<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MapReduce论文阅读 | tinylcy</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MapReduce论文阅读</h1><a id="logo" href="/.">tinylcy</a><p class="description">辰洋的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MapReduce论文阅读</h1><div class="post-meta">Jan 7, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>大四时曾经粗略的阅读过这篇<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">论文</a>，并且已经写过不少的<code>MapReduce</code>程序，所以介绍性的内容不再赘述。再次阅读这篇论文的原因是为了更系统的学习分布式的相关知识，我开始跟进<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="external">MIT 6.824: Distributed Systems</a>，而完成这门课程的第一个<code>lab</code>的前提便是阅读这篇论文。</p>
<p>这篇笔记重点分析了<code>MapReduce</code>的<strong>执行流程</strong>以及<strong>容错机制</strong>，因为是个人理解，若有分析不妥之处欢迎发送邮件至<code>tinylcy (at) gmail.com</code>讨论交流。</p>
<h2 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h2><p>根据不同的环境，<code>MapReduce</code>的实现方式有多种，比如基于共享内存、基于<code>NUMA</code>多处理器环境等等。而<code>Google</code>内部实现的<code>MapReduce</code>基于如下环境。</p>
<ul>
<li>双核<code>x86</code>处理器，<code>Linux</code>操作系统，每台机器有<code>2～4GB</code>的内存。</li>
<li>使用商用的网络设备，例如<code>100M</code>／<code>1G</code>带宽网卡。</li>
<li>集群是由成百上千台上述配置的设备组成的，因此集群中节点出现故障应该视为常态。</li>
<li>存储设备采用的是廉价的<code>IDE</code>硬盘。在这种不可靠的硬件上，<code>Google</code>实现了一个分布式文件系统<code>GFS</code>，通过备份和冗余来保证可靠性和可用性。</li>
<li>用户将作业（<code>job</code>）提交到调度系统，每个作业由多个任务（<code>task</code>）组成，调度系统负责将任务分配到集群空闲的节点上。</li>
</ul>
<p>在<code>Map</code>阶段，输入数据会被自动划分为<code>M</code>个分片，这些分片可以在不同的节点上被并行处理。在<code>Reduce</code>阶段，根据一定的划分规则（例如<code>hash(key) mod R</code>），中间数据会被划分为<code>R</code>个分片，这<code>R</code>个分片也可以被多个节点同时处理。<code>Reduce</code>阶段的分片个数<code>R</code>和分片规则可以由用户指定。<code>MapReduce</code>的执行流程如下图所示。</p>
<p><img src="/img/2017-01-07-Image 1.png" alt="Alt text"></p>
<p>整个执行流程可以划分为如下几个阶段，上图中的数字也标识了这几个阶段。</p>
<ul>
<li>用户程序将输入数据切分为<code>M</code>个分片（分片的大小一般为<code>16～64MB</code>，用户可以设置分片大小），并把用户程序拷贝到集群中的多个节点。因为数据要比程序大得多，所以“拷贝程序”要比“拷贝数据”高效的多。</li>
<li>在拷贝程序到节点的过程中，有一个节点比较特殊：<code>master</code>节点。其余的节点都为<code>worker</code>节点，<code>worker</code>节点负责执行具体的任务，这些任务通过<code>master</code>节点来分配。任务又分为<code>map task</code>和<code>reduce task</code>。</li>
<li>被分配到<code>map task</code>的<code>worker（map worker）</code>会读取相应的输入分片，并将输入分片中的数据解析为一系列的<code>key/value pairs</code>，然后将这些<code>key/value pairs</code>输入到用户定义的<code>map function</code>，<code>map function</code>输出的<code>key/value pairs</code>会被缓存到内存中，而不是直接写入磁盘。</li>
<li>由<code>map function</code>输出的，缓存在内存中的<code>key/value pairs</code>会被划分为<code>R</code>个分区，并定期写入到<strong>本地</strong>磁盘中。写入磁盘的位置会被推送给<code>master</code>节点，<code>master</code>节点会将磁盘的位置信息转发给下一阶段执行<code>reduce</code>任务的节点（<code>reduce worker</code>）。</li>
<li><code>reduce worker</code>在接收到磁盘的位置信息后开始读取相应的磁盘中的数据，当所有的数据读取完毕后，<code>reduce worker</code>会在内存中按照<code>key</code>将所有的<code>key/value pairs</code>进行一次排序。论文认为这次排序是必要的原因是不同的<code>key</code>往往会映射到同一个<code>reduce worker</code>。</li>
<li><code>reducer worker</code>遍历已排好序的<code>key/value pairs</code>，每遇到一个不同的<code>key</code>，便将该<code>key</code>和对应的一系列<code>value</code>传递给用户定义的<code>reduce function</code>，这个过程同时解释了为什么在上一阶段<code>reduce worker</code>要对数据进行排序（论文<code>Section 4.2</code>提到了按照key排序的两个优势，一是支持高效随机按<code>key</code>的查找，二是已经排好序的数据可以方便用户的操作）。<code>reduce function</code>将输出数据<code>append</code>到最终的输出文件中。</li>
<li>当所有的<code>map task</code>和<code>reduce task</code>都完成了，<code>master</code>唤醒用户程序并返回。</li>
</ul>
<p>在执行完整个流程后，会有<code>R</code>个输出文件，每个<code>reduce worker</code>对应一个。这<code>R</code>个输出文件一般不需要合并，因为它们往往是下一个<code>MapReduce</code>处理逻辑的输入数据。</p>
<h2 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h2><ul>
<li><code>master</code>会记录每个<code>map task</code>和<code>reduce task</code>的状态，包括<code>idle</code>、<code>in-progress</code>和<code>completed</code>。同时，<code>master</code>还会记录<code>non-idle task</code>对应的<code>worker</code>的信息。</li>
<li>对于每个<code>map task</code>，<code>master</code>会记录下<code>map function</code>输出的<code>R</code>个分片的位置信息和大小。这些信息会被推送到处于<code>in-progress</code>状态的<code>reduce worker</code>上。</li>
</ul>
<h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>由于运行在规模庞大并且廉价的硬件上，因此容错性变得非常重要。</p>
<h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p><code>master</code>会定期<code>ping</code> <code>worker</code>，如果<code>worker</code>没有响应并且超过了一定的次数，那么<code>master</code>就认为<code>worker</code>已经<code>failed</code>了。因此，所有在该<code>worker</code>上完成的<code>task</code>的状态将会被重置为初始的<code>idle</code>状态，并且这些<code>task</code>需要被重新分配到其它的<code>worker</code>上去。类似的，该<code>worker</code>上处于<code>in-progress</code>状态的<code>task</code>也会被重置为最初的<code>idle</code>状态，并被重新分配到其它<code>worker</code>上去。</p>
<p>对于已完成的<code>map task</code>，也需要重新被执行。因为<code>map task</code>的输出是在<code>worker</code>的本地磁盘上，因为<code>worker</code>已经失联了，所以<code>map task</code>的输出数据自然也获取不到。对于已完成的<code>reduce task</code>，不再需要重新执行。因为<code>reduce task</code>的输出是在全局的文件系统（<code>GFS</code>）上。</p>
<p>如果一个<code>map task</code>一开始运行在<code>worker A</code>上，接着由于<code>worker A</code> <code>failed</code>导致该<code>map task</code>迁移到<code>worker B</code>上。那么读取该<code>map task</code>输出数据并且处于正在执行的<code>reduce worker</code>会收到重新执行<code>reduce task</code>的通知，任何还未开始读取数据的<code>reduce task</code>也会收到通知。<code>reduce worker</code>接下来会从<code>worker B</code>上读取数据。</p>
<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>可以通过定期建立检查点的方式来保存<code>master</code>的状态。但是，<code>Google</code>当时的做法是考虑到只有一个<code>master</code>，所以<code>master</code>出现故障的概率很小，如果出现故障了，重新开始整个<code>MapReduce</code>计算。</p>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>网络带宽在计算环境中属于一种非常稀缺的资源，利用输入数据的特性可以减小网络带宽。</p>
<ul>
<li>输入数据由<code>GFS</code>来管理，<code>GFS</code>把数据存储在集群节点的本地磁盘上，<code>GFS</code>将文件分割为<code>64MB</code>大小的块，并且针对每个块会做冗余（一般冗余<code>2</code>份）。<code>master</code>利用输入数据的位置信息，将<code>map task</code>分配给输入数据所在的节点。</li>
<li>如果在计算过程中出现了失败的情况，那么<code>master</code>会把任务调度给离输入数据较近的节点。</li>
</ul>
<h2 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h2><p>从上文我们可以得知，<code>map</code>阶段被划分成<code>M</code>个<code>task</code>，<code>reduce</code>阶段被划分成<code>R</code>个<code>task</code>，<code>M</code>和<code>R</code>一般会比集群中节点的个数大得多。每个节点运行多个<code>task</code>有利于动态的负载均衡，加速<code>worker</code>从失败中恢复。</p>
<p>在具体的实现中，<code>M</code>和<code>R</code>的大小是有实际限制的，因为<code>master</code>至少要做<code>O(M＋R)</code>次的调度决策，并且需要保持<code>O(M*R)</code>个状态。</p>
<p>通常情况下，<code>R</code>的大小是由用户指定的，而对<code>M</code>的选择要保证每个<code>task</code>的输入数据大小，即一个输入分片在<code>16MB～64MB</code>之间，这样可以最大化的利用数据本地性。</p>
<h2 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h2><p>导致整个<code>MapReduce</code>计算过程被延迟的原因之一是过多的时间花费在最后几个<code>map task</code>或<code>reduce task</code>上。导致这个问题的原因由很多，可能是因为<code>task</code>所在的节点硬盘的读写速度非常慢，同时<code>master</code>又有可能把新的<code>task</code>分配给了该节点，所以引入了更加激烈的<code>CPU</code>竞争、内存竞争。</p>
<p>一种通用的解决方案是在整个<code>MapReduce</code>计算快要结束时，<code>master</code>对当前处于<code>in-progress</code>状态的<code>task</code>进行备份，无论是原来的<code>task</code>执行完毕还是备份的<code>task</code>执行完毕，那么就认为该<code>task</code>完成了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce: Simplified Data Processing on Large Clusters</a></li>
</ul>
</div><div class="tags"><a href="/tags/Distributed-System/">Distributed System</a></div><div class="post-nav"><a href="/2017/01/04/Bigtable论文阅读/" class="pre">Bigtable论文阅读</a><a href="/2017/01/10/CSAPP-Shell-Lab/" class="next">CSAPP: Shell Lab</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://tinylcy.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Unix-Linux/" style="font-size: 15px;">Unix/Linux</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/Distributed-System/" style="font-size: 15px;">Distributed System</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://wdxtub.com/" title="wdxtub" target="_blank">wdxtub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a>2017 </a><a href="/." rel="nofollow">tinylcy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>