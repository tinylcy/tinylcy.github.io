<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tinylcy</title>
  <subtitle>辰洋的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tinylcy.me/"/>
  <updated>2017-04-27T06:59:49.000Z</updated>
  <id>http://tinylcy.me/</id>
  
  <author>
    <name>tinylcy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP: Bomb Lab</title>
    <link href="http://tinylcy.me/2017/04/26/CSAPP-Bomb-Lab/"/>
    <id>http://tinylcy.me/2017/04/26/CSAPP-Bomb-Lab/</id>
    <published>2017-04-26T11:14:51.000Z</published>
    <updated>2017-04-27T06:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Bomb Lab</code>是<code>CS:APP</code>一书中的第二个<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf" target="_blank" rel="external">实验</a>，实验中的<code>bomb</code>实际上是一个程序的二进制文件，该程序由一系列<code>phase</code>组成，每个<code>phase</code>需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印<code>BOOM!!!</code>。</p>
<a id="more"></a>
<p>完成整个实验的思路是通过<code>objdump</code>对<code>bome</code>进行反编译（<code>objdump -d bomb &gt; bomb.txt</code>），获取所有的汇编代码。提取每个阶段对应的代码并借助<code>gdb</code>进行分析，逐一拆弹。</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p><code>phase_1</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0000000000400ee0 &lt;phase_1&gt;:</div><div class="line">  400ee0: 48 83 ec 08           sub    $0x8,%rsp</div><div class="line">  400ee4: be 00 24 40 00        mov    $0x402400,%esi</div><div class="line">  400ee9: e8 4a 04 00 00        callq  401338 &lt;strings_not_equal&gt;</div><div class="line">  400eee: 85 c0                 test   %eax,%eax</div><div class="line">  400ef0: 74 05                 je     400ef7 &lt;phase_1+0x17&gt;</div><div class="line">  400ef2: e8 43 05 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400ef7: 48 83 c4 08           add    $0x8,%rsp</div><div class="line">  400efb: c3                    retq</div></pre></td></tr></table></figure>
<p>由<code>callq</code>指令可以得知，<code>phase_1</code>调用了<code>strings_not_equal</code>，并将返回值存储于<code>%eax</code>中，<code>test</code>指令计算<code>%eax</code>的值是否等于<code>0</code>，<code>je</code>指令决定是否跳转，若<code>%eax</code>的值等于<code>0</code>，则跳转至<code>0x400ef7</code>处，也就是安全区域，拆弹成功，否则不跳转，即执行<code>explode_bomb</code>，拆弹失败。通过以上分析，可以得知<code>phase_1</code>的关键在于控制<code>strings_not_equal</code>的返回值。</p>
<p>在执行<code>callq strings_not_equal</code>指令之前，<code>mov $0x402400,%esi</code>将常数<code>0x402400</code>传递至<code>%esi</code>，根据<code>x86-64</code>寄存器使用规范，<code>%esi</code>的值是<code>strings_not_equal</code>函数的第二个参数，而第一个参数则是我们输入的值。因此，问题的关键在于如何得到<code>%esi</code>的值。</p>
<p>利用<code>gdb</code>对<code>bomb</code>进行调试，并在<code>phase_1</code>处设置断点，通过<code>disassemble</code>对当前函数进行反编译，使用<code>stepi</code>对指令进行单步调试，运行至<code>phase_1</code>第一条指令的初始状态如下图所示。</p>
<p><img src="/img/2017-04-26-Image 1.png" alt=""></p>
<p>在进入<code>phase_1</code>之前，<code>read_line</code>函数从终端读取输入（可从<code>bomb.c</code>得知该信息，我输入的是<code>tinylcy</code>）。接着，通过<code>stepi</code>单步执行指令，直至指令<code>mov $0x402400,%esi</code>执行完毕，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 2.png" alt=""></p>
<p>此时，<code>strings_not_equal</code>函数的第二个参数已经存储于<code>%esi</code>，通过<code>print</code>打印<code>%esi</code>的值，可以得知<code>%esi</code>存储的是一个内存地址，这是因为参数类型是字符串类型，因此寄存器存储的是内存地址，而非确切的字符串值，使用<code>x</code>打印位于地址<code>%esi</code>处的内容，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 3.png" alt=""></p>
<p>由此，我们得到了拆除<code>pahse_1</code>炸弹所需要的字符串。</p>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><p><code>phase_2</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">0000000000400efc &lt;phase_2&gt;:</div><div class="line">  400efc: 55                    push   %rbp</div><div class="line">  400efd: 53                    push   %rbx</div><div class="line">  400efe: 48 83 ec 28           sub    $0x28,%rsp</div><div class="line">  400f02: 48 89 e6              mov    %rsp,%rsi</div><div class="line">  400f05: e8 52 05 00 00        callq  40145c &lt;read_six_numbers&gt;</div><div class="line">  400f0a: 83 3c 24 01           cmpl   $0x1,(%rsp)</div><div class="line">  400f0e: 74 20                 je     400f30 &lt;phase_2+0x34&gt;</div><div class="line">  400f10: e8 25 05 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400f15: eb 19                 jmp    400f30 &lt;phase_2+0x34&gt;</div><div class="line">  400f17: 8b 43 fc              mov    -0x4(%rbx),%eax</div><div class="line">  400f1a: 01 c0                 add    %eax,%eax</div><div class="line">  400f1c: 39 03                 cmp    %eax,(%rbx)</div><div class="line">  400f1e: 74 05                 je     400f25 &lt;phase_2+0x29&gt;</div><div class="line">  400f20: e8 15 05 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400f25: 48 83 c3 04           add    $0x4,%rbx</div><div class="line">  400f29: 48 39 eb              cmp    %rbp,%rbx</div><div class="line">  400f2c: 75 e9                 jne    400f17 &lt;phase_2+0x1b&gt;</div><div class="line">  400f2e: eb 0c                 jmp    400f3c &lt;phase_2+0x40&gt;</div><div class="line">  400f30: 48 8d 5c 24 04        lea    0x4(%rsp),%rbx</div><div class="line">  400f35: 48 8d 6c 24 18        lea    0x18(%rsp),%rbp</div><div class="line">  400f3a: eb db                 jmp    400f17 &lt;phase_2+0x1b&gt;</div><div class="line">  400f3c: 48 83 c4 28           add    $0x28,%rsp</div><div class="line">  400f40: 5b                    pop    %rbx</div><div class="line">  400f41: 5d                    pop    %rbp</div><div class="line">  400f42: c3                    retq</div></pre></td></tr></table></figure>
<p>由<code>callq read_six_numbers</code>可知，<code>phase_2</code>调用了<code>read_six_numbers</code>函数并读取了<code>6</code>个数值。根据<code>cmpl $0x1,(%rsp)</code>可知，若地址<code>%rsp</code>处的值等于<code>1</code>，那么进入安全区域，否则就会引爆炸弹。由此可以得知，我们输入的第<code>1</code>个数字应该为<code>1</code>。然后<code>phase_2</code>跳转至<code>0x400f30</code>处执行指令<code>lea 0x4(%rsp),%rbx</code>，该指令的效果是将<code>%rsp</code>的值加<code>4</code>并存储于<code>%rbx</code>，这意味着<code>%rbx</code>的值实际上是下一个数的地址值。<code>lea 0x18(%rsp),%rbp</code>用于控制循环的次数，<code>6</code>个整型共占用<code>24</code>字节，恰好等于<code>0x18</code>。接着<code>phase_2</code>跳转至<code>0x400f17</code>处执行<code>mov -0x4(%rbx),%eax</code>指令，该指令的效果是使<code>%eax</code>的值等于<code>M[%rbx-4]</code>的值，即<code>M[%rsp]</code>的值，也就是第<code>1</code>个数的值。<code>add %eax,%eax</code>使<code>%eax</code>的值扩大为原来的<code>2</code>倍，<code>cmp %eax,(%rbx)</code>将下一个数的值与<code>%eax</code>的值作比较，若相等则跳转至安全区域<code>0x400f25</code>，否则拆弹失败。<code>0x400f25</code>处的指令为<code>add $0x4,%rbx</code>，该指令的效果是使<code>%rbx</code>存储下一个数的地址，与<code>%rbp</code>的值比较并在不相等的情况下跳转至<code>0x400f17</code>处循环执行指令。</p>
<p>综上，<code>phase_2</code>通过<code>%rbx</code>来获取输入的<code>6</code>个数字，通过<code>%eax</code>来控制比较的数值大小，<code>%eax</code>初始化为第<code>1</code>个数字的值，并在每次循环后增长至原来的<code>2</code>倍，一共<code>6</code>次循环。所以<code>phase_2</code>的解为<code>1 2 4 8 16 32</code>。</p>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><p><code>phase_3</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">0000000000400f43 &lt;phase_3&gt;:</div><div class="line">  400f43: 48 83 ec 18           sub    $0x18,%rsp</div><div class="line">  400f47: 48 8d 4c 24 0c        lea    0xc(%rsp),%rcx</div><div class="line">  400f4c: 48 8d 54 24 08        lea    0x8(%rsp),%rdx</div><div class="line">  400f51: be cf 25 40 00        mov    $0x4025cf,%esi</div><div class="line">  400f56: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  400f5b: e8 90 fc ff ff        callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</div><div class="line">  400f60: 83 f8 01              cmp    $0x1,%eax</div><div class="line">  400f63: 7f 05                 jg     400f6a &lt;phase_3+0x27&gt;</div><div class="line">  400f65: e8 d0 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400f6a: 83 7c 24 08 07        cmpl   $0x7,0x8(%rsp)</div><div class="line">  400f6f: 77 3c                 ja     400fad &lt;phase_3+0x6a&gt;</div><div class="line">  400f71: 8b 44 24 08           mov    0x8(%rsp),%eax</div><div class="line">  400f75: ff 24 c5 70 24 40 00  jmpq   *0x402470(,%rax,8)</div><div class="line">  400f7c: b8 cf 00 00 00        mov    $0xcf,%eax</div><div class="line">  400f81: eb 3b                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f83: b8 c3 02 00 00        mov    $0x2c3,%eax</div><div class="line">  400f88: eb 34                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f8a: b8 00 01 00 00        mov    $0x100,%eax</div><div class="line">  400f8f: eb 2d                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f91: b8 85 01 00 00        mov    $0x185,%eax</div><div class="line">  400f96: eb 26                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f98: b8 ce 00 00 00        mov    $0xce,%eax</div><div class="line">  400f9d: eb 1f                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f9f: b8 aa 02 00 00        mov    $0x2aa,%eax</div><div class="line">  400fa4: eb 18                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400fa6: b8 47 01 00 00        mov    $0x147,%eax</div><div class="line">  400fab: eb 11                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400fad: e8 88 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400fb2: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  400fb7: eb 05                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400fb9: b8 37 01 00 00        mov    $0x137,%eax</div><div class="line">  400fbe: 3b 44 24 0c           cmp    0xc(%rsp),%eax</div><div class="line">  400fc2: 74 05                 je     400fc9 &lt;phase_3+0x86&gt;</div><div class="line">  400fc4: e8 71 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400fc9: 48 83 c4 18           add    $0x18,%rsp</div><div class="line">  400fcd: c3                    retq</div></pre></td></tr></table></figure>
<p>前<code>3</code>条指令非常普通，并不能吸引我们的注意，能够吸引我们的是<code>mov $0x4025cf,%esi</code>这条指令，常数<code>0x4025cf</code>应该是个内存地址，打印该内存地址的值，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 4.png" alt=""></p>
<p>很容易把<code>%d %d</code>与<code>callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</code>这条指令联系起来，由此我们基本知道，<code>phase_3</code>会输入<code>2</code>个值。<code>scanf</code>函数的返回值存储于<code>%eax</code>，该值代表输入值的个数，<code>cmp $0x1,%eax</code>将<code>%eax</code>的值与<code>1</code>做比较，如果输入值的个数大于<code>1</code>，跳转至安全区域，即指令<code>cmpl $0x7,0x8(%rsp)</code>处，否则拆弹失败。<code>cmpl   $0x7,0x8(%rsp)</code>将输入的第一个数(以<code>6</code>为例)与<code>7</code>作比较，如果大于<code>7</code>，那么拆弹失败，否则执行指令<code>mov 0x8(%rsp),%eax</code>，该指令将第一个数存储于<code>%eax</code>中。接着执行指令<code>jmpq *0x402470(,%rax,8)</code>，该指令是一个间接跳转指令，通过<code>gdb</code>得到执行该指令后的跳转位置，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 5.png" alt=""></p>
<p><code>mov $0x2aa,%eax</code>指令将常数<code>0x2aa</code>移至<code>%eax</code>，然后执行<code>jmp 0x400fbe &lt;phase_3+123&gt;</code>跳转至<code>0x400fbe</code>处执行指令<code>cmp 0xc(%rsp),%eax</code>，该指令将第二个数与<code>%eax</code>做比较，若相等，安全退出，拆弹成功，否则拆弹失败。<code>0x2aa</code>的十进制值为<code>682</code>，因此<code>phase_3</code>输入的两个数应为<code>6</code>，<code>682</code>。</p>
<p>注意，第一个数并不一定是<code>6</code>，只要小于<code>7</code>即可。当第一个数的取值改变，那么在获取第二个数时会跳转到不同的分支，因此会得到不同的值。例如当第一个数等于<code>5</code>，那么第二个数应为<code>206</code>。</p>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><p><code>phase_4</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">000000000040100c &lt;phase_4&gt;:</div><div class="line">  40100c: 48 83 ec 18           sub    $0x18,%rsp</div><div class="line">  401010: 48 8d 4c 24 0c        lea    0xc(%rsp),%rcx</div><div class="line">  401015: 48 8d 54 24 08        lea    0x8(%rsp),%rdx</div><div class="line">  40101a: be cf 25 40 00        mov    $0x4025cf,%esi</div><div class="line">  40101f: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  401024: e8 c7 fb ff ff        callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</div><div class="line">  401029: 83 f8 02              cmp    $0x2,%eax</div><div class="line">  40102c: 75 07                 jne    401035 &lt;phase_4+0x29&gt;</div><div class="line">  40102e: 83 7c 24 08 0e        cmpl   $0xe,0x8(%rsp)</div><div class="line">  401033: 76 05                 jbe    40103a &lt;phase_4+0x2e&gt;</div><div class="line">  401035: e8 00 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  40103a: ba 0e 00 00 00        mov    $0xe,%edx</div><div class="line">  40103f: be 00 00 00 00        mov    $0x0,%esi</div><div class="line">  401044: 8b 7c 24 08           mov    0x8(%rsp),%edi</div><div class="line">  401048: e8 81 ff ff ff        callq  400fce &lt;func4&gt;</div><div class="line">  40104d: 85 c0                 test   %eax,%eax</div><div class="line">  40104f: 75 07                 jne    401058 &lt;phase_4+0x4c&gt;</div><div class="line">  401051: 83 7c 24 0c 00        cmpl   $0x0,0xc(%rsp)</div><div class="line">  401056: 74 05                 je     40105d &lt;phase_4+0x51&gt;</div><div class="line">  401058: e8 dd 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  40105d: 48 83 c4 18           add    $0x18,%rsp</div><div class="line">  401061: c3                    retq</div></pre></td></tr></table></figure>
<p>和<code>phase_3</code>类似，首先将内存地址为<code>0x4025cf</code>的内容打印出来，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 6.png" alt=""></p>
<p>由此得知，<code>phase_4</code>的输入应该为<code>2</code>个整数。在执行<code>callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</code>指令后，返回值存储于<code>%eax</code>，然后判断<code>%eax</code>的值是否等于<code>2</code>，若不等于则会引爆炸弹，否则执行指令<code>cmpl $0xe,0x8(%rsp)</code>，该指令将输入的第一个数与常数<code>0xe</code>做比较，根据<code>jbe 40103a &lt;phase_4+0x2e&gt;</code>，如果输入的第一个数大于<code>0xe</code>，那么拆弹失败，否则跳转到<code>0x40103a</code>处执行<code>mov $0xe,%edx</code>指令。接下来可以看到<code>phase_4</code>调用了函数<code>func4</code>，而<code>mov $0xe,%edx</code>、<code>mov $0x0,%esi</code>和<code>mov 0x8(%rsp),%edi</code>这三条指令用于设置<code>func4</code>的参数，根据<code>x86-64</code>寄存器使用规范，第一个、第二个和第三个参数分别存储于寄存器<code>%edi</code>、<code>%esi</code>和<code>%edx</code>。</p>
<p>在查看<code>func4</code>对应的代码之前，先观察执行<code>callq  400fce &lt;func4&gt;</code>指令之后<code>phase_4</code>的操作：<code>test %eax,%eax</code>指令检查<code>%eax</code>的值是否等于<code>0</code>，如果不等于<code>0</code>，则会引爆炸弹，否则执行指令<code>cmpl $0x0,0xc(%rsp)</code>，该指令将输入的第二个数与<code>0</code>做比较，如果相等，那么<code>phase_4</code>正常退出，拆弹成功。因此，<code>phase_4</code>的第二个输入值即为<code>0</code>。</p>
<p>经过以上的分析，可以意识到<code>phase_4</code>的核心目标在于要让<code>func4</code>执行后，<code>%eax</code>的值等于<code>0</code>，这取决于输入的第一个数。接着需要分析<code>func4</code>执行的操作，其对应代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">0000000000400fce &lt;func4&gt;:</div><div class="line">  400fce: 48 83 ec 08           sub    $0x8,%rsp</div><div class="line">  400fd2: 89 d0                 mov    %edx,%eax</div><div class="line">  400fd4: 29 f0                 sub    %esi,%eax</div><div class="line">  400fd6: 89 c1                 mov    %eax,%ecx</div><div class="line">  400fd8: c1 e9 1f              shr    $0x1f,%ecx</div><div class="line">  400fdb: 01 c8                 add    %ecx,%eax</div><div class="line">  400fdd: d1 f8                 sar    %eax</div><div class="line">  400fdf: 8d 0c 30              lea    (%rax,%rsi,1),%ecx</div><div class="line">  400fe2: 39 f9                 cmp    %edi,%ecx</div><div class="line">  400fe4: 7e 0c                 jle    400ff2 &lt;func4+0x24&gt;</div><div class="line">  400fe6: 8d 51 ff              lea    -0x1(%rcx),%edx</div><div class="line">  400fe9: e8 e0 ff ff ff        callq  400fce &lt;func4&gt;</div><div class="line">  400fee: 01 c0                 add    %eax,%eax</div><div class="line">  400ff0: eb 15                 jmp    401007 &lt;func4+0x39&gt;</div><div class="line">  400ff2: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  400ff7: 39 f9                 cmp    %edi,%ecx</div><div class="line">  400ff9: 7d 0c                 jge    401007 &lt;func4+0x39&gt;</div><div class="line">  400ffb: 8d 71 01              lea    0x1(%rcx),%esi</div><div class="line">  400ffe: e8 cb ff ff ff        callq  400fce &lt;func4&gt;</div><div class="line">  401003: 8d 44 00 01           lea    0x1(%rax,%rax,1),%eax</div><div class="line">  401007: 48 83 c4 08           add    $0x8,%rsp</div><div class="line">  40100b: c3                    retq</div></pre></td></tr></table></figure>
<p>在分析<code>func4</code>之前，不要忘了传递到<code>func4</code>的三个参数分别存储于寄存器<code>%edi</code>、<code>%esi</code>和<code>%edx</code>，其值分别为<code>x</code>(输入的第一个数)、<code>0</code>和<code>14</code>。在<code>0x400fe9</code>处执行了指令<code>callq 400fce &lt;func4&gt;</code>，因此<code>func4</code>很可能是个递归函数，我们将<code>func4</code>翻译成等价的<code>C</code>代码，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = z - y;</div><div class="line">    <span class="keyword">int</span> k = t &gt;&gt; <span class="number">31</span>;</div><div class="line">    t = (t + k) &gt;&gt; <span class="number">1</span>;</div><div class="line">    k = t + y;</div><div class="line">    <span class="keyword">if</span>(k &lt;= x) &#123;</div><div class="line">        t = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(k &gt;= x) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            y = k + <span class="number">1</span>;</div><div class="line">            func4(x, y, z);</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        z = k - <span class="number">1</span>;</div><div class="line">        func4(x, y, z);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>func4</code>的目的是要让函数退出后<code>%eax</code>的值为<code>0</code>，而在<code>0x400ff2</code>处<code>mov $0x0,%eax</code>显示的将<code>%eax</code>的值设置为<code>0</code>，该指令对应于<code>C</code>代码中的<code>t = 0</code>。并且，<code>func4</code>执行递归的退出条件为<code>k == x</code>，其中<code>x</code>对应于输入的第一个数，而<code>k</code>则可以通过一系列计算得到，由于<code>y = 0</code>且<code>z = 14</code>，易知<code>k = 7</code>，因此输入的第一个数即为<code>7</code>。将字符串<code>7 0</code>作为<code>phase_4</code>的输入，拆弹成功，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 7.png" alt=""></p>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><p><code>phase_5</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">0000000000401062 &lt;phase_5&gt;:</div><div class="line">  401062: 53                    push   %rbx</div><div class="line">  401063: 48 83 ec 20           sub    $0x20,%rsp</div><div class="line">  401067: 48 89 fb              mov    %rdi,%rbx</div><div class="line">  40106a: 64 48 8b 04 25 28 00  mov    %fs:0x28,%rax</div><div class="line">  401071: 00 00 </div><div class="line">  401073: 48 89 44 24 18        mov    %rax,0x18(%rsp)</div><div class="line">  401078: 31 c0                 xor    %eax,%eax</div><div class="line">  40107a: e8 9c 02 00 00        callq  40131b &lt;string_length&gt;</div><div class="line">  40107f: 83 f8 06              cmp    $0x6,%eax</div><div class="line">  401082: 74 4e                 je     4010d2 &lt;phase_5+0x70&gt;</div><div class="line">  401084: e8 b1 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  401089: eb 47                 jmp    4010d2 &lt;phase_5+0x70&gt;</div><div class="line">  40108b: 0f b6 0c 03           movzbl (%rbx,%rax,1),%ecx</div><div class="line">  40108f: 88 0c 24              mov    %cl,(%rsp)</div><div class="line">  401092: 48 8b 14 24           mov    (%rsp),%rdx</div><div class="line">  401096: 83 e2 0f              and    $0xf,%edx</div><div class="line">  401099: 0f b6 92 b0 24 40 00  movzbl 0x4024b0(%rdx),%edx</div><div class="line">  4010a0: 88 54 04 10           mov    %dl,0x10(%rsp,%rax,1)</div><div class="line">  4010a4: 48 83 c0 01           add    $0x1,%rax</div><div class="line">  4010a8: 48 83 f8 06           cmp    $0x6,%rax</div><div class="line">  4010ac: 75 dd                 jne    40108b &lt;phase_5+0x29&gt;</div><div class="line">  4010ae: c6 44 24 16 00        movb   $0x0,0x16(%rsp)</div><div class="line">  4010b3: be 5e 24 40 00        mov    $0x40245e,%esi</div><div class="line">  4010b8: 48 8d 7c 24 10        lea    0x10(%rsp),%rdi</div><div class="line">  4010bd: e8 76 02 00 00        callq  401338 &lt;strings_not_equal&gt;</div><div class="line">  4010c2: 85 c0                 test   %eax,%eax</div><div class="line">  4010c4: 74 13                 je     4010d9 &lt;phase_5+0x77&gt;</div><div class="line">  4010c6: e8 6f 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  4010cb: 0f 1f 44 00 00        nopl   0x0(%rax,%rax,1)</div><div class="line">  4010d0: eb 07                 jmp    4010d9 &lt;phase_5+0x77&gt;</div><div class="line">  4010d2: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  4010d7: eb b2                 jmp    40108b &lt;phase_5+0x29&gt;</div><div class="line">  4010d9: 48 8b 44 24 18        mov    0x18(%rsp),%rax</div><div class="line">  4010de: 64 48 33 04 25 28 00  xor    %fs:0x28,%rax</div><div class="line">  4010e5: 00 00 </div><div class="line">  4010e7: 74 05                 je     4010ee &lt;phase_5+0x8c&gt;</div><div class="line">  4010e9: e8 42 fa ff ff        callq  400b30 &lt;__stack_chk_fail@plt&gt;</div><div class="line">  4010ee: 48 83 c4 20           add    $0x20,%rsp</div><div class="line">  4010f2: 5b                    pop    %rbx</div><div class="line">  4010f3: c3                    retq</div></pre></td></tr></table></figure>
<p>根据<code>x86-64</code>寄存器使用规范，<code>%rdi</code>寄存器存储的是第一个参数的值，由于输入的是字符串，因此<code>%rdi</code>存储的应该是输入字符串的起始地址。<code>0x401067</code>处的指令<code>mov %rdi,%rbx</code>将字符串起始地址保存在<code>%rbx</code>中，即<code>%rbx</code>为基址寄存器。指令<code>xor %eax,%eax</code>的作用是将<code>%eax</code>清零，接着调用<code>string_length</code>函数获取输入字符串的长度，并将长度值（返回值）存储于<code>%eax</code>。指令<code>cmp $0x6,%eax</code>将<code>string_length</code>的返回值与常数<code>6</code>作比较，若不相等则会引爆炸弹，由此可以得知，<code>phase_5</code>的输入字符串长度应该等于<code>6</code>。</p>
<p>当输入字符串的长度等于<code>6</code>，<code>phase_5</code>跳转至<code>0x4010d2</code>处执行指令<code>mov $0x0,%eax</code>，接着又跳转至<code>0x40108b</code>处执行指令<code>movzbl (%rbx,%rax,1),%ecx</code>，可以发现<code>0x40108b</code>至<code>0x4010ac</code>构成了一个循环，且在循环退出后在<code>0x4010bd</code>处调动了<code>strings_not_equal</code>来比较字符串是否相等，若相等，则拆弹成功。其中，由<code>mov $0x40245e,%esi</code>指令可知，待比较的字符串存储于地址<code>0x40245e</code>处，打印以该地址作为起始地址的字符串，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 8.png" alt=""></p>
<p>待比较的字符串为<code>flyers</code>，且长度也为<code>6</code>。所以，接下来的关键任务是需要对循环操作进行分析，理解该循环操作对输入字符串做了哪些操作。提取循环操作的代码，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">40108b: 0f b6 0c 03           movzbl (%rbx,%rax,1),%ecx</div><div class="line">40108f: 88 0c 24              mov    %cl,(%rsp)</div><div class="line">401092: 48 8b 14 24           mov    (%rsp),%rdx</div><div class="line">401096: 83 e2 0f              and    $0xf,%edx</div><div class="line">401099: 0f b6 92 b0 24 40 00  movzbl 0x4024b0(%rdx),%edx</div><div class="line">4010a0: 88 54 04 10           mov    %dl,0x10(%rsp,%rax,1)</div><div class="line">4010a4: 48 83 c0 01           add    $0x1,%rax</div><div class="line">4010a8: 48 83 f8 06           cmp    $0x6,%rax</div><div class="line">4010ac: 75 dd                 jne    40108b &lt;phase_5+0x29&gt;</div></pre></td></tr></table></figure>
<p>由于<code>%rbx</code>存储的是输入字符串的起始地址，<code>%rax</code>初始化为<code>0</code>，其作用等价于下标，因此<code>movzbl (%rbx,%rax,1),%ecx</code>指令的作用是将字符串的第<code>%rax</code>个字符存储于<code>%ecx</code>，<code>movzbl</code>意味做了零扩展。接着，<code>mov  %cl,(%rsp)</code>指令取<code>%ecx</code>的低<code>8</code>位，即一个字符的大小，通过内存间接存储至<code>%rdx</code>中。<code>and  $0xf,%edx</code>指令将<code>%edx</code>的值与常数<code>0xf</code>进行位与，由指令<code>movzbl 0x4024b0(%rdx),%edx</code>可知，位与后的值将会作为偏移量，以<code>0x4024b0</code>为基址，将偏移后的值存储至<code>%edx</code>。最后，指令<code>mov %dl,0x10(%rsp,%rax,1)</code>以<code>%edx</code>低<code>8</code>位的值作为新的字符，对原有字符进行替换。</p>
<p>综上，<code>phase_5</code>遍历输入字符串的每个字符，将字符的低<code>4</code>位作为偏移量，以<code>0x4024b0</code>为起始地址，将新地址对应的字符替换原有字符，最终得到<code>flyers</code>字符串。打印<code>0x4024b0</code>处的内容，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 9.png" alt=""></p>
<p>例如，如果要得到字符<code>f</code>，那么偏移量应为<code>9</code>，二进制表示为<code>1001</code>，通过查找<code>ASCII</code>表，可知字符<code>i</code>的<code>ASCII</code>编码为<code>01101001</code>，满足要求。剩余<code>5</code>个字符采用同样的策略可以依次求得，最终，<code>phase_5</code>的输入字符串为<code>ionefg</code>。</p>
<h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase 6"></a>Phase 6</h2><p><code>phase_6</code>对应的代码非常长，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">00000000004010f4 &lt;phase_6&gt;:</div><div class="line">  4010f4: 41 56                 push   %r14</div><div class="line">  4010f6: 41 55                 push   %r13</div><div class="line">  4010f8: 41 54                 push   %r12</div><div class="line">  4010fa: 55                    push   %rbp</div><div class="line">  4010fb: 53                    push   %rbx</div><div class="line">  4010fc: 48 83 ec 50           sub    $0x50,%rsp</div><div class="line">  401100: 49 89 e5              mov    %rsp,%r13</div><div class="line">  401103: 48 89 e6              mov    %rsp,%rsi</div><div class="line">  401106: e8 51 03 00 00        callq  40145c &lt;read_six_numbers&gt;</div><div class="line">  40110b: 49 89 e6              mov    %rsp,%r14               # %r14存储数组起始地址</div><div class="line">  40110e: 41 bc 00 00 00 00     mov    $0x0,%r12d              # 将%r12d初始化为0</div><div class="line">  </div><div class="line">  #################### Section 1:确认数组中所有的元素小于等于6且不存在重复值 ###################</div><div class="line">  401114: 4c 89 ed              mov    %r13,%rbp               # %r13和%rbp存储数组某个元素的地址，并不是第1个元素，意识到这点需要结合0x40114d处的指令</div><div class="line">  401117: 41 8b 45 00           mov    0x0(%r13),%eax          # %eax存储第%r13个数</div><div class="line">  40111b: 83 e8 01              sub    $0x1,%eax               # 将%eax的值减1</div><div class="line">  40111e: 83 f8 05              cmp    $0x5,%eax               # 将%eax的值与常数5做比较</div><div class="line">  401121: 76 05                 jbe    401128 &lt;phase_6+0x34&gt;</div><div class="line">  401123: e8 12 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  401128: 41 83 c4 01           add    $0x1,%r12d              # 如果%eax的值小于等于5，%r12d加1</div><div class="line">  40112c: 41 83 fc 06           cmp    $0x6,%r12d              # 将%r12d与常数6做比较</div><div class="line">  401130: 74 21                 je     401153 &lt;phase_6+0x5f&gt;</div><div class="line">  401132: 44 89 e3              mov    %r12d,%ebx              # %ebx起了数组下标的作用</div><div class="line">  </div><div class="line">  # 用于判断数组6个数是否存在重复值，若存在，引爆炸弹</div><div class="line">  401135: 48 63 c3              movslq %ebx,%rax               # 将数组下标存储至%rax</div><div class="line">  401138: 8b 04 84              mov    (%rsp,%rax,4),%eax      # 将下一个数存储至%eax</div><div class="line">  40113b: 39 45 00              cmp    %eax,0x0(%rbp)          # 将第1个数与%eax的值(当前数)做比较</div><div class="line">  40113e: 75 05                 jne    401145 &lt;phase_6+0x51&gt;   # 若相等，引爆炸弹   </div><div class="line">  401140: e8 f5 02 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  401145: 83 c3 01              add    $0x1,%ebx               # 数组下标加1            </div><div class="line">  401148: 83 fb 05              cmp    $0x5,%ebx               # 判断数组下标是否越界(&lt;=5)</div><div class="line">  40114b: 7e e8                 jle    401135 &lt;phase_6+0x41&gt;</div><div class="line">  </div><div class="line">  40114d: 49 83 c5 04           add    $0x4,%r13               # %r13存储数组下一个数的地址</div><div class="line">  401151: eb c1                 jmp    401114 &lt;phase_6+0x20&gt;</div><div class="line">  ####################################### Section 1 end ######################################</div><div class="line">  </div><div class="line">  ################ Section 2：用7减去数组的每个元素，并将相减后的元素替换原有元素 #################</div><div class="line">  401153: 48 8d 74 24 18        lea    0x18(%rsp),%rsi         # 0x18(%rsp)是数组的边界地址：0x18 = 24         </div><div class="line">  401158: 4c 89 f0              mov    %r14,%rax               # 将数组起始地址存储于%rax</div><div class="line">  40115b: b9 07 00 00 00        mov    $0x7,%ecx</div><div class="line">  </div><div class="line">  401160: 89 ca                 mov    %ecx,%edx               # %edx = 7</div><div class="line">  401162: 2b 10                 sub    (%rax),%edx             # %edx = 7 - 数组元素</div><div class="line">  401164: 89 10                 mov    %edx,(%rax)             # 用相减后的元素(%edx)替换原有元素</div><div class="line">  401166: 48 83 c0 04           add    $0x4,%rax               # %rax存储数组下一个元素的地址</div><div class="line">  40116a: 48 39 f0              cmp    %rsi,%rax               # 判断是否越界</div><div class="line">  40116d: 75 f1                 jne    401160 &lt;phase_6+0x6c&gt;</div><div class="line">  ####################################### Section 2 end ######################################</div><div class="line">  </div><div class="line">  ########################## Section 3：根据输入数组重排结构体数组 ##############################</div><div class="line">  40116f: be 00 00 00 00        mov    $0x0,%esi               # 将%esi初始化为0，作为数组下标</div><div class="line">  401174: eb 21                 jmp    401197 &lt;phase_6+0xa3&gt;</div><div class="line">  </div><div class="line">  401176: 48 8b 52 08           mov    0x8(%rdx),%rdx          # 0x8(%rdx)为下一个元素的地址</div><div class="line">  40117a: 83 c0 01              add    $0x1,%eax               </div><div class="line">  40117d: 39 c8                 cmp    %ecx,%eax               # %ecx存储了数组当前值(第%esi个元素)</div><div class="line">  40117f: 75 f5                 jne    401176 &lt;phase_6+0x82&gt;</div><div class="line">  </div><div class="line">  401181: eb 05                 jmp    401188 &lt;phase_6+0x94&gt;</div><div class="line">  401183: ba d0 32 60 00        mov    $0x6032d0,%edx          # %edx存储结构体数组第1个元素的地址</div><div class="line">  401188: 48 89 54 74 20        mov    %rdx,0x20(%rsp,%rsi,2)  # %rsi的初始值为0；该指令的作用是将结构体数组的第%ecx个元素的地址存储在内存的某个位置(以%rsp + 0x20为基地址，%rsi为偏移量)</div><div class="line">  40118d: 48 83 c6 04           add    $0x4,%rsi               # 增加偏移量</div><div class="line">  401191: 48 83 fe 18           cmp    $0x18,%rsi</div><div class="line">  401195: 74 14                 je     4011ab &lt;phase_6+0xb7&gt;</div><div class="line">  401197: 8b 0c 34              mov    (%rsp,%rsi,1),%ecx      # %ecx存储数组第%esi个元素</div><div class="line">  40119a: 83 f9 01              cmp    $0x1,%ecx               # 将数组第%esi个元素与常数1做比较</div><div class="line">  40119d: 7e e4                 jle    401183 &lt;phase_6+0x8f&gt;   # 实际上不会小于1，如果数组的第1个元素等于1，那么跳转至0x401183处</div><div class="line">  40119f: b8 01 00 00 00        mov    $0x1,%eax</div><div class="line">  4011a4: ba d0 32 60 00        mov    $0x6032d0,%edx          # %edx存储结构体数组第1个元素的地址</div><div class="line">  4011a9: eb cb                 jmp    401176 &lt;phase_6+0x82&gt;</div><div class="line">  ####################################### Section 3 end ######################################</div><div class="line">  </div><div class="line">  ######################### Section 4：修改结构体数组元素的next域值 #############################</div><div class="line">  4011ab: 48 8b 5c 24 20        mov    0x20(%rsp),%rbx         # %rbx存储地址数组的第1个元素的值</div><div class="line">  4011b0: 48 8d 44 24 28        lea    0x28(%rsp),%rax         # %rax存储地址数组的第2个元素的地址</div><div class="line">  4011b5: 48 8d 74 24 50        lea    0x50(%rsp),%rsi</div><div class="line">  4011ba: 48 89 d9              mov    %rbx,%rcx               # %rcx存储地址数组的第1个元素的值</div><div class="line">  </div><div class="line">  # 下面用i和i+1来表示元素位置</div><div class="line">  4011bd: 48 8b 10              mov    (%rax),%rdx             # %rdx存储地址数组的第i+1个元素的值</div><div class="line">  4011c0: 48 89 51 08           mov    %rdx,0x8(%rcx)          # 把第i+1和元素的值存储于第i个结构体元素的next域中，next域的地址为0x8(%rcx)的值</div><div class="line">  4011c4: 48 83 c0 08           add    $0x8,%rax</div><div class="line">  4011c8: 48 39 f0              cmp    %rsi,%rax</div><div class="line">  4011cb: 74 05                 je     4011d2 &lt;phase_6+0xde&gt;</div><div class="line">  4011cd: 48 89 d1              mov    %rdx,%rcx</div><div class="line">  4011d0: eb eb                 jmp    4011bd &lt;phase_6+0xc9&gt;</div><div class="line">  ####################################### Section 4 end ######################################</div><div class="line">  </div><div class="line">  ######################### Section 5：判断结构体数组是否是递减序列 #############################</div><div class="line">  4011d2: 48 c7 42 08 00 00 00  movq   $0x0,0x8(%rdx)</div><div class="line">  4011d9: 00 </div><div class="line">  4011da: bd 05 00 00 00        mov    $0x5,%ebp</div><div class="line">  4011df: 48 8b 43 08           mov    0x8(%rbx),%rax</div><div class="line">  4011e3: 8b 00                 mov    (%rax),%eax</div><div class="line">  4011e5: 39 03                 cmp    %eax,(%rbx)</div><div class="line">  4011e7: 7d 05                 jge    4011ee &lt;phase_6+0xfa&gt;</div><div class="line">  4011e9: e8 4c 02 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  4011ee: 48 8b 5b 08           mov    0x8(%rbx),%rbx</div><div class="line">  4011f2: 83 ed 01              sub    $0x1,%ebp</div><div class="line">  4011f5: 75 e8                 jne    4011df &lt;phase_6+0xeb&gt;</div><div class="line">  ####################################### Section 5 end ######################################</div><div class="line">  </div><div class="line">  4011f7: 48 83 c4 50           add    $0x50,%rsp</div><div class="line">  4011fb: 5b                    pop    %rbx</div><div class="line">  4011fc: 5d                    pop    %rbp</div><div class="line">  4011fd: 41 5c                 pop    %r12</div><div class="line">  4011ff: 41 5d                 pop    %r13</div><div class="line">  401201: 41 5e                 pop    %r14</div><div class="line">  401203: c3                    retq</div></pre></td></tr></table></figure>
<p>分析清楚<code>phase_6</code>非常需要耐心，我将<code>phase_6</code>划分为<code>5</code>个<code>Section</code>，每个<code>Section</code>完成特定的功能，详细的注释直接附到了相关代码。前两个<code>Section</code>不难理解：<code>Section 1</code>确保输入数组的值的范围在<code>1 ~ 6</code>且不存在重复值；<code>Section 2</code>用<code>7</code>减去输入数组的每个元素，相当于求补。<code>Section 3</code>中出现了一个常数地址，使用<code>gdb</code>将该地址存储的内容打印出来，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 10.png" alt=""></p>
<p>可以意识到这其实是一个链表数据结构，链表的节点由<code>3</code>部分组成：<code>value 1</code>、<code>value 2</code>和一个地址值(<code>next</code>域，指向下一个节点)。<code>Section 3</code>根据我们输入的数组，按照数组元素的值将对应结构体数组中的元素的首地址存储到内存的某个位置(<code>mov %rdx,0x20(%rsp,%rsi,2)</code>)。例如，假设输入数组为<code>[3, 4, 5, 6, 1, 2]</code>，那么<code>Section 3</code>首先会将结构体数组的第<code>3</code>个元素的地址存储到<code>0x20(%rsp,%rsi,2)</code>处，接着将结构体数组的第<code>4</code>个元素……依次类推。</p>
<p><code>Section 4</code>根据<code>Section 3</code>构建的地址数组，修改结构体数组的<code>next</code>域的值，实现单链表的排序操作。<code>Section 5</code>进行验证，要求单链表递减排序，若满足要求，那么拆弹成功。</p>
<p>综上，根据已有的结构体数组以及<code>phase_6</code>的操作，若要实现单链表的递减排序，应将第<code>3</code>个节点放在第<code>1</code>位，将第<code>4</code>个节点放在第<code>2</code>位……最终得到序列：<code>[3, 4, 5, 6, 1, 2]</code>。不要忘记<code>Section 2</code>中的求补操作，所以<code>phase_6</code>的输入序列应该为<code>[4, 3, 2, 1, 6, 5]</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，<code>Bomb Lab</code>包含了<code>6</code>个<code>phase</code>全部拆弹成功。将输入序列存储在文件，然后将文件作为<code>bomb</code>二进制文件的参数，运行结果如下图所示。</p>
<p><img src="/img/2017-04-26-Image 11.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Bomb Lab&lt;/code&gt;是&lt;code&gt;CS:APP&lt;/code&gt;一书中的第二个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/bomblab.pdf&quot;&gt;实验&lt;/a&gt;，实验中的&lt;code&gt;bomb&lt;/code&gt;实际上是一个程序的二进制文件，该程序由一系列&lt;code&gt;phase&lt;/code&gt;组成，每个&lt;code&gt;phase&lt;/code&gt;需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印&lt;code&gt;BOOM!!!&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://tinylcy.me/tags/CSAPP/"/>
    
      <category term="Assembly" scheme="http://tinylcy.me/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>理解Golang中的defer</title>
    <link href="http://tinylcy.me/2017/04/04/%E7%90%86%E8%A7%A3Golang%E4%B8%AD%E7%9A%84defer/"/>
    <id>http://tinylcy.me/2017/04/04/理解Golang中的defer/</id>
    <published>2017-04-04T13:01:21.000Z</published>
    <updated>2017-04-25T04:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字<code>defer</code>用于实现延迟调用，根据<code>Golang</code>官方的定义：<em>A defer statement defers the execution of a function until the surrounding function returns.</em> 。但是，当返回值与<code>defer</code>相互关联时，如果没有正确理解<code>defer</code>与<code>return</code>真正的执行顺序，那么容易出现一些不可描述的现象。</p>
<p>我们先运行如下代码，根据运行结果来理解<code>defer</code>，在查看运行结果之前，不妨先想想<code>main</code>函数的输出是什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(funcA())</div><div class="line">	fmt.Println(funcB())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer2:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer1:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> i</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer2:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer1:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> i</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">defer1: <span class="number">1</span></div><div class="line">defer2: <span class="number">2</span></div><div class="line"><span class="number">0</span></div><div class="line">defer1: <span class="number">1</span></div><div class="line">defer2: <span class="number">2</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>根据运行结果，我们可以看到，<code>defer</code>语句的执行顺序以及打印出来的变量<code>i</code>的值是意料之内的，区别在于函数的返回值，而<code>funcA</code>和<code>funcB</code>这两个函数唯一的区别则是函数的返回值有没有被命名，因此导致两个函数返回值不同的原因也应该和返回值是否命名有关。</p>
<p>在计算机科学中，我相信很多原理性的东西都是可以相互解释的。在本篇文章中，我决定用<code>Java</code>中的<code>try-catch-finally</code>来解释<code>defer</code>的运行机制。首先，先看看如下<code>Java</code>代码片段，并考虑返回值有哪几种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        x = <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        x = <span class="number">2</span>;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        x = <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们对<code>Java</code>熟悉，那么应该知道，无论在<code>try</code>块中是否出现异常，<code>finally</code>块中的语句是一定要执行的，但是函数的返回值只可能是<code>1</code>或者<code>2</code>，绝对不会是<code>3</code>。我们通过查看这段<code>Java</code>代码对应的字节码指令来理解这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</div><div class="line">  flags: ACC_PUBLIC</div><div class="line">  Code:</div><div class="line">    stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></div><div class="line">       <span class="number">0</span>: iconst_1</div><div class="line">       <span class="number">1</span>: istore_1</div><div class="line">       <span class="number">2</span>: iload_1</div><div class="line">       <span class="number">3</span>: istore_2</div><div class="line">       <span class="number">4</span>: iconst_3</div><div class="line">       <span class="number">5</span>: istore_1</div><div class="line">       <span class="number">6</span>: iload_2</div><div class="line">       <span class="number">7</span>: ireturn</div></pre></td></tr></table></figure>
<p>这段字节码对应于<code>try-finally</code>这条执行轨迹：<code>iconst_1</code>将常量<code>1</code>压入操作数栈；<code>istore_1</code>将栈顶元素弹出并存储于局部变量表<code>Slot1</code>处；<code>iload_1</code>将局部变量表<code>Slot1</code>处的元素压入操作数栈；<code>istore_2</code>将操作数栈顶元素弹出并存储于局部变量表<code>Slot2</code>处；<code>iconst_3</code>将常量<code>3</code>压入操作数栈；<code>istore_1</code>将操作数栈顶元素弹出并存储于局部变量表<code>Slot1</code>处；<code>iload_2</code>将局部变量表<code>Slot2</code>处的元素压入操作数栈；<code>ireturn</code>返回栈顶元素。</p>
<p>第<code>0</code>条指令和第<code>1</code>条指令实现了<code>x = 1</code>，并且<code>x</code>的值存储于局部变量表的<code>Slot1</code>处；第<code>2</code>条指令和第<code>3</code>条指令将<code>x</code>的值拷贝了一份，并存储在局部变量表的<code>Slot2</code>处。第<code>4</code>条指令和第<code>5</code>条指令实现了<code>x = 3</code>；第<code>6</code>条指令和第<code>7</code>条指令将存储于局部变量表<code>Slot2</code>处的<code>x</code>的拷贝值返回，由于<code>Slot2</code>中的值是执行<code>finally</code>块中语句之前<code>x</code>的值，因此返回值等于<code>2</code>。</p>
<p>基于以上解释，我们再来重新理解<code>defer</code>。对于函数<code>funcA</code>，当执行至<code>return</code>时，变量<code>i</code>的值等于<code>0</code>，与<code>Java</code>类似，<code>Golang</code>会将返回值的拷贝值（即变量<code>i</code>的值）存储于内存中的某个位置<code>pos</code>（对应于局部变量表的<code>Slot2</code>处），然后执行<code>defer</code>语句，当<code>defer</code>语句执行完后，尽管变量<code>i</code>的值已增加至<code>2</code>，但是返回值依赖于地址<code>pos</code>处的值，因此<code>funcA</code>返回<code>0</code>；对于函数<code>funcB</code>，由于<code>funcB</code>已经命名了函数的返回值为变量<code>i</code>，这意味着函数的返回值的地址即为变量<code>i</code>的地址。当执行至<code>return</code>时，尽管变量<code>i</code>的值为<code>0</code>，但是紧接着的<code>defer</code>语句使得变量<code>i</code>的值增加至<code>2</code>，由于<code>funcA</code>的返回值的地址为变量<code>i</code>的地址，因此<code>funcB</code>最后的返回值为<code>2</code>。</p>
<p>为了验证我们的解释，运行如下代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(*(funcC()))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer2:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer1:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> &amp;i</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管函数<code>funcC</code>的返回值并没有提前声明，但是<code>funcC</code>的返回值仍为<code>2</code>，这是因为<code>funcC</code>的返回值是变量<code>i</code>的内存地址，当执行到<code>return</code>语句时，变量<code>i</code>的内存地址值的拷贝会被存储于内存的某个位置，而该位置的值即是最后的返回值，由于变量<code>i</code>的地址在整个过程并未被修改，因此通过地址值的拷贝值我们依旧可以观察到<code>defer</code>语句对变量<code>i</code>的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字&lt;code&gt;defer&lt;/code&gt;用于实现延迟调用，根据&lt;code&gt;Golang&lt;/code&gt;官方的定义：&lt;em&gt;A defer statement defers the execution of a function until the surrounding f
    
    </summary>
    
    
      <category term="Golang" scheme="http://tinylcy.me/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ThreadLocal</title>
    <link href="http://tinylcy.me/2017/02/24/%E8%B0%88%E8%B0%88ThreadLocal/"/>
    <id>http://tinylcy.me/2017/02/24/谈谈ThreadLocal/</id>
    <published>2017-02-24T14:21:03.000Z</published>
    <updated>2017-04-25T04:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a> 一书在介绍<code>ThreadLocal</code>类时（第<code>3</code>章），书中有这么两段话，在我初次阅读时不知道如何去理解。</p>
<blockquote>
<p>ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。</p>
<p>当某个频繁执行的操作需要一个临时变量，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。例如，在Java 5.0之前，Integer.toString()方法使用ThreadLocal对象来保存一个12字节大小的缓冲区，用于对结果进行格式化，而不是使用共享的静态缓冲区（这需要锁机制）或者在每次调用时都分配一个新的缓冲区。</p>
</blockquote>
<p>如果我们要在某种程度上理解这两句话，首先我们需要知道什么是<code>ThreadLocal</code>？更重要的是为什么要提出<code>ThreadLocal</code>这个概念？</p>
<p>我们知道，线程并不独立拥有用户空间，用户空间是归进程所有，为同一进程中的所有线程所共享的。所以，用户空间中的任何一个区域，只要有一个线程可以访问，那么同一进程中的所有其它的线程就都能访问。在这个意义上，整个用户空间都是（由同一进程中的）所有线程共享的，不存在只归一个线程使用的变量或数据结构。可是，一般而言，程序对变量或数据结构的访问都是按变量名访问的，经过编译/连接之后就是按地址访问，要是不知道一个变量的地址，实际上就无法正常和正确地加以访问。在这个意义上，则只归一个线程使用的变量或数据结构又是可能的。</p>
<p>注意<code>ThreadLocal</code>只是对全局量和静态变量才有意义。局部量存在于具体线程的堆栈上，而每个线程都有自己的堆栈，所以局部量本来就是“局部”于具体线程的。至于通过动态分配的缓冲区，则取决于保存着缓冲区指针的变量。如果缓冲区指针是全局量，那么同一进程中的所有线程都能访问这个缓冲区；而若是局部量，则别的线程自然就不得其门而入。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在介绍<code>ThreadLocal</code>之前，我们先通过一段代码来理解<code>synchronized</code>是如何实现在同一时刻只允许单个线程访问同步代码块的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;   </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>SynchronizedTest</code>编译之后，<code>SynchronizedTest</code>中的两个同步方法的字节码（只截取需要的部分 ）如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public synchronized void func1();</div><div class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</div><div class="line">  Code:</div><div class="line">    stack=0, locals=1, args_size=1</div><div class="line">       0: return</div><div class="line">    LineNumberTable:</div><div class="line">      line 10: 0</div><div class="line"></div><div class="line">public void func2();</div><div class="line">  flags: ACC_PUBLIC</div><div class="line">  Code:</div><div class="line">    stack=2, locals=3, args_size=1</div><div class="line">       0: aload_0</div><div class="line">       1: dup</div><div class="line">       2: astore_1</div><div class="line">       3: monitorenter</div><div class="line">       4: aload_1</div><div class="line">       5: monitorexit</div><div class="line">       6: goto          14</div><div class="line">       9: astore_2</div><div class="line">      10: aload_1</div><div class="line">      11: monitorexit</div><div class="line">      12: aload_2</div><div class="line">      13: athrow</div><div class="line">      14: return</div></pre></td></tr></table></figure>
<p><code>synchronized</code>关键字经过编译之后，会在同步代码块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，例如<code>func2</code>方法对应的第<code>3</code>条和第<code>5</code>条字节码，这两个字节码都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。那这里提到的锁和对象之间的关系是什么？关于这个问题，可以参考我的另一篇文章 <a href="http://tinylcy.me/2016/11/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Java对象内存布局</a>，在对象的<code>Mark Word</code>部分，存储着锁标志位，线程通过检查对象头的锁标志位，获知对象的锁状态，然后决定是获取锁还是进入阻塞状态。<code>synchronized</code>正是通过这个机制实现对共享资源的串行访问。</p>
<h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>关于<code>ThreadLocal</code>的概念，直接<code>从ThreadLocal</code>源码注释入手。</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p>
</blockquote>
<p>根据注释，我们认识到<code>ThreadLocal</code>可以为线程提供一个线程局部的值，既然该值是一个线程的局部变量，自然不存在线程同步的问题。但是注释又说到：<em>ThreadLocal instances are typically private static fields in classes</em>，这句话如何理解？如果一个变量是<code>static</code>的变量，那么它就是进程级别的全局变量，那不是意味着<code>ThreadLocal</code>是一个线程共享的变量吗？为了解决这个问题，我们需要阅读<code>ThreadLocal</code>的源码。</p>
<p>首先是<code>ThreadLocal</code>的<code>set</code>方法，<code>set</code>方法的作用是为当前线程设置一个<code>ThreadLocal</code>的值<code>value</code>，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>set</code>方法首先调用<code>getMap</code>方法从当前线程获取类型为<code>ThreadLocalMap</code>的对象<code>map</code>，如果<code>map</code>还没有创建，就通过<code>createMap</code>方法创建一个。然后<code>set</code>方法以当前的<code>ThreadLocal</code>对象为键，<code>value</code>为值，存储到当前线程的<code>ThreadLocalMap</code>对象中。<code>Thread</code>类中<code>ThreadLocalMap</code>变量的声明如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p><code>ThreadLocal</code>的<code>get</code>方法用于获取与当前线程关联的<code>ThreadLocal</code>值，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get</code>方法首先通过<code>getMap</code>方法获取当前线程的<code>ThreadLocalMap</code>对象，然后以<code>ThreadLocal</code>对象为键获取与该<code>ThreadLocal</code>对象关联的值。</p>
<p>从这两个方法我们知道，<code>ThreadLocal</code>对象的确是线程共享的，但是当线程向<code>ThreadLocal</code>设置值时，实际上是给当前线程维护的<code>ThreadLocalMap</code>设置了值。因此线程设置的值为线程私有，但是<code>ThreadLocal</code>对象为线程共享。</p>
<h2 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计"></a>为什么这么设计</h2><p>如果我们要设置线程本地的变量，我们只需要在方法内声明局部变量即可，为什么要通过<code>ThreadLocal</code>来设置？对于<code>ThreadLocal</code>的设计理念，我们通过<code>Linux/Unix</code>的<code>C</code>程序库<code>libc</code>的全局变量<code>errno</code>来理解。当系统调用从内核空间返回用户空间时，如果系统调用出错，那么便设置<code>errno</code>的值为一个负值，这样就不需要每次在函数内部定义局部变量。但是当多线程的概念和技术被提出后，这套机制就不再适用了，可以使用局部变量，但是不太可能去更改已有的代码了，比较好的解决方案是让每个线程都有自己的<code>errno</code>。实际上，现在的<code>C</code>库函数不是把出错代码写入全局量<code>errno</code>，而是通过一个函数<code>__errno_location()</code>获取一个地址，再把出错代码写入该地址，其意图就是让不同的线程使用不同的出错代码存储地点，而<code>errno</code>，现在一般已经变成了一个宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> errno (*__errno_location())</span></div></pre></td></tr></table></figure>
<p>考虑另一个场景：我们现在需要设置一个线程局部变量，于是我们在方法内设置了一个局部变量，当我们需要把这个局部变量从一个方法传递到另一个方法，只需要将这个变量作为参数传递即可。假设<code>funcA</code>需要访问该变量，<code>funcZ</code>也需要访问该变量，但是<code>funcA</code>需要通过调用<code>funcB</code>，<code>funcC...funcY</code>才能调用<code>funcZ</code>，于是该变量需要被声明在所有的方法的签名中。为了避免这个麻烦，我们可以把这个变量设置为进程级别的全局变量，但是此时就需要我们控制线程同步了。于是，<code>ThreadLocal</code>就可以发挥作用了。</p>
<p>我们可以认为<code>ThreadLocal</code>存储了一个线程的上下文信息，线程通过访问<code>ThreadLocal</code>这个进程级别的变量实现了线程级别的访问。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a></li>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></li>
<li><a href="http://www.longene.org/techdoc/0328131001224576926.html" target="_blank" rel="external">漫谈兼容内核</a></li>
<li><a href="http://github.thinkingbar.com/threadlocal/" target="_blank" rel="external">理解 ThreadLocal</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java并发编程实战&lt;/a&gt; 一书在介绍&lt;code&gt;ThreadLocal&lt;/code&gt;类时（第&lt;code&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个Java Class解析器</title>
    <link href="http://tinylcy.me/2017/02/12/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAJava-Class%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>http://tinylcy.me/2017/02/12/如何实现一个Java-Class解析器/</id>
    <published>2017-02-12T15:26:08.000Z</published>
    <updated>2017-04-25T04:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个私人项目，名字叫做<code>ClassAnalyzer</code>，<code>ClassAnalyzer</code>的目的是能让我们对<code>Java Class</code>文件的设计与结构能够有一个深入的理解。主体框架与基本功能已经完成，还有一些细节功能日后再增加。实际上<code>JDK</code>已经提供了命令行工具<code>javap</code>来反编译<code>Class</code>文件，但本篇文章将阐明我实现解析器的思路。</p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>作为类或者接口信息的载体，每个<code>Class</code>文件都完整的定义了一个类。为了使<code>Java</code>程序可以“编写一次，处处运行”，<a href="http://files.cnblogs.com/files/zhuYears/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%EF%BC%88JavaSE7%EF%BC%89.pdf" target="_blank" rel="external">Java虚拟机规范</a>对<code>Class</code>文件进行了严格的规定。构成<code>Class</code>文件的基本数据单位是字节，这些字节之间不存在任何分隔符，这使得整个<code>Class</code>文件中存储的内容几乎全部是程序运行的必要数据，单个字节无法表示的数据由多个连续的字节来表示。</p>
<p>根据<code>Java</code>虚拟机规范，<code>Class</code>文件采用一种类似于<code>C</code>语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。<code>Java</code>虚拟机规范定义了<code>u1</code>、<code>u2</code>、<code>u4</code>和<code>u8</code>来分别表示<code>1</code>个字节、<code>2</code>个字节、<code>4</code>个字节和<code>8</code>个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者是字符串。表是由多个无符号数或者其它表作为数据项构成的复合数据类型，表用于描述有层次关系的复合结构的数据，因此整个<code>Class</code>文件本质上就是一张表。在<code>ClassAnalyzer</code>中，<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>分别对应<code>u1</code>、<code>u2</code>、<code>u4</code>和<code>u8</code>数据类型，<code>Class</code>文件被描述为如下<code>Java</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFile</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> U4 magic;                            <span class="comment">// magic</span></div><div class="line">    <span class="keyword">public</span> U2 minorVersion;                     <span class="comment">// minor_version</span></div><div class="line">    <span class="keyword">public</span> U2 majorVersion;                     <span class="comment">// major_version</span></div><div class="line">    <span class="keyword">public</span> U2 constantPoolCount;                <span class="comment">// constant_pool_count</span></div><div class="line">    <span class="keyword">public</span> ConstantPoolInfo[] cpInfo;           <span class="comment">// cp_info</span></div><div class="line">    <span class="keyword">public</span> U2 accessFlags;                      <span class="comment">// access_flags</span></div><div class="line">    <span class="keyword">public</span> U2 thisClass;                        <span class="comment">// this_class</span></div><div class="line">    <span class="keyword">public</span> U2 superClass;                       <span class="comment">// super_class</span></div><div class="line">    <span class="keyword">public</span> U2 interfacesCount;                  <span class="comment">// interfaces_count</span></div><div class="line">    <span class="keyword">public</span> U2[] interfaces;                     <span class="comment">// interfaces</span></div><div class="line">    <span class="keyword">public</span> U2 fieldsCount;                      <span class="comment">// fields_count</span></div><div class="line">    <span class="keyword">public</span> FieldInfo[] fields;                  <span class="comment">// fields</span></div><div class="line">    <span class="keyword">public</span> U2 methodsCount;                     <span class="comment">// methods_count</span></div><div class="line">    <span class="keyword">public</span> MethodInfo[] methods;                <span class="comment">// methods</span></div><div class="line">    <span class="keyword">public</span> U2 attributesCount;                  <span class="comment">// attributes_count</span></div><div class="line">    <span class="keyword">public</span> BasicAttributeInfo[] attributes;     <span class="comment">// attributes</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何解析"><a href="#如何解析" class="headerlink" title="如何解析"></a>如何解析</h2><p>组成<code>Class</code>文件的各个数据项中，例如魔数、<code>Class</code>文件的版本、访问标志、类索引和父类索引等数据项，它们在每个<code>Class</code>文件中都占用固定数量的字节，在解析时只需要读取相应数量的字节。除此之外，需要灵活处理的主要包括<code>4</code>部分：常量池、字段表集合、方法表集合和属性表集合。字段和方法都可以具备自己的属性，<code>Class</code>本身也有相应的属性，因此，在解析字段表集合和方法表集合的同时也包含了属性表集合的解析。</p>
<p>常量池占据了<code>Class</code>文件很大一部分的数据，用于存储所有的常量信息，包括数字和字符串常量、类名、接口名、字段名和方法名等。<code>Java</code>虚拟机规范定义了多种常量类型，每一种常量类型都有自己的结构。常量池本身是一个表，在解析时有几点需要注意。</p>
<ul>
<li><p>每个常量类型都通过一个<code>u1</code>类型的<code>tag</code>来标识。</p>
</li>
<li><p>表头给出的常量池大小（<code>constantPoolCount</code>）比实际大<code>1</code>，例如，如果<code>constantPoolCount</code>等于<code>47</code>，那么常量池中有<code>46</code>项常量。</p>
</li>
<li>常量池的索引范围从<code>1</code>开始，例如，如果<code>constantPoolCount</code>等于<code>47</code>，那么常量池的索引范围为<code>1 ~ 46</code>。设计者将第<code>0</code>项空出来的目的是用于表达“不引用任何一个常量池项目”。</li>
<li>如果一个<code>CONSTANT_Long_info</code>或<code>CONSTANT_Double_info</code>结构的项在常量池中的索引为<code>n</code>，则常量池中下一个有效的项的索引为<code>n+2</code>，此时常量池中索引为<code>n+1</code>的项有效但必须被认为不可用。</li>
<li><code>CONSTANT_Utf8_info</code>型常量的结构中包含一个<code>u1</code>类型的<code>tag</code>、一个<code>u2</code>类型的<code>length</code>和由<code>length</code>个<code>u1</code>类型组成的<code>bytes</code>，这<code>length</code>字节的连续数据是一个使用<code>MUTF-8</code>（<code>Modified UTF-8）</code>编码的字符串。<code>MUTF-8</code>与<code>UTF-8</code>并不兼容，主要区别有两点：一是<code>null</code>字符会被编码成<code>2</code>字节（<code>0xC0</code>和<code>0x80</code>）；二是补充字符是按照<code>UTF-16</code>拆分为代理对分别编码的，相关细节可以看<a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">这里（变种UTF-8）</a>。</li>
</ul>
<p>属性表用于描述某些场景专有的信息，<code>Class</code>文件、字段表和方法表都有相应的属性表集合。<code>Java</code>虚拟机规范定义了多种属性，<code>ClassAnalyzer</code>目前实现了对常用属性的解析。与常量类型的数据项不同，属性并没有一个<code>tag</code>来标识属性的类型，但是每个属性都包含有一个<code>u2</code>类型的<code>attribute_name_index</code>，<code>attribute_name_index</code>指向常量池中的一个<code>CONSTANT_Utf8_info</code>类型的常量，该常量包含着属性的名称。在解析属性时，<code>ClassAnalyzer</code>正是通过<code>attribute_name_index</code>指向的常量对应的属性名称来得知属性的类型。</p>
<p>字段表用于描述类或者接口中声明的变量，字段包括类级变量以及实例级变量。字段表的结构包含一个<code>u2</code>类型的<code>access_flags</code>、一个<code>u2</code>类型的<code>name_index</code>、一个<code>u2</code>类型的<code>descriptor_index</code>、一个<code>u2</code>类型的<code>attributes_count</code>和<code>attributes_count</code>个<code>attribute_info</code>类型的<code>attributes</code>。我们已经介绍了属性表的解析，<code>attributes</code>的解析方式与属性表的解析方式一致。</p>
<p><code>Class</code>的文件方法表采用了和字段表相同的存储格式，只是<code>access_flags</code>对应的含义有所不同。方法表包含着一个重要的属性：<code>Code</code>属性。<code>Code</code>属性存储了<code>Java</code>代码编译成的字节码指令，在<code>ClassAnalyzer</code>中，<code>Code</code>对应的<code>Java</code>类如下所示（仅列出了类属性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> <span class="keyword">extends</span> <span class="title">BasicAttributeInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> maxStack;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> maxLocals;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> codeLength;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] code;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> exceptionTableLength;</div><div class="line">    <span class="keyword">private</span> ExceptionInfo[] exceptionTable;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> attributesCount;</div><div class="line">    <span class="keyword">private</span> BasicAttributeInfo[] attributes;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInfo</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> startPc;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> endPc;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> handlerPc;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> catchType;</div><div class="line">      	...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Code</code>属性中，<code>codeLength</code>和<code>code</code>分别用于存储字节码长度和字节码指令，每条指令即一个字节（<code>u1</code>类型）。在虚拟机执行时，通过读取<code>code</code>中的一个个字节码，并将字节码翻译成相应的指令。另外，虽然<code>codeLength</code>是一个<code>u4</code>类型的值，但是实际上一个方法不允许超过<code>65535</code>条字节码指令。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>ClassAnalyzer</code>的源码已放在了<a href="https://github.com/tinylcy/ClassAnalyzer" target="_blank" rel="external">GitHub</a>上。在<code>ClassAnalyzer</code>的<a href="https://github.com/tinylcy/ClassAnalyzer/blob/master/README.md" target="_blank" rel="external">README</a>中，我以一个类的<code>Class</code>文件为例，对该<code>Class</code>文件的每个字节进行了分析，希望对大家的理解有所帮助。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个私人项目，名字叫做&lt;code&gt;ClassAnalyzer&lt;/code&gt;，&lt;code&gt;ClassAnalyzer&lt;/code&gt;的目的是能让我们对&lt;code&gt;Java Class&lt;/code&gt;文件的设计与结构能够有一个深入的理解。主体框架与基本功能已经完成，还有一些
    
    </summary>
    
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
      <category term="JVM" scheme="http://tinylcy.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP: Shell Lab</title>
    <link href="http://tinylcy.me/2017/01/10/CSAPP-Shell-Lab/"/>
    <id>http://tinylcy.me/2017/01/10/CSAPP-Shell-Lab/</id>
    <published>2017-01-10T08:13:11.000Z</published>
    <updated>2017-04-25T04:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf" target="_blank" rel="external">实验</a>通过实现一个支持作业控制的<code>Unix Shell</code>，让我们对进程控制和信号控制更加熟悉。课程<code>Lab</code>已经帮助我们搭建起了<code>Shell</code>的整体框架，并实现了与本次实验不太相关的代码，核心部分需要我们自己完成。</p>
<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><code>Shell</code>从标准输入（<code>stdin</code>）读取用户输入的命令，然后解析命令，<code>Shell</code>支持两种类型的命令：如果用户输入的是的内置命令（如<code>quit</code>、<code>jobs</code>等），那么直接执行该命令；如果用户输入的是某个可执行文件的路径，那么通过<code>fork</code>一个子进程，在子进程中加载并执行命令。<code>Shell</code>把每次用户输入的命令抽象为一个<code>job</code>，一个<code>job</code>可以包含多个进程（例如管道）。每个<code>job</code>有两种运行方式，如果用户输入的命令以’<code>&amp;</code>‘结尾，那么<code>job</code>将会在后台（<code>background</code>）运行，否则，<code>job</code>运行在前台（<code>foreground</code>）。在任意时刻，只允许存在<code>0</code>或<code>1</code>个前台<code>job</code>，但是可以有<code>0</code>或多个后台<code>job</code>运行。最后，为了支持用户能够向<code>Shell</code>发送信号，我们还需要实现<code>3</code>个信号处理程序，分别处理信号<code>SIGCHLD</code>、<code>SIGINT</code>和<code>SIGTSTP</code>。</p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ul>
<li>默认的，一个子进程和它的父进程同属于一个进程组，而<code>Unix</code>系统提供的大量向进程发送信号的机制，都是基于进程组这个概念的。当我们输入<code>Ctrl + C</code>，内核会发送一个<code>SIGINT</code>信号到前台进程组的每个进程，类似的，输入<code>Ctrl + Z</code>会导致内核发送一个<code>SIGTSTP</code>信号给前台进程组中的每个进程。这儿的“前台进程组”指的是<code>Shell</code>进程所属的进程组。实验中，我们并不期望信号直接作用于<code>Shell</code>进程本身（否则<code>Shell</code>收到<code>SIGINT</code>信号就终止了），而是需要让<code>Shell</code>将信号转发给<code>Shell</code>前台作业中的子进程及其所属进程组中的所有进程。所以，我们不能让子进程和<code>Shell</code>进程同属一个进程组。具体做法是通过使用<code>setpgid</code>函数来改变子进程的进程组，当调用<code>setpgid(0, 0)</code>时，内核会创建一个新的进程组，其进程组<code>ID</code>是调用者进程的<code>PID</code>，并且会把调用者进程加入到这个进程组中。</li>
<li>当<code>Shell</code>收到信号时，具体的工作需要信号处理函数来完成。例如收到<code>SIGINT</code>信号，那么信号处理函数会把该信号发往前台<code>job</code>中的进程及其所属进程组中的所有进程。实验中，我们是通过<code>kill(pid_t pid, int sig)</code>来发送信号，注意到我们并不仅仅是向<code>PID = pid</code>的进程发送信号，<code>kill</code>函数帮助我们实现了这一点：如果<code>pid</code>小于<code>0</code>，<code>kill</code>发送信号<code>sig</code>给进程组<code>|pid|</code>（<code>pid</code>的绝对值）中的每个进程。我们可以意识到，上一点需要注意的地方正是为这一点做铺垫的。</li>
<li>父进程（<code>Shell</code>）<code>fork</code>了一个子进程后，父进程需要将这个进程作为一个<code>job</code>添加到<code>job</code>队列中去（<code>addjob</code>），当子进程终止时，内核会发送一个<code>SIGCHLD</code>信号给父进程，然后在相应的信号处理程序中，把终止的子进程对应的<code>job</code>从<code>job</code>队列中删除（<code>deletejob</code>）。考虑一种情况：当父进程<code>fork</code>了一个子进程之后，子进程先于父进程获得调度，并且在父进程执行<code>addjob</code>前，子进程就已经终止了，并发送了<code>SIGCHLD</code>信号给父进程。此时，在信号处理程序中<code>deletejob</code>不会做任何操作，因为此时父进程还没有把<code>job</code>加入到<code>job</code>队列中。出现这个问题的根本原因是在<code>addjob</code>之前调用了<code>deletejob</code>。解决这个问题的方法是：在父进程<code>fork</code>子进程之前，将<code>SIGCHLD</code>信号阻塞，当完成<code>addjob</code>之后，才解除对<code>SIGCHLD</code>信号的阻塞，这样就能保证在子进程被添加到<code>job</code>队列之后再回收该子进程。注意，子进程继承了它们父进程的被阻塞信号集合，所以我们必须在调用<code>execve</code>之前，解除子进程中阻塞的<code>SIGCHLD</code>信号。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Shell Lab</code>的代码在<a href="https://github.com/tinylcy/cmu-15213/tree/master/Shell%20Lab/shlab-handout" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/shlab.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验&lt;/a&gt;通过实现一个支持作业控制的&lt;code&gt;Unix Shell&lt;/code&gt;，让我们对进程控制和信号控制更
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://tinylcy.me/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce论文阅读</title>
    <link href="http://tinylcy.me/2017/01/07/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://tinylcy.me/2017/01/07/MapReduce论文阅读/</id>
    <published>2017-01-07T13:03:08.000Z</published>
    <updated>2017-04-25T04:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>大四时曾经粗略的阅读过这篇<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">论文</a>，并且已经写过不少的<code>MapReduce</code>程序，所以介绍性的内容不再赘述。再次阅读这篇论文的原因是为了更系统的学习分布式的相关知识，我开始跟进<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="external">MIT 6.824: Distributed Systems</a>，而完成这门课程的第一个<code>lab</code>的前提便是阅读这篇论文。</p>
<p>这篇笔记重点分析了<code>MapReduce</code>的<strong>执行流程</strong>以及<strong>容错机制</strong>，因为是个人理解，若有分析不妥之处欢迎发送邮件至<code>tinylcy (at) gmail.com</code>讨论交流。</p>
<h2 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h2><p>根据不同的环境，<code>MapReduce</code>的实现方式有多种，比如基于共享内存、基于<code>NUMA</code>多处理器环境等等。而<code>Google</code>内部实现的<code>MapReduce</code>基于如下环境。</p>
<ul>
<li>双核<code>x86</code>处理器，<code>Linux</code>操作系统，每台机器有<code>2～4GB</code>的内存。</li>
<li>使用商用的网络设备，例如<code>100M</code>／<code>1G</code>带宽网卡。</li>
<li>集群是由成百上千台上述配置的设备组成的，因此集群中节点出现故障应该视为常态。</li>
<li>存储设备采用的是廉价的<code>IDE</code>硬盘。在这种不可靠的硬件上，<code>Google</code>实现了一个分布式文件系统<code>GFS</code>，通过备份和冗余来保证可靠性和可用性。</li>
<li>用户将作业（<code>job</code>）提交到调度系统，每个作业由多个任务（<code>task</code>）组成，调度系统负责将任务分配到集群空闲的节点上。</li>
</ul>
<p>在<code>Map</code>阶段，输入数据会被自动划分为<code>M</code>个分片，这些分片可以在不同的节点上被并行处理。在<code>Reduce</code>阶段，根据一定的划分规则（例如<code>hash(key) mod R</code>），中间数据会被划分为<code>R</code>个分片，这<code>R</code>个分片也可以被多个节点同时处理。<code>Reduce</code>阶段的分片个数<code>R</code>和分片规则可以由用户指定。<code>MapReduce</code>的执行流程如下图所示。</p>
<p><img src="/img/2017-01-07-Image 1.png" alt="Alt text"></p>
<p>整个执行流程可以划分为如下几个阶段，上图中的数字也标识了这几个阶段。</p>
<ul>
<li>用户程序将输入数据切分为<code>M</code>个分片（分片的大小一般为<code>16～64MB</code>，用户可以设置分片大小），并把用户程序拷贝到集群中的多个节点。因为数据要比程序大得多，所以“拷贝程序”要比“拷贝数据”高效的多。</li>
<li>在拷贝程序到节点的过程中，有一个节点比较特殊：<code>master</code>节点。其余的节点都为<code>worker</code>节点，<code>worker</code>节点负责执行具体的任务，这些任务通过<code>master</code>节点来分配。任务又分为<code>map task</code>和<code>reduce task</code>。</li>
<li>被分配到<code>map task</code>的<code>worker（map worker）</code>会读取相应的输入分片，并将输入分片中的数据解析为一系列的<code>key/value pairs</code>，然后将这些<code>key/value pairs</code>输入到用户定义的<code>map function</code>，<code>map function</code>输出的<code>key/value pairs</code>会被缓存到内存中，而不是直接写入磁盘。</li>
<li>由<code>map function</code>输出的，缓存在内存中的<code>key/value pairs</code>会被划分为<code>R</code>个分区，并定期写入到<strong>本地</strong>磁盘中。写入磁盘的位置会被推送给<code>master</code>节点，<code>master</code>节点会将磁盘的位置信息转发给下一阶段执行<code>reduce</code>任务的节点（<code>reduce worker</code>）。</li>
<li><code>reduce worker</code>在接收到磁盘的位置信息后开始读取相应的磁盘中的数据，当所有的数据读取完毕后，<code>reduce worker</code>会在内存中按照<code>key</code>将所有的<code>key/value pairs</code>进行一次排序。论文认为这次排序是必要的原因是不同的<code>key</code>往往会映射到同一个<code>reduce worker</code>。</li>
<li><code>reducer worker</code>遍历已排好序的<code>key/value pairs</code>，每遇到一个不同的<code>key</code>，便将该<code>key</code>和对应的一系列<code>value</code>传递给用户定义的<code>reduce function</code>，这个过程同时解释了为什么在上一阶段<code>reduce worker</code>要对数据进行排序（论文<code>Section 4.2</code>提到了按照key排序的两个优势，一是支持高效随机按<code>key</code>的查找，二是已经排好序的数据可以方便用户的操作）。<code>reduce function</code>将输出数据<code>append</code>到最终的输出文件中。</li>
<li>当所有的<code>map task</code>和<code>reduce task</code>都完成了，<code>master</code>唤醒用户程序并返回。</li>
</ul>
<p>在执行完整个流程后，会有<code>R</code>个输出文件，每个<code>reduce worker</code>对应一个。这<code>R</code>个输出文件一般不需要合并，因为它们往往是下一个<code>MapReduce</code>处理逻辑的输入数据。</p>
<h2 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h2><ul>
<li><code>master</code>会记录每个<code>map task</code>和<code>reduce task</code>的状态，包括<code>idle</code>、<code>in-progress</code>和<code>completed</code>。同时，<code>master</code>还会记录<code>non-idle task</code>对应的<code>worker</code>的信息。</li>
<li>对于每个<code>map task</code>，<code>master</code>会记录下<code>map function</code>输出的<code>R</code>个分片的位置信息和大小。这些信息会被推送到处于<code>in-progress</code>状态的<code>reduce worker</code>上。</li>
</ul>
<h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>由于运行在规模庞大并且廉价的硬件上，因此容错性变得非常重要。</p>
<h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p><code>master</code>会定期<code>ping</code> <code>worker</code>，如果<code>worker</code>没有响应并且超过了一定的次数，那么<code>master</code>就认为<code>worker</code>已经<code>failed</code>了。因此，所有在该<code>worker</code>上完成的<code>task</code>的状态将会被重置为初始的<code>idle</code>状态，并且这些<code>task</code>需要被重新分配到其它的<code>worker</code>上去。类似的，该<code>worker</code>上处于<code>in-progress</code>状态的<code>task</code>也会被重置为最初的<code>idle</code>状态，并被重新分配到其它<code>worker</code>上去。</p>
<p>对于已完成的<code>map task</code>，也需要重新被执行。因为<code>map task</code>的输出是在<code>worker</code>的本地磁盘上，因为<code>worker</code>已经失联了，所以<code>map task</code>的输出数据自然也获取不到。对于已完成的<code>reduce task</code>，不再需要重新执行。因为<code>reduce task</code>的输出是在全局的文件系统（<code>GFS</code>）上。</p>
<p>如果一个<code>map task</code>一开始运行在<code>worker A</code>上，接着由于<code>worker A</code> <code>failed</code>导致该<code>map task</code>迁移到<code>worker B</code>上。那么读取该<code>map task</code>输出数据并且处于正在执行的<code>reduce worker</code>会收到重新执行<code>reduce task</code>的通知，任何还未开始读取数据的<code>reduce task</code>也会收到通知。<code>reduce worker</code>接下来会从<code>worker B</code>上读取数据。</p>
<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>可以通过定期建立检查点的方式来保存<code>master</code>的状态。但是，<code>Google</code>当时的做法是考虑到只有一个<code>master</code>，所以<code>master</code>出现故障的概率很小，如果出现故障了，重新开始整个<code>MapReduce</code>计算。</p>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>网络带宽在计算环境中属于一种非常稀缺的资源，利用输入数据的特性可以减小网络带宽。</p>
<ul>
<li>输入数据由<code>GFS</code>来管理，<code>GFS</code>把数据存储在集群节点的本地磁盘上，<code>GFS</code>将文件分割为<code>64MB</code>大小的块，并且针对每个块会做冗余（一般冗余<code>2</code>份）。<code>master</code>利用输入数据的位置信息，将<code>map task</code>分配给输入数据所在的节点。</li>
<li>如果在计算过程中出现了失败的情况，那么<code>master</code>会把任务调度给离输入数据较近的节点。</li>
</ul>
<h2 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h2><p>从上文我们可以得知，<code>map</code>阶段被划分成<code>M</code>个<code>task</code>，<code>reduce</code>阶段被划分成<code>R</code>个<code>task</code>，<code>M</code>和<code>R</code>一般会比集群中节点的个数大得多。每个节点运行多个<code>task</code>有利于动态的负载均衡，加速<code>worker</code>从失败中恢复。</p>
<p>在具体的实现中，<code>M</code>和<code>R</code>的大小是有实际限制的，因为<code>master</code>至少要做<code>O(M＋R)</code>次的调度决策，并且需要保持<code>O(M*R)</code>个状态。</p>
<p>通常情况下，<code>R</code>的大小是由用户指定的，而对<code>M</code>的选择要保证每个<code>task</code>的输入数据大小，即一个输入分片在<code>16MB～64MB</code>之间，这样可以最大化的利用数据本地性。</p>
<h2 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h2><p>导致整个<code>MapReduce</code>计算过程被延迟的原因之一是过多的时间花费在最后几个<code>map task</code>或<code>reduce task</code>上。导致这个问题的原因由很多，可能是因为<code>task</code>所在的节点硬盘的读写速度非常慢，同时<code>master</code>又有可能把新的<code>task</code>分配给了该节点，所以引入了更加激烈的<code>CPU</code>竞争、内存竞争。</p>
<p>一种通用的解决方案是在整个<code>MapReduce</code>计算快要结束时，<code>master</code>对当前处于<code>in-progress</code>状态的<code>task</code>进行备份，无论是原来的<code>task</code>执行完毕还是备份的<code>task</code>执行完毕，那么就认为该<code>task</code>完成了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce: Simplified Data Processing on Large Clusters</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大四时曾经粗略的阅读过这篇&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf&quot; target=&quot;_blank&quot;
    
    </summary>
    
    
      <category term="Distributed System" scheme="http://tinylcy.me/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>Bigtable论文阅读</title>
    <link href="http://tinylcy.me/2017/01/04/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://tinylcy.me/2017/01/04/Bigtable论文阅读/</id>
    <published>2017-01-04T11:53:17.000Z</published>
    <updated>2017-04-26T11:33:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我对Bigtable论文进行第一轮阅读所做的笔记。对于理解欠妥的地方，欢迎发送邮件至<code>tinylcy (at) gmail.com</code>讨论。</p>
<a id="more"></a>
<h2 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h2><blockquote>
<p>A Bigtable is a sparse, distributed, persistent multi-dimensional sorted map. The map is indexed by a row key, column key, and a timestamp; each value in the map is an uninterpreted arrays of bytes.</p>
</blockquote>
<p>Bigtable是稀疏的、分布式的、持久化的、多维度的、顺序的map，我们可以将Bigtable的数据模型抽象为一系列的键值对，满足的映射关系为：<code>(row:string, column:string, time:int64) -&gt; string</code>。</p>
<p><img src="/img/2017-01-04-Image 1.png" alt=""></p>
<blockquote>
<p>A slice of an example table that stores Web pages. The row name is a reversed URL. The contents column family contains the page contents, and the anchor column family contains the text of any anchors that reference the page. CNN’s home page is referenced by both the Sports Illustrated and the MY-look home pages, so the row contains columns named anchor:cnnsi.com and anchor:my.look.ca. Each anchor cell has one version; the contents column has three versions, at timestamps t3 , t5 , and t6.</p>
</blockquote>
<h3 id="Rows"><a href="#Rows" class="headerlink" title="Rows"></a>Rows</h3><blockquote>
<ul>
<li>The row keys in a table are arbitrary strings.</li>
<li>Bigtable maintains data in lexicographic order by row key.</li>
<li>The row range for a table is dynamically partitioned. Each row range is called a tablet, which is the unit of distribution and load balancing.</li>
</ul>
</blockquote>
<ul>
<li>Bigtable内部的行键（row key）会按照字典序排序，因为系统庞大且为分布式，所以排序这个特性会带来很大的好处，行的空间邻近性可以确保当我们在扫描表时，我们感兴趣的记录会大概率的汇聚到一起。</li>
<li>Tablet是Bigtable分配和负载均衡的单元，Bigtable的表根据行键自动划分为tablet。最初表都只有一个tablet，但随着表的不断增大，原始的tablet自动分割为多个tablet。</li>
</ul>
<h3 id="Column-Families"><a href="#Column-Families" class="headerlink" title="Column Families"></a>Column Families</h3><blockquote>
<ul>
<li>Column keys are grouped into sets called column families, which form the basic unit of access control.</li>
<li>All data stored in a column family is usually of the same type.</li>
<li>A column family must be created before data can be stored under any column key in that family; after a family has been created, any column key within the family can be used.</li>
<li>Column families rarely change during operation. In contrast, a table may have an unbounded number of columns.</li>
</ul>
</blockquote>
<ul>
<li>Bigtable把所有的列划分为若干个列族（column family），每个列族一般存储相同类型的数据。关于这点，我联想到在大部分的NoSQL数据库中，始终贯穿的一个理念就是<strong>面向聚合</strong>，NoSQL往往是应用在集群环境中，而在集群环境下的跨表JOIN实现起来会比单机关系型数据库复杂的多，所以在设计表时，我们就把相同类型的数据尽可能汇聚在一起，即每个列族一般存储相同类型的数据。</li>
<li>一行的列族很少变化（改变的开也会比较大），但是列族里的列是允许随意增减的。列键（column key）是通过family:qualifier来定位的。</li>
</ul>
<h3 id="Timestamps"><a href="#Timestamps" class="headerlink" title="Timestamps"></a>Timestamps</h3><blockquote>
<ul>
<li>Each cell in a Bigtable can contain multiple versions of the same data; these versions are indexed by timestamp.</li>
<li>Different versions of a cell are stored in decreasing timestamp order, so that the most recent version can be read first.</li>
</ul>
</blockquote>
<ul>
<li>对于具有相同行键（row key）和列键（column key）的数据（cell），Bigtable会存储这个数据的多个版本，这些版本通过时间戳来区分，用户可以版本的数量。</li>
<li>数据按照时间戳降序排序，这样可以保证取到的数据是最新的。同时，过期的数据也会被回收。</li>
</ul>
<p>我们现在再回顾论文一开始便提到的：A Bigtable is a … map，传统的map由一系列键值对组成，在Bigtable中，对应的键是由多个数据复合而成的，即row key，column key和timestamp。</p>
<h2 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h2><p>Bigtable的实现依托于Google的几个基础组件：Google File System，Google SSTable 和 Chubby。</p>
<blockquote>
<ul>
<li>Bigtable uses the distributed Google File System(GFS)  to store log and data files.</li>
<li>The Google SSTable file format is used internally to store Bigtable data. An SSTable provides a persistent, ordered immutable map from keys to values.</li>
<li>Bigtable relies on a highly-available and persistent distributed lock service called Chubby. Bigtable uses Chubby for a variety of tasks.<ul>
<li>to ensure that there is at most one active master at any time;</li>
<li>to store bootstrap location of Bigtable data;</li>
<li>to discover tablet servers and finalize tablet server deaths;</li>
<li>to store access control lists;</li>
</ul>
</li>
</ul>
</blockquote>
<p>Chubby是一个高可靠用于分布式的锁服务，其目的是解决分布式一致性的问题，通过Paxos算法实现。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Bigtable的系统结构由三个部分组成，包括客户端中用于通信的Library、一个主节点（master server）和一系列从节点（tablet servers）。整个架构可以从下图清晰的体现出来。</p>
<p><img src="/img/2017-01-04-Image 2.jpg" alt=""></p>
<blockquote>
<ul>
<li>The master is responsible for assigning tablets to tablet servers, detecting the addition and expiration of tablet servers, balancing tablet-server load, and garbage collection of files in GFS.</li>
<li>Each tablet server manages a set of tablets and handles read and write requests to the tablets that it has load, and also splits tablets that have grown too large.</li>
</ul>
</blockquote>
<p>需要注意的是，客户端在读写数据时直接和tablet server通信，不需要经过master server，而且在Bigtable中，客户端获取tablet位置信息也不依赖于master server。因此在大多数情况下，客户端都不会和master server通信，这就大大降低了由单个master server造成的单点故障的可能性。关于这点我们从上图也可以得知。</p>
<h3 id="Tablet-Location"><a href="#Tablet-Location" class="headerlink" title="Tablet Location"></a>Tablet Location</h3><p>前面已经提到，客户端在获取tablet位置信息时并不需要经过master server，那么tablet的位置信息时如何定位的？首先，需要了解tablet的位置信息是如何存储的。Bigtable通过类似B+树的结构来存储tablet的位置信息，如下图所示。</p>
<p><img src="/img/2017-01-04-Image 3.png" alt=""></p>
<blockquote>
<ul>
<li>The first level is a file stored in Chubby that contains the location of the root tablet. The root tablet contains the location of all tablets in a special METADATA table.</li>
<li>Each METADATA tablet contains the location of a set of user tables.</li>
</ul>
</blockquote>
<p>Root tablet存储了一系列METADATA tablet的位置信息，而user tablet的位置信息存储在这些METADATA tablets中。论文中提到root tablet是不允许被分片的，这么做的目的是保证整个tablet location hierarchy不超过3层。这意味着Bigtable的数据存储还是有上限的，于是论文计算了3层架构能够存储的tablet的数量。</p>
<blockquote>
<p>Each METADATA row stores approximately 1KB of data in memory. With a modest limit of 128 MB METADATA tablets, our three-level location scheme is sufficient to address 2^34 tablets (or 2^61 bytes in 128 MB tablets).</p>
</blockquote>
<p>客户端会缓存tablet的位置信息，客户端在获取tablet的位置信息时，会涉及到两种情况。</p>
<ul>
<li>如果客户端没有缓存目标tablet的位置信息，那么就会沿着root tablet定位到最终的tablet，整个过程需要3个network round-trips。</li>
<li>如果客户端缓存了目标tablet的位置信息，但是到了目标tablet后发现原来缓存的tablet位置信息过时了，那么会重新从root tablet开始定位tablet，整个过程需要6个network round-trips。</li>
</ul>
<h3 id="Tablet-Assignment"><a href="#Tablet-Assignment" class="headerlink" title="Tablet Assignment"></a>Tablet Assignment</h3><p>当tablet server启动时，它会在Chubby的某个特定目录下创建并获取一个锁文件（互斥锁），这个锁文件的名称是唯一表示该tablet server的。master server通过监控这个目录获取当前存活着的tablet server的信息。</p>
<ul>
<li>如果tablet server失去了锁（比如网络问题），那么tablet server也就不再为对应的tablet服务了。</li>
<li>如果锁文件存在，那么tablet server会主动获取锁。</li>
<li>如果所文件不存在了，那么tablet server就永远不会再服务对应的tablet了，所以tablet server就会自己kill掉自己。</li>
<li>当tablet server要终止时，它会自己释放占有的锁，master server就会把该tablet server上的tablet分配给其它的tablet server。</li>
</ul>
<p>那么maser server是如何获知tablet server不再服务了呢？master server会定期轮询每个tablet server的锁状态。如果tablet server报告自己失去了已经失去了锁，或者master server不能获取tablet server的状态，那么master server就会尝试去获取tablet server对应的锁文件。如果master server获取到了所文件，并且Chubby是处于正常工作的状态的，此时master server就确认tablet server已经无法再提供服务了，master server删除相应的锁文件并把tablet server对应的tablet分配给新的tablet server。</p>
<p>如果master server与Chubby之间出现了网络问题，那么master server会自己kill掉自己。但是这并不会影响tablet与tablet server之间的分配关系。</p>
<p>master server的启动需要经历一下几个阶段。</p>
<ul>
<li>master server需要从Chubby获取锁，这样可以确保在同一时刻只有一个master server在工作。</li>
<li>master server扫描Chubby下特定的目录（即tablet server创建锁文件的目录），获取存活着的tablet server的信息。</li>
<li>master server与存活着的tablet server通信，获取已被分配到tablet server的tablet信息。</li>
<li>master server扫描METADATA tablet，获取所有的tablet信息，然后把未分配的tablet分配给tablet server。</li>
</ul>
<p>在论文Section 5.2中有一段话还有待理解，如下。</p>
<blockquote>
<p>One complication is that the scan of the METADATA table cannot happen until the METADATA tablets have been assigned. Therefore, before starting this scan (step 4), the master adds the roottablet to the set of unassigned tablets if an assignment for the root tablet was not discovered during step 3. This addition ensures that the root tablet will be assigned. Because the root tablet contains the names of all METADATA tablets, the master knows about all of them after it has scanned the root tablet.</p>
</blockquote>
<p>当出现如下几种情况时，tablet的分配情况会发生变化。</p>
<ul>
<li>tablet的创建和删除。</li>
<li>已有的两个tablet合并为一个较大的tablet。</li>
<li>已有的一个tablet分割为两个较小的tablet。</li>
</ul>
<p>对于前两种情况，master server可以马上调整（因为它们是发生在master server上的），但是对于tablet分割，由于它是发生在tablet server上的，因此需要tablet server通知master server。论文关于这一点的描述如下。</p>
<blockquote>
<p>The tablet server commits the split by recording information for the new tablet in the METADATA table. When the split has committed, it notifies the master.</p>
</blockquote>
<h3 id="Tablet-Serving"><a href="#Tablet-Serving" class="headerlink" title="Tablet Serving"></a>Tablet Serving</h3><p>tablet的持久化是通过存储为GFS文件的形式实现的，下图描述了tablet更新操作的实现。</p>
<p><img src="/img/2017-01-04-Image 4.png" alt=""></p>
<p>当发生更新时，首先将更新操作写到tablet log日志文件中去，然后把待更新的内容先写到memtable中，memtable是内存中一个排序的缓冲，保存了最近的一次更新操作的内容。更早的更新内容会被持久化到SSTable文件中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf" target="_blank" rel="external">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable" target="_blank" rel="external">Understanding HBase and BigTable</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我对Bigtable论文进行第一轮阅读所做的笔记。对于理解欠妥的地方，欢迎发送邮件至&lt;code&gt;tinylcy (at) gmail.com&lt;/code&gt;讨论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Distributed System" scheme="http://tinylcy.me/tags/Distributed-System/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结及2017年度计划</title>
    <link href="http://tinylcy.me/2017/01/01/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E5%8F%8A2017%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    <id>http://tinylcy.me/2017/01/01/2016年度总结及2017年度计划/</id>
    <published>2016-12-31T18:24:14.000Z</published>
    <updated>2017-04-25T04:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>从<code>2016</code>年<code>12</code>月开始持续使用<a href="https://pomotodo.com/" target="_blank" rel="external">Pomotodo</a>起，我逐渐意识到给自己定下量化计划是一件能够提升学习效率的事情。<code>2017</code>年的核心目标依然是提高自己，但是会采用具体的量化的指标来代替模糊性描述。其实这就类似于我们在<code>git commit</code>时候，如果以<code>git commit -m &quot;fix some bugs&quot;</code>的形式<code>commit</code>，那么在后期这些<code>descriptions</code>并不会带给我们任何帮助。</p>
<h3 id="2016总结"><a href="#2016总结" class="headerlink" title="2016总结"></a>2016总结</h3><ul>
<li><code>2016</code>年<code>3</code>月至<code>6</code>月我需要完成学校的课程，但是总体来说，课程的质量不算高，我没有在这些课程及考试上花太多的时间，但是尴尬的是我拿了一等学业奖学金（逃。</li>
<li>在课程及暑假期间我参与了一个网站外包项目。对我而言，这个项目最大的意义在于让我了解除了开发以外的工作，包括文档的编写、与人的沟通。在大型软件的开发过程中，最大的问题可能不是技术问题，而是<code>people problem</code>。</li>
<li><code>2016</code>年读了不少书，有些书读完了，有些书拣一部分读。经典技术书籍主要包括《<code>C</code>程序设计语言》（<code>100%</code>）、《<code>C Primer Plus</code>》（<code>60%</code>）、《<code>Linux/UNIX</code>系统编程手册》（<code>60%</code>）、《算法》（<code>50%</code>）、《深入理解<code>Java</code>虚拟机》（<code>50%</code>）、《图解<code>HTTP</code>》（<code>90%</code>）、《深入理解计算机系统》（<code>40%</code>）、《大型网站技术架构》（<code>100%</code>）、《深入分析<code>Java Web</code>》（<code>70%</code>）。其它书籍包括《白夜行》、《解忧杂货店》、《人类简史》、《活着》、《平凡的世界》等。</li>
<li><code>2016</code>年最大的惊喜发生在最后一天。我的学生生涯第一篇一作<code>SCI</code>被录用。从学术和技术的角度上说，我个人认为我的论文存在诸多不足之处，但是这篇论文对我而言象征意义重大。感谢我的导师。</li>
<li><code>2016</code>年我开始花时间运营自己的<a href="http://tinylcy.me/">博客</a>，我把我的博客迁移到了<code>Github</code>，并购买了域名，开始注重技术文章的质量以及文章的脉络。</li>
<li><code>2016</code>年我的个人小项目<a href="https://github.com/tinylcy/RecommendationEngine" target="_blank" rel="external">RecommendationEngine</a>在<code>Github</code>上收集到了一丢丢的<code>stars</code>和<code>forks</code>。为了更好的学习网络编程，我开始编写一个轻量级的<code>Web</code> 服务器<a href="https://github.com/tinylcy/tinyhttpd" target="_blank" rel="external">tinyhttpd</a>，目前<code>tinyhttpd</code>的主体框架和基本功能已完成。</li>
<li><code>2016</code>年<code>12</code>月开始，我开始跟随视频学习《深入理解计算机系统》，课程全英文且无字幕，在边听边理解了两节课后，除了感叹授课老师深厚的功底之外，我的英语听力也有所提升，至少目前听课不会感到不适了。</li>
<li>入手<code>MacBook Pro</code>。</li>
<li><code>2016</code>年最不满意的一点是我的身体保持的很不好，严重缺少身体机能上的锻炼。</li>
</ul>
<h3 id="2017计划"><a href="#2017计划" class="headerlink" title="2017计划"></a>2017计划</h3><ul>
<li>身体是本钱，每周要强制性体育锻炼，每周的跑步次数大于等于<code>3</code>次。</li>
<li>继续完善自己的知识架构，努力把计算机系统的基础知识形成闭环，完成《深入理解计算机系统》第一轮的全面阅读。</li>
<li><code>2017</code>年有两件对我而言可能是非常重要的事情，一是实习，二是校招。从二月份开始要针对性的进行准备。</li>
<li>开始准备研究生阶段的第二篇论文，同时作为研究生的毕业设计。</li>
<li>继续读书，将<code>2016</code>年未读完的部分读完，并继续阅读计算机科学领域的经典书籍。</li>
<li>争取能够阅读一个开源项目的源码（部分也行）。</li>
<li>锻炼自己的自律能力和观察能力，学会从不同角度看待问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;code&gt;2016&lt;/code&gt;年&lt;code&gt;12&lt;/code&gt;月开始持续使用&lt;a href=&quot;https://pomotodo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pomotodo&lt;/a&gt;起，我逐渐意识到给自己定下量化计划是一件能
    
    </summary>
    
    
      <category term="Life" scheme="http://tinylcy.me/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC容器初始化 — Resource定位源码分析</title>
    <link href="http://tinylcy.me/2016/12/07/Spring-IoC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%94Resource%E5%AE%9A%E4%BD%8D%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/12/07/Spring-IoC容器初始化—Resource定位源码分析/</id>
    <published>2016-12-07T07:53:56.000Z</published>
    <updated>2017-04-25T04:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Spring IoC</code>容器的设计中，有两个主要的容器系列。一个是实现了<code>BeanFactory</code>接口的简单容器系列，这系列容器只实现了容器基本的功能；另一个是<code>ApplicationContext</code>应用上下文，它在简单容器的基础上增加了许多面向框架的特性，同时对应用环境做了许多适配。</p>
<h2 id="IoC容器的初始化过程"><a href="#IoC容器的初始化过程" class="headerlink" title="IoC容器的初始化过程"></a>IoC容器的初始化过程</h2><p><code>Spring IoC</code>容器的初始化过程分为三个阶段：<code>Resource</code>定位、<code>BeanDefinition</code>的载入和向<code>IoC</code>容器注册<code>BeanDefinition</code>。<code>Spring</code>把这三个阶段分离，并使用不同的模块来完成，这样可以让用户更加灵活的对这三个阶段进行扩展。</p>
<ul>
<li><code>Resource</code>定位指的是<code>BeanDefinition</code>的资源定位，它由<code>ResourceLoader</code>通过统一的<code>Resource</code>接口来完成，<code>Resource</code>对各种形式的<code>BeanDefinition</code>的使用都提供了统一的接口。</li>
<li><code>BeanDefinition</code>的载入是把用户定义好的<code>Bean</code>表示成<code>IoC</code>容器内部的数据结构，而这个容器内部的数据结构就是<code>BeanDefinition</code>，<code>BeanDefinition</code>实际上就是<code>POJO</code>对象在<code>IoC</code>容器中的抽象。通过<code>BeanDefinition</code>，<code>IoC</code>容器可以方便的对<code>POJO</code>对象进行管理。</li>
<li>向<code>IoC</code>容器注册<code>BeanDefinition</code>是通过调用<code>BeanDefinitionRegistry</code>接口的实现来完成的，这个注册过程是把载入的<code>BeanDefinition</code>向<code>IoC</code>容器进行注册。实际上，在<code>IoC</code>容器内部维护着一个<code>HashMap</code>，而这个注册过程其实就将<code>BeanDefinition</code>添加至这个<code>HashMap</code>。</li>
</ul>
<p>我们可以自己定义<code>Resource</code>、<code>BeanFactory</code>和<code>BeanDefinitionReader</code>来初始化一个容器。如下代码片段使用了<code>DefaultListableBeanFactory</code>作为实际使用的<code>IoC</code>容器。同时，创建<code>IoC</code>配置文件（<code>dispatcher-servlet.xml</code>）的抽象资源，这个抽象资源包含了<code>BeanDefinition</code>的定义信息。最后，还需要创建一个载入<code>BeanDefinition</code>的读取器，此处使用<code>XmlBeanDefinitionReader</code>，通过一个回调配置给<code>BeanFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"dispatcher-servlet.xml"</span>);</div><div class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</div><div class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</div><div class="line">reader.loadBeanDefinitions(res);</div></pre></td></tr></table></figure>
<p>我们也可以通过<code>ApplicationContext</code>创建一个<code>IoC</code>容器。在<code>Spring</code>中，系统已经提供许多定义好的容器实现，而不需要自己组装。如下代码片段以<code>FileSystemXmlApplicationContext</code>为例创建了一个<code>IoC</code>容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FileSystemXmlApplicationContext context = </div><div class="line">        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:dispatcher-servlet.xml"</span>);</div></pre></td></tr></table></figure>
<p>无论使用哪种方式初始化<code>IoC</code>容器，都会经历上述三个阶段。本篇文章将结合<code>Spring 4.0.2</code>源码，并以<code>FileSystemXmlApplicationContext</code>为例对<code>IoC</code>容器初始化的第一阶段，也就是<code>Resource</code>定位阶段进行分析。</p>
<h2 id="BeanDefinition的Resource定位"><a href="#BeanDefinition的Resource定位" class="headerlink" title="BeanDefinition的Resource定位"></a>BeanDefinition的Resource定位</h2><p>下图展示了<code>FileSystemXmlApplicationContext</code>的继承体系，<code>FileSystemXmlApplicationContext</code>继承自<code>AbstractApplicationContext</code>，而<code>AbstractApplicationContext</code>又继承自<code>DefaultResourceLoader</code>，<code>DefaultResourceLoader</code>实现了<code>ResourceLoader</code>接口。因此<code>FileSystemXmlApplicationContext</code>具备读取定义了<code>BeanDefinition</code>的<code>Resource</code>的能力。</p>
<p><img src="/img/2016-12-07-Image 1.png" alt="Alt text"></p>
<p>我们的分析入口是<code>new FileSystemXmlApplicationContext(&quot;classpath:dispatcher-servlet.xml&quot;);</code>，这句代码调用了<code>FileSystemXmlApplicationContext</code>的构造方法。<code>FileSystemXmlApplicationContext</code>的构造方法源码如下（只提取与本次分析关联的代码）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, 	</span></span></div><div class="line">                                       ApplicationContext parent) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">    <span class="keyword">super</span>(parent);</div><div class="line">    <span class="keyword">this</span>.setConfigLocations(configLocations);</div><div class="line">    <span class="keyword">if</span>(refresh) &#123;</div><div class="line">        <span class="keyword">this</span>.refresh();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建<code>FileSystemXmlApplicationContext</code>时，我们仅传入了包含<code>BeanDefinition</code>的配置文件路径（<code>classpath:dispatcher-servlet.xml</code>），由此调用<code>FileSystemXmlApplicationContext(String configLocation)</code>构造方法。接着，<code>FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</code>构造方法被间接调用，在该构造方法内部，<code>refresh</code>方法完成了整个<code>IoC</code>容器的初始化。因此，<code>refresh</code>方法是我们分析的下一个入口。</p>
<p><code>refresh</code>方法的具体实现定义在<code>FileSystemXmlApplicationContext</code>的父类<code>AbstractApplicationContext</code>中，对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">    Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">        <span class="keyword">this</span>.prepareRefresh();</div><div class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</div><div class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</div><div class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</div><div class="line">            <span class="keyword">this</span>.initMessageSource();</div><div class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</div><div class="line">            <span class="keyword">this</span>.onRefresh();</div><div class="line">            <span class="keyword">this</span>.registerListeners();</div><div class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</div><div class="line">            <span class="keyword">this</span>.finishRefresh();</div><div class="line">        &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</div><div class="line">            <span class="keyword">this</span>.destroyBeans();</div><div class="line">            <span class="keyword">this</span>.cancelRefresh(var5);</div><div class="line">            <span class="keyword">throw</span> var5;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>refresh</code>方法中，通过<code>obtainFreshBeanFactory</code>方法，<code>ConfigurableListableBeanFactory</code>类型的<code>BeanFactory</code>被创建。我们接着进入<code>obtainFreshBeanFactory</code>方法，<code>obtainFreshBeanFactory</code>方法也定义在<code>AbstractApplicationContext</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.refreshBeanFactory();</div><div class="line">    ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.getBeanFactory();</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Bean factory for "</span> + <span class="keyword">this</span>.getDisplayName() + <span class="string">": "</span> + beanFactory);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> beanFactory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</div></pre></td></tr></table></figure>
<p>我们重点关注<code>refreshBeanFactory</code>方法的实现。在<code>AbstractApplicationContext</code>中，<code>refreshBeanFactory</code>方法仅仅是个声明，具体的实现委托给了子类完成。此处，<code>refreshBeanFactory</code>方法的具体实现定义在了<code>AbstractRefreshableApplicationContext</code>，<code>AbstractRefreshableApplicationContext</code>正是继承自<code>AbstractApplicationContext</code>，这点我们可以从上文的继承体系图可以得知。<code>refreshBeanFactory</code>方法在<code>AbstractRefreshableApplicationContext</code>中的定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</div><div class="line">        <span class="keyword">this</span>.destroyBeans();</div><div class="line">        <span class="keyword">this</span>.closeBeanFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        DefaultListableBeanFactory ex = <span class="keyword">this</span>.createBeanFactory();</div><div class="line">        ex.setSerializationId(<span class="keyword">this</span>.getId());</div><div class="line">        <span class="keyword">this</span>.customizeBeanFactory(ex);</div><div class="line">        <span class="keyword">this</span>.loadBeanDefinitions(ex);</div><div class="line">        Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">            <span class="keyword">this</span>.beanFactory = ex;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException var5) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory var1)</span> <span class="keyword">throws</span> BeansException, IOException</span>;</div></pre></td></tr></table></figure>
<p><code>refreshBeanFactory</code>方法首先会判断是否已经建立的<code>BeanFactory</code>，如果已经建立，那么需要销毁并关闭该<code>BeanFactory</code>。接着，<code>refreshBeanFactory</code>方法通过<code>createBeanFactory</code>方法创建了一个<code>IoC</code>容器供<code>ApplicationContext</code>使用，且这个<code>IoC</code>容器的实际类型为<code>DefaultListableBeanFactory</code>。同时，<code>refreshBeanFactory</code>方法将这个<code>IoC</code>容器作为参数，调用<code>loadBeanDefinitions</code>载入了<code>BeanDefinition</code>（本文暂不分析载入过程的具体操作）。</p>
<p><code>loadBeanDefinitions</code>方法也仅仅在<code>AbstractRefreshableApplicationContext</code>中声明，具体的实现定义在<code>AbstractXmlApplicationContext</code>中，从继承体系图我们可以得知<code>AbstractXmlApplicationContext</code>正是<code>AbstractRefreshableApplicationContext</code>的子类。<code>loadBeanDefinitions</code>方法对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</div><div class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</div><div class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</div><div class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</div><div class="line">    <span class="keyword">this</span>.initBeanDefinitionReader(beanDefinitionReader);</div><div class="line">    <span class="keyword">this</span>.loadBeanDefinitions(beanDefinitionReader);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">    Resource[] configResources = <span class="keyword">this</span>.getConfigResources();</div><div class="line">    <span class="keyword">if</span>(configResources != <span class="keyword">null</span>) &#123;</div><div class="line">        reader.loadBeanDefinitions(configResources);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String[] configLocations = <span class="keyword">this</span>.getConfigLocations();</div><div class="line">    <span class="keyword">if</span>(configLocations != <span class="keyword">null</span>) &#123;</div><div class="line">        reader.loadBeanDefinitions(configLocations);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>loadBeanDefinitions(DefaultListableBeanFactory beanFactory)</code>中，定义了<code>BeanDefinition</code>的读入器<code>beanDefinitionReader</code>。<code>Spring</code>把定位、读入和注册的过程解耦，这正是体现之处之一。接着<code>beanDefinitionReader</code>作为参数，调用<code>loadBeanDefinitions(XmlBeanDefinitionReader reader)</code>方法，如果<code>configResources</code>为空，那么<code>reader</code>就会根据<code>configLocations</code>调用<code>reader</code>的<code>loadBeanDefinitions</code>去加载相应的<code>Resource</code>。在<code>AbstractBeanDefinitionReader</code>和<code>XmlBeanDefinitionReader</code>中个自定义了不同的<code>loadBeanDefinitions</code>方法，与我们本次分析相关的代码定义在<code>AbstractBeanDefinitionReader</code>中，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    String[] var3 = locations;</div><div class="line">    <span class="keyword">int</span> var4 = locations.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</div><div class="line">        String location = var3[var5];</div><div class="line">        counter += <span class="keyword">this</span>.loadBeanDefinitions(location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBeanDefinitions(location, (Set)<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">    ResourceLoader resourceLoader = <span class="keyword">this</span>.getResourceLoader();</div><div class="line">    <span class="keyword">if</span>(resourceLoader == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> loadCount;</div><div class="line">        <span class="keyword">if</span>(!(resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver)) &#123;</div><div class="line">            Resource var11 = resourceLoader.getResource(location);</div><div class="line">            loadCount = <span class="keyword">this</span>.loadBeanDefinitions((Resource)var11);</div><div class="line">            <span class="keyword">if</span>(actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">                actualResources.add(var11);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> loadCount;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Resource[] resource =</div><div class="line">                    ((ResourcePatternResolver)resourceLoader).getResources(location);</div><div class="line">                loadCount = <span class="keyword">this</span>.loadBeanDefinitions(resource);</div><div class="line">                <span class="keyword">if</span>(actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">                    Resource[] var6 = resource;</div><div class="line">                    <span class="keyword">int</span> var7 = resource.length;</div><div class="line"></div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var8 = <span class="number">0</span>; var8 &lt; var7; ++var8) &#123;</div><div class="line">                        Resource resource1 = var6[var8];</div><div class="line">                        actualResources.add(resource1);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> loadCount;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException var10) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, var10);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources)</code>方法中，我们可以看到，<code>Resource</code>的定位工作交给了<code>ResourceLoader</code>来完成。对于取得<code>Resource</code>的具体过程，我们可以看看<code>DefaultResourceLoader</code>是怎样完成的，对应源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</div><div class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);</div><div class="line">    <span class="keyword">if</span>(location.startsWith(<span class="string">"classpath:"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(<span class="string">"classpath:"</span>.length()),</div><div class="line">                                     <span class="keyword">this</span>.getClassLoader());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL ex = <span class="keyword">new</span> URL(location);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException var3) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getResourceByPath(location);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们传入的<code>location</code>为<code>classpath:dispatcher-servlet.xml</code>，因此<code>getResource</code>方法会生成一个<code>ClassPathResource</code>并返回，如果我们传入的是一个文件路径，那么会调用<code>getResourceByPath</code>方法，<code>getResourceByPath</code>方法定义在<code>FileSystemXmlApplicationContext</code>中，对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">        path = path.substring(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此，我们完成了<code>IoC</code>容器在初始化过程中的<code>Resource</code>定位过程的流程分析，这为接下来进行<code>BeanDefinition</code>数据的载入和解析创造了条件。</p>
<p>后续我会对<code>BeanDefinition</code>的载入和解析过程结合源码进行分析，欢迎关注。若本文存在分析不妥之处，建议发送邮件至<code>tinylcy (at) gmail.com</code>交流，直接在页面评论亦可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Spring IoC&lt;/code&gt;容器的设计中，有两个主要的容器系列。一个是实现了&lt;code&gt;BeanFactory&lt;/code&gt;接口的简单容器系列，这系列容器只实现了容器基本的功能；另一个是&lt;code&gt;ApplicationContext&lt;/code&gt;应用上
    
    </summary>
    
    
      <category term="Spring" scheme="http://tinylcy.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://tinylcy.me/2016/12/04/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/12/04/HashMap源码分析/</id>
    <published>2016-12-04T03:46:58.000Z</published>
    <updated>2017-04-25T04:47:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>本文针对<code>HashMap</code>的源码分析基于<code>JDK 7</code>，<code>JDK 8</code>在<code>HashMap</code>的实现上有着较大幅度的改进和优化，这部分优化我将另起一篇来阐述。另外，本文仅分析<code>HashMap</code>众多方法中最常用的方法，其余方法有需要时再研究 :smile:。</p>
<p><code>HashMap</code>的继承关系如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p><code>HashMap</code>继承自<code>AbstractMap</code>，同时实现了<code>Map</code>、<code>Cloneable</code>和<code>Serializable</code>接口。因此，<code>HashMap</code>可以被克隆，并支持序列化。另外，<code>HashMap</code>是一个非线程安全的，因此适合运用在单线程环境下。如果是在多线程环境，可以通过<code>Collections</code>的静态方法<code>synchronizedMap</code>获得线程安全的<code>HashMap</code>，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</div></pre></td></tr></table></figure>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>针对每个键值对，<code>HashMap</code>使用内部类<code>Entry</code>来存储，<code>Entry</code>核心代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K, V&gt; next;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">  </div><div class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">        value = v;</div><div class="line">        next = n;</div><div class="line">        key = k;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从整体上看，<code>HashMap</code>底层的存储结构是基于数组和链表实现的。对于每一个要存入<code>HashMap</code>的键值对（<code>Key-Value Pair</code>），通过计算<code>Key</code>的<code>hash</code>值来决定存入哪个数组单元（<code>bucket</code>），为了处理<code>hash</code>冲突，每个数组单元实际上是一条<code>Entry</code>单链表的头结点，其后引申出一条单链表。<code>HashMap</code>的存储结构如下图所示。</p>
<p><img src="/img/2016-12-04-Image 1.png" alt="Alt text"></p>
<h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><p><code>HashMap</code>定义了几个关键属性，对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="keyword">transient</span> Entry[] table;</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code>代表<code>HashMap</code>槽（<code>bucket</code>）的默认容量，且该容量必须为<code>2</code>的幂，具体原因会在下文解释。</li>
<li><code>MAXIMUM_CAPACITY代表HashMap</code>槽（<code>bucket</code>）的最大容量，如果传入的容量大于<code>1 &lt;&lt; 30</code>，那么实际容量会被<code>MAXIMUM_CAPACITY</code>替换。</li>
<li><code>DEFAULT_LOAD_FACTOR</code>是默认的加载因子，用于计算<code>HashMap</code>扩容的<code>threshold</code>，当<code>HashMap</code>的实际元素容量达到总容量的<code>threshold</code>时，对<code>HashMap</code>进行扩容。</li>
<li><code>table</code>是存储<code>Entry</code>的数组，每个<code>Entry</code>是一条单链表的头结点。</li>
<li><code>size</code>代表<code>HashMap</code>键值对的数量。</li>
<li><code>threshold</code>是<code>HashMap</code>决定是否执行执行扩容操作的阈值，<code>threshold  = capacity * load factor</code>。</li>
<li><code>loadFactor</code>表示<code>HashMap</code>实际加载因子，通过构造方法传入。若未指定，<code>loadFactor</code>等于<code>DEFAULT_LOAD_FACTOR</code>。</li>
</ul>
<p>需要进一步解释的是<code>loadFactor</code>属性，<code>loadFactor</code>描述了<code>HashMap</code>发生扩容时的填充程度。如果<code>loadFactor</code>设置过大，意味着在<code>HashMap</code>扩容前发生<code>hash</code>冲突的机会越大，因此单链表的长度也就会越长，那么在执行查找操作时，会由于单链表长度过长导致查找的效率降低。如果<code>loadFactor</code>设置过小，那么<code>HashMap</code>的空间利用率会降低，导致<code>HashMap</code>在很多空间都没有被利用的情况下便开始扩容。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>HashMap</code>定义了四个构造方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</div><div class="line">    table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">    init(); <span class="comment">// 在源码中，init方法体不执行任何操作。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</div><div class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</div><div class="line">    putAllForCreate(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用<code>HashMap</code>默认构造方法时，<code>HashMap</code>对象的属性均会被设置为默认值，包括设置加载因子（<code>DEFAULT_LOAD_FACTOR</code>）、扩容阈值（<code>threshold</code>）和<code>table</code>的初始大小。</p>
<p>如果在创建<code>HashMap</code>对象时指定了<code>bucket</code>容量<code>initialCapacity</code>，通过源码我们可以看出在初始化对象时不一定会直接使用<code>initialCapacity</code>，而是选取满足小于等于<code>initialCapacity</code>前提条件下最大的且是<code>2</code>的幂的一个值作为实际<code>bucket</code>的大小。</p>
<p>如果向构造方法传递的参数是一个<code>Map</code>对象<code>m</code>，那么<code>putAllForCreate</code>方法会重新散列<code>m</code>中的每个元素，将它们存入相应的<code>bucket</code>中。<code>putAllForCreate</code>方法及其调用的相关方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</div><div class="line">        putForCreate(e.getKey(), e.getValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>putAllForCreate</code>方法遍历每一个键值对<code>e</code>，通过<code>putForCreat</code>方法将<code>e</code>散列到对应的<code>bucket</code>中。<code>putForCreate</code>方法调用<code>indexFor</code>来确定键值对散列的<code>bucket</code>的位置。<code>indexFor</code>通过<code>h &amp; (length-1)</code>返回<code>bucket</code>的位置，接着遍历对应的单链表来决定是更新操作还是插入操作。</p>
<p>我们需要关注的地方是<code>indexFor</code>为什么通过计算<code>h &amp; (length-1)</code>来获得<code>bucket</code>的位置，而不是通过计算<code>h % length</code>？</p>
<p>实际上，在<code>HashMap</code>中，<code>h &amp; (length-1) == h % length</code>，但是需要一个前提：<code>length</code>必须满足是<code>2</code>的幂。这也正是在解释<code>DEFAULT_INITIAL_CAPACITY</code>和<code>HashMap</code>构造方法时强调的<code>HashMap</code>的<code>bucket</code>容量必须是<code>2</code>的幂。当<code>length</code>是<code>2</code>的幂，那么<code>length</code>的二进制数可以表示为<code>1000...000</code>，因此<code>length - 1</code>的二进制数为<code>0111...111</code>，当<code>h</code>与<code>length - 1</code>位与时，除了<code>h</code>的最高位的被修改为<code>0</code>，其余位均保持不变，这也正是实现了<code>h % length</code>的效果。只是相比于<code>h % length</code>，<code>h &amp; (length-1)</code>的效率会更高。</p>
<p><code>HashMap</code>的<code>bucket</code>容量必须为<code>2</code>的幂的另一个重要原因是一旦满足此条件，那么<code>length</code>即为偶数，<code>length - 1</code>便为奇数，所以<code>length - 1</code>的最后一位必为<code>1</code>。因此，<code>h &amp; (length - 1)</code>得到的值既可能是奇数，也可能是偶数，这确保了散列的均匀性。如果<code>length - 1</code>是偶数，那么<code>h &amp; (length - 1)</code>得到的值必为偶数，那么<code>HashMap</code>的空间便浪费了一半。</p>
<h2 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h2><p>我们分析<code>HashMap</code>使用频率最高的两个方法<code>get</code>方法和<code>put</code>方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<code>HashMap</code>获取<code>get</code>元素时，先计算<code>Key</code>的<code>hash</code>值，定位到数组中对应的<code>bucket</code>，然后开始遍历<code>Entry</code>单链表，直到找到需要的元素，否则返回<code>null</code>。</p>
<p>当我们向<code>HashMap</code>中<code>put</code>新的键值对时，<code>HashMap</code>首先检查<code>Key</code>是否等于<code>null</code>，若为<code>null</code>，则执行<code>putForNullKey</code>方法，<code>putForNullKey</code>方法对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>); <span class="comment">// 不做任何操作</span></div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    modCount++;</div><div class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>Key</code>等于<code>null</code>，那么就将该键值对添加到<code>table[0]</code>的位置，同时，遍历<code>table[0]</code>处的单链表并将链表中所有节点的值都覆盖为新传递进来的键值对的值。因此，该位置永远只有一个值。</p>
<p>如果<code>Key</code>不等于<code>null</code>，那么通过<code>indexFor</code>定位到<code>bucket</code>，然后遍历单链表，如果存在<code>Key</code>相等的键值对，就用新值覆盖旧值，并返回旧值。如果在单链表中没有找到对应的<code>Key</code>，那么调用<code>addEntry</code>方法创建新的<code>Entry</code>节点至单链表（作为头节点）。<code>addEntry</code>及关联方法源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    transfer(newTable);</div><div class="line">    table = newTable;</div><div class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line">    Entry[] src = table;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</div><div class="line">        Entry&lt;K,V&gt; e = src[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            src[j] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">                e.next = newTable[i];</div><div class="line">                newTable[i] = e;</div><div class="line">                e = next;</div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>addEntry</code>把新增键值对插入单链表后，会判断是否需要扩容，即判断当前<code>HashMap</code>的元素的个数是否大于<code>threshold</code>。若需要扩容，那么调用<code>resize</code>方法进行<code>2</code>倍扩容。<code>resize</code>方法会在内部调用<code>transfer</code>方法，<code>transfer</code>方法遍历旧数组及单链表，并将每个键值对重新散列，可以意识到，这整个<code>rehash</code>的开销相当大。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>关于线程安全，我们想要知道的是<code>HashMap</code>在什么情况下会发生线程不安全的情况？实际上，在上文分析<code>put</code>方法时，当<code>HashMap</code>的容量超过了<code>threshold</code>时，便执行<code>resize</code>操作，<code>resize</code>就存在线程不安全的问题。</p>
<p>关于<code>resize</code>哪儿不安全，我推荐左耳朵耗子写的 <a href="http://coolshell.cn/articles/9606.html/" target="_blank" rel="external">疫苗：Java HashMap的死循环</a>，这篇文章图文并茂的解释了在<code>rehash</code>过程中出现线程不安全问题的根源。</p>
<h2 id="HashMap-VS-HashTable"><a href="#HashMap-VS-HashTable" class="headerlink" title="HashMap VS HashTable"></a>HashMap VS HashTable</h2><p><code>HashTable</code>和<code>HashMap</code>底层采用相同的存储结构，在很多方法的实现上二者的思路基本一致。最主要的区别主要有两点。</p>
<ul>
<li><code>HashTable</code>实现了所谓的线程安全，在<code>HashTable</code>很多方法上都加上了<code>synchronized</code>。</li>
<li>在<code>HashMap</code>的分析中，我们发现当我们新增键值对时，<code>HashMap</code>是允许<code>Key</code>和<code>Value</code>均为<code>null</code>。但是<code>HashTable</code>不允许<code>Key</code>或<code>Value</code>为<code>null</code>，关于这一点我们可以通过查看<code>HashTable</code>源码得知。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure the value is not null</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 若value为空则抛出NullPointerException。</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode(); <span class="comment">// 若key为空则抛出NullPointerException。</span></div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            <span class="keyword">return</span> old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap简介&quot;&gt;&lt;a href=&quot;#HashMap简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap简介&quot;&gt;&lt;/a&gt;HashMap简介&lt;/h2&gt;&lt;p&gt;本文针对&lt;code&gt;HashMap&lt;/code&gt;的源码分析基于&lt;code&gt;JDK 7
    
    </summary>
    
    
      <category term="JDK" scheme="http://tinylcy.me/tags/JDK/"/>
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vector源码分析</title>
    <link href="http://tinylcy.me/2016/12/02/Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/12/02/Vector源码分析/</id>
    <published>2016-12-02T13:00:08.000Z</published>
    <updated>2017-04-25T04:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vector简介"><a href="#Vector简介" class="headerlink" title="Vector简介"></a>Vector简介</h2><p><code>Vector</code>在<code>JDK 1.0</code>被引入，基于数组实现，并且是一个动态数组，其容量可以自动增长。在很多方法的实现上，<code>Vector</code>加入了同步语句，因此一般来说<code>Vector</code>是线程安全的，可以在多线程环境中运用。</p>
<p>本文对<code>Vector</code>源码的分析基于<code>JDK 1.8.0_111</code>，并仅对常用的方法进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p><code>Vector</code>类继承自<code>AbstractList</code>，<code>AbstractList</code>是一个抽象类，实现了<code>List</code>接口，<code>AbstractList</code>提供了实现一个<code>List</code>的基本骨架，包括<code>add</code>，<code>remove</code>，<code>get</code>，<code>set</code>，<code>indexOf</code>等方法。<code>Vector</code>实现了<code>RandomAccess</code>接口，因此可以随机访问。实现了<code>Cloneable</code>接口，允许克隆。实现了<code>Serializable</code>接口，可以被序列化。</p>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p><code>Vector</code>内包含<code>3</code>个实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Object[] elementData;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</div></pre></td></tr></table></figure>
<ul>
<li><code>elementData</code>是一个数组，用于存储<code>Vector</code>容器的元素，该数组有一个对应的属性<code>capacity</code>，<code>capacity</code>描述了<code>elementData</code>当前的长度。</li>
<li><code>elementCount</code>描述了<code>elementData</code>内有效元素的个数。</li>
<li><code>capacityIncrement</code>刻画了当要存储的元素的个数大于<code>elementData</code>的<code>capacity</code>时，<code>elementData</code>需要扩容的空间大小，即容器增长系数。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>Vector</code>定义了<code>4</code>个构造方法。</p>
<ul>
<li><p><code>Vector(int initialCapacity, int capacityIncrement);</code></p>
</li>
<li><p><code>Vector(int initialCapacity);</code></p>
</li>
<li><p><code>Vector();</code></p>
</li>
<li><p><code>Vector(Collection&lt;? extends E&gt; c);</code></p>
</li>
</ul>
<p>当我们直接<code>new</code>一个<code>Vector</code>时，即调用<code>Vector</code>的默认构造方法，实际上，<code>Vector</code>的默认构造方法调用<code>this(10)</code>，即调用<code>Vector(int initialCapacity)</code>，并将<code>initialCapacity</code>设置为<code>10</code>，接着<code>Vector(int initialCapacity)</code>再调用<code>this(initialCapacity, 0)</code>，并将<code>capacityIncrement</code>设置为<code>0</code>。从以上我们可以得知，对于一个默认构造的<code>Vector</code>对象，它的默认存储空间可以存储<code>10</code>个元素，且容器增长系统等于<code>0</code>。</p>
<h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><p><code>Vector</code>定义了<code>3</code>个重要的私有方法<code>ensureCapacityHelper(int minCapacity)</code>、<code>void grow(int minCapacity)</code>和<code>int hugeCapacity(int minCapacity)</code>，这<code>3</code>个方法用于实现<code>Vector</code>的自动扩容，<code>Vector</code>中很多涉及到影响<code>Vector</code>元素变化的操作都会直接或者间接的调用这<code>3</code>个方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</div><div class="line">                                     capacityIncrement : oldCapacity);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">    elementData[elementCount++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以关注<code>Vector</code>的<code>add(E e)</code>方法，在往<code>Vector</code>内新增元素前，需要确保存储<code>Vector</code>元素的数组<code>elementData</code>有充足的空间，这一步通过<code>ensureCapacityHelper</code>来实现，<code>ensureCapacityHelper</code>接收<code>elementCount + 1</code>作为参数，确保<code>Vector</code>至少有一个空闲的空间存储新增的元素。当<code>Vector</code>不具备多余的空间时（<code>minCapacity - elementData.length &gt; 0</code>），<code>ensureCapacityHelper</code>就会调用<code>grow</code>方法扩充<code>elementData</code>数组。在扩充数组时，如果<code>capacityIncrement</code>不大于<code>0</code>，那么<code>Vector</code>就会开辟出<code>2</code>倍于原<code>elementData</code>数组长度的空间，并通过<code>Arrays.copyOf</code>将原<code>elementData</code>中的元素拷贝到新地址空间。另外，<code>Vector</code>容量的扩充也是有限制的，从<code>hugeCapacity</code>方法可以看出，<code>Vector</code>的容量最大扩充至<code>Integer.MAX_VALUE</code>。</p>
<p> <code>Vector</code>中定义了大量的用于操作容器的方法，其中绝大多数设计到改变容器大小的方法都是在底层做两件事，一是开辟新的存储空间（如果有必要），二是进行数组的拷贝。这些方法理解起来并不难，此处不再赘述。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在很多面试环节中，经常被问到的问题是<em><code>ArrayList</code>和<code>Vector</code>的区别是什么？</em>关于这个问题，最频繁的回答可能是<em><code>Vector</code>是线程安全的，而<code>ArrayList</code>是非线程安全的</em>。这样回答的原因是在<code>Vector</code>的方法中，几乎所有的操作容器的方法上都加了<code>synchronized</code>，这意味着访问这些方法前都需要获得对象的锁。因此，这些方法不会被多个线程同时访问，从而实现线程安全。</p>
<p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a>一书中提到：如果只是将每个方法都作为同步方法（比如<code>Vector</code>，简单的在方法前加上<code>synchronized</code>），那么并不足以确保复合操作是原子的，以<code>Vector</code>为例，观察如下代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!vector.contains(element)) &#123;</div><div class="line">    vector.add(element);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个经典的<code>put-if-else</code>问题，虽然通过<code>synchronized</code>已确保<code>contains</code>方法和<code>add</code>方法都是原子的，但是如果把多个操作合并为一个复合操作，仍旧需要额外的加锁机制。否则，多线程环境下，在<code>contains</code>方法和<code>add</code>方法的执行间隙期间完全有可能经历一个线程获取<code>contains</code>上的锁，执行完<code>contains</code>方法后释放锁，然后锁又被另一线程获取，并执行了<code>add</code>方法，然后释放锁，锁又被原来执行<code>contains</code>方法的线程获取，然后执行<code>add</code>方法，此时，该线程可能已经基于一个错误的假设在执行<code>add</code>方法了（<code>Vector</code>内可能已经存在该线程即将要<code>add</code>的元素了）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vector简介&quot;&gt;&lt;a href=&quot;#Vector简介&quot; class=&quot;headerlink&quot; title=&quot;Vector简介&quot;&gt;&lt;/a&gt;Vector简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;在&lt;code&gt;JDK 1.0&lt;/code&gt;被引入，基于
    
    </summary>
    
    
      <category term="JDK" scheme="http://tinylcy.me/tags/JDK/"/>
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java对象内存布局</title>
    <link href="http://tinylcy.me/2016/11/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://tinylcy.me/2016/11/30/Java对象内存布局/</id>
    <published>2016-11-30T10:58:18.000Z</published>
    <updated>2017-04-25T04:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>JVM</code>将内存划分为程序计数器（<code>Program Counter Register</code>）、虚拟机栈（<code>VM Stack</code>）、本地方法栈（<code>Native Method Stack</code>）、堆（<code>Heap</code>）以及方法区（<code>Method Area</code>）。作为开发者，我们最关注的是虚拟机栈以及堆这两块区域。虚拟机栈所需要的内存空间在编译期间即可明确，而堆内存所需要的空间需要在运行时才可确定。堆内存用于存放我们在程序中创建的对象，一旦没有足够的空间用于存放这些对象，即会抛出<code>OutOfMemoryError</code>异常。在这种情况下，我们可以调整堆内存的大小，或者对程序进行优化。当我们采用后一种方式时，我们需要了解一个对象是如何占据堆内存空间的，或者说是了解一个对象是由哪些部分组成的。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在<code>HotSpot</code>虚拟机中，对象在内存中的布局划分为<code>3</code>个区域：对象头（<code>Header</code>），实例数据（<code>Instance Data</code>）以及对齐填充（<code>Padding</code>）。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><code>HotSpot</code>虚拟机对象的对象头一般包含两部分信息，第一部分用于存储对象自身的运行时数据，例如<code>HashCode</code>、<code>GC</code>分代年龄等信息。在<code>32</code>位和<code>64</code>位的<code>JVM</code>中，这部分数据分别为<code>32bit</code>和<code>64bit</code>，官方称这部分数据为<code>Mark Word</code>。</p>
<p>另一部分用于存储对象的类型指针，该指针指向它的类元数据，<code>JVM</code>通过这个指针确定对象是哪个类的实例。在<code>32</code>位<code>JVM</code>中，指针的长度为<code>32bit</code>，在未开启压缩指针的<code>64</code>位<code>JVM</code>中，该指针的长度为<code>64bit</code>，如果开启压缩指针，那么为<code>32bit</code>。</p>
<p>之前提到对象头一般包含两部分信息，这是因为如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，并且这部分数据也随着<code>JVM</code>位数的不同而不同：<code>32</code>位的<code>JVM</code>上，该区域的长度为<code>32bit</code>，在<code>64</code>位未开启压缩指针的<code>JVM</code>中，这部分数据的长度为<code>64bit</code>，否则为<code>32bit</code>。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储有效信息的区域，存储了代码中定义的各种字段的内容，包括从父类继承下来的字段和子类中定义的字段。</p>
<p>实例数据紧随对象头，为了提高存储空间的利用率，这部分数据的存储顺序会受到虚拟机分配策略参数和字段在<code>Java</code>源码中定义顺序的影响。<code>HotSpot</code>虚拟机默认的分配策略如下所示。</p>
<ul>
<li><code>doubles &amp; longs</code></li>
<li><code>ints &amp; floats</code></li>
<li><code>shorts &amp; chars</code></li>
<li><code>booleans &amp; bytes</code></li>
<li><code>references</code></li>
</ul>
<p>可以看出，相同宽度的字段总是被分配到一起，并且在满足这个条件的前提下，在父类中定义的字段会出现在子类字段之前。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充这部分不是必须存在的，这部分仅仅是起着占位符的作用。由于<code>HotSpot</code>虚拟机的自动内存管理系统要求对象的起始地址必须是<code>8</code>字节的整数倍，因此当对象实例部分数据没有对齐时，就需要对剩余的部分进行填充。</p>
<h2 id="度量工具"><a href="#度量工具" class="headerlink" title="度量工具"></a>度量工具</h2><p>从<code>JDK 5</code>开始， <code>Java</code>提供了<code>Instrumentation API</code>，通过<code>getObjectSize</code>方法来获取对象的大小，但是<code>getObjectSize</code>方法存在如下两个缺陷，不能准确的计算对象的大小。</p>
<ul>
<li>不能直接调用<code>getObjectSize</code>方法，而是需要通过<code>-javaagent</code>参数指定一个特定的<code>jar</code>文件（包含<code>Instrumentation</code>代理）来启动<code>Instrumentation</code>的代理程序。</li>
<li>如果一个对象中包含别的对象的引用，那么<code>getObjectSize</code>方法仅仅计算引用的大小，而不包括引用所指向的对象的大小。</li>
</ul>
<p>由于上述两个缺陷，我们不能直接调用<code>getObjectSize</code>方法来计算对象的大小，但是利用<code>Java</code>的反射机制，我们可以完整的计算一个对象的大小。我们解析对象的每一个<code>Field</code>（使用<code>getDeclaredFields</code>），并遵从如下规则。</p>
<ul>
<li>当<code>Field</code>是基本数据类型时，我们不再计算该<code>Field</code>的大小，因为该<code>Field</code>的大小已经被包含在<code>getObjectSize</code>方法的返回值中。</li>
<li>当<code>Field</code>是静态数据或者是常量池中包含的数据，那么我们忽略这些数据，因为这些数据并不是属于对象的。</li>
<li>我们需要保存我们已经计算过的对象的引用，防止重复计算。 </li>
<li>如果对象所属的类存在父类，还需要计算父类中成员变量的大小。</li>
</ul>
<p><a href="https://github.com/tinylcy/jvm-obj-size" target="_blank" rel="external">jvm-obj-size</a> 是以上思想的具体实现，<a href="https://github.com/tinylcy/jvm-obj-size" target="_blank" rel="external">jvm-obj-size</a> 实现了基本的获取对象本身的大小（<code>sizeOf</code>，仅包含引用本身），以及获取对象真正的大小（<code>fullSizeOf</code>，包含引用所指向的对象）的方法，具体用法以及测试代码详见<code>README</code>文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></li>
<li><a href="http://www.jroller.com/maxim/entry/again_about_determining_size_of" target="_blank" rel="external">Again about determining size of Java object</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="external">Java SE 6 新特性: Instrumentation 新功能</a></li>
<li><a href="http://blog.csdn.net/u013256816/article/details/51008443" target="_blank" rel="external">Java对象大小内幕浅析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JVM&lt;/code&gt;将内存划分为程序计数器（&lt;code&gt;Program Counter Register&lt;/code&gt;）、虚拟机栈（&lt;code&gt;VM Stack&lt;/code&gt;）、本地方法栈（&lt;code&gt;Native Method Stack&lt;/code&gt;）、堆（
    
    </summary>
    
    
      <category term="JVM" scheme="http://tinylcy.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux C 线程池实现</title>
    <link href="http://tinylcy.me/2016/11/17/Linux-C-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tinylcy.me/2016/11/17/Linux-C-线程池实现/</id>
    <published>2016-11-17T09:15:35.000Z</published>
    <updated>2017-04-25T04:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习网络编程时，自己动手实现一个<code>Web Server</code>是一个很有意思的经历。大多数<code>Web Server</code>都有一个特点：在单位时间内需要处理大量的请求，并且处理这些请求的时间往往还很短。《深入理解计算机系统》 (<code>CSAPP</code>) 在讲解网络编程时实现了一个经典的<code>Web Server</code>，这个<code>Web Server</code>不仅满足了静态请求，同时还满足了动态请求 (<code>CGI</code>)。虽然这个<code>Web Server</code>能够正常使用，但是仍存在一个明显的缺陷：它是一个迭代式的<code>Web Server</code>，这意味着在一个请求处理完毕前，不能同时处理另一个请求，而我们之前提到<code>Web Server</code>的一个重要特点就是在单位时间内可能会有大量的请求，所以如果投入工业界，这种情况自然是无法容忍的。</p>
<h2 id="多进程-Web-Server-模型"><a href="#多进程-Web-Server-模型" class="headerlink" title="多进程 Web Server 模型"></a>多进程 Web Server 模型</h2><p>解决上面提到的<code>Web Server</code>只能一个接着一个处理请求的第一个方案是：当<code>accept</code>到一个请求时，<code>fork</code>一个子进程去处理这个请求，而主进程仍然在监听是否有新的连接请求。多进程模型在表面上看似乎解决了问题，但是我们都知道<code>fork</code>一个进程的开销是非常大的，基于以下几个事实。</p>
<ul>
<li><p>从概念上说，可以将<code>fork</code>认作对父进程程序段、数据段、堆段以及栈段创建拷贝。但是如果真的只是简单的将父进程虚拟内存页拷贝到子进程，那就太浪费了。现代<code>UNIX</code>(<code>Linux</code>) 在实现<code>fork</code>时往往会采用两种技术来避免这种浪费。一是内核将每一进程的代码段标记为只读，从而使得父进程和子进程都无法修改代码段。这样，父进程和子进程可以共共享同一代码段。二是对于父进程数据段、堆段和栈段中的各页，内核采用写时复制(<code>copy-on-write</code>) 的方式，这么做的原因之一是：<code>fork</code>之后常常伴随着<code>exec</code>，这会用新程序替换进程的代码段，并重新初始化其数据段、堆段和栈段。但是无论如何，仍存在复制页表的操作，这也是为什么在<code>UNIX</code>(<code>Linux</code>) 下创建进程要比创建线程开销大的原因。</p>
</li>
<li><p>并发量一大，此时系统内便会有存在大量的进程，这会导致<code>CPU</code>花费大量的时间在进程调度上，并且进程上下文的切换开销也很大。</p>
</li>
</ul>
<p>因此，相比于多进程模型，多线程是一个更优的模型：创建线程要快于创建进程，线程间的上下文切换消耗的时间一般也比进程要短。</p>
<h2 id="多线程-Web-Server-模型"><a href="#多线程-Web-Server-模型" class="headerlink" title="多线程 Web Server 模型"></a>多线程 Web Server 模型</h2><p> 换用多线程<code>Web Server</code>模型：每<code>accept</code>一个请求，创建一个线程，将请求交由该线程处理。换用多线程模型可以解决由<code>fork</code>带来的开销问题，但是调度问题依然还是存在的。因此，一个显而易见的解决办法是使用线程池，将线程的数量固定下来。基本的实现思路如下。</p>
<ul>
<li><p>将每个请求封装为一个<code>Job</code>，每个<code>Job</code>包含线程要执行的方法、传递给线程的参数以及用于描述该<code>Job</code>处于<code>Job</code>队列的位置的参数。</p>
</li>
<li><p>线程池维护着一个<code>Job</code>队列，每个线程从<code>Job</code>队列中取下一个<code>Job</code>执行。因为该<code>Job</code>队列是一个共享资源，因此需要控制线程的同步。</p>
</li>
<li><p>初始化线程池时，马上创建一定数量的线程。此时，这些线程都是阻塞状态的，因为<code>Job</code>队列为空。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://github.com/tinylcy/tinyhttpd" target="_blank" rel="external">tinyhttpd</a>是我为了更有效的学习网络编程而实现的一个轻量级的<code>Web Server</code>，目前仍有部分问题需要解决以及优化。按照上面的思路，我实现了一个简单的线程池，并将其引入到<a href="https://github.com/tinylcy/tinyhttpd" target="_blank" rel="external">tinyhttpd</a>中。具体的代码实现请参考<a href="https://github.com/tinylcy/tinyhttpd/blob/master/threadpool.h" target="_blank" rel="external">threadpool.h</a>和<a href="https://github.com/tinylcy/tinyhttpd/blob/master/threadpool.c" target="_blank" rel="external">threadpool.c</a>。</p>
<h2 id="剩余问题"><a href="#剩余问题" class="headerlink" title="剩余问题"></a>剩余问题</h2><p>当固定了线程池的线程数量后，仍然存在一个严重的问题：实际情况下，很多连接都是长连接，这意味着一个线程在处理一个请求时，<code>read</code>到的数据将会是是不连续的。当线程处理完一批数据后，如果继续<code>read</code>，而下一批数据还未到来时，由于默认情况下<code>file descriptor</code>是<code>blocking</code>的，因此该线程就会进入阻塞状态。所以，如果线程池中所有的线程都处于阻塞状态，此时如果有新的请求到来，那么是无法处理的。</p>
<p>解决方案是将<code>file descriptor</code>设置为<code>non-blocking</code>，利用事件驱动(<code>Event-driven</code>)来处理连接。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://book.douban.com/subject/25809330/" target="_blank" rel="external">Linux/UNIX系统编程手册</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统</a></p>
</li>
<li><p><a href="https://github.com/zyearn/zaver" target="_blank" rel="external">zaver</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习网络编程时，自己动手实现一个&lt;code&gt;Web Server&lt;/code&gt;是一个很有意思的经历。大多数&lt;code&gt;Web Server&lt;/code&gt;都有一个特点：在单位时间内需要处理大量的请求，并且处理这些请求的时间往往还很短。《深入理解计算机系统》 (&lt;code&gt;CS
    
    </summary>
    
    
      <category term="Unix/Linux" scheme="http://tinylcy.me/tags/Unix-Linux/"/>
    
      <category term="C" scheme="http://tinylcy.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型总结</title>
    <link href="http://tinylcy.me/2016/10/03/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://tinylcy.me/2016/10/03/Java泛型总结/</id>
    <published>2016-10-03T13:51:39.000Z</published>
    <updated>2017-04-25T04:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code>泛型是<code>JDK5</code>引入的一个新特性，允许在定义类和接口的时候使用类型参数（<code>type parameter</code>）。声明的类型参数在使用的时候使用具体的类型来替换。泛型最主要的应用是在<code>JDK5</code>中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面上说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。从不好的方面说，为了保证与旧版本的兼容性，<code>Java</code>泛型的实现上还存在着不够优雅的地方。</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>正确理解泛型概念的首要前提是理解类型擦除（<code>type erasure</code>）。<code>Java</code>中的泛型基本上都是在编译器这个层次来实现的。在生成的<code>Java</code>字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。比如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成<code>List</code>。<code>JVM</code>看到的只是<code>List</code>，而由泛型附加的类型信息对<code>JVM</code>来说是不可见的。<code>Java</code>编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</p>
<p>通过如下代码片段感受类型擦除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;Integer&gt; a2 =<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">Class c1 =a1.getClass();</div><div class="line">Class c2 = a2.getClass();</div><div class="line"></div><div class="line">System.out.println(c1.equals(c2));    <span class="comment">//Output: true</span></div></pre></td></tr></table></figure>
<p>此时，程序输出<code>true</code>，这就是类型擦除造成的。因为不管是<code>ArrayList&lt;String&gt;</code>还是<code>ArrayList&lt;Integer&gt;</code>，都会在编译期被编译器擦除成<code>ArrayList</code>。编译器这么做的原因归根结底还是为了兼容<code>JDK5</code>前未使用泛型的代码，因此不得不让编译器擦除有关类型信息的部分，这样生成的代码其实就是类型无关的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">System.out.println(Arrays.toString(list.getClass().getTypeParameters()));    <span class="comment">//[E]</span></div><div class="line">System.out.println(Arrays.toString(map.getClass().getTypeParameters()));    <span class="comment">//[K, V]</span></div></pre></td></tr></table></figure>
<p>我们期望的是返回泛型参数的类型，结果返回的仅仅是参数的占位符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] makeArray()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T[<span class="number">10</span>];    <span class="comment">//编译期报错：不能创建泛型类型的数组</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为<code>T</code>仅仅是个占位符，并不具有真实的类型信息。为了解决这个问题，可以利用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] makeArray(Class&lt;T&gt; clazz) &#123;</div><div class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(clazz, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多泛型的奇怪特性都与类型擦除的存在有关，包括：</p>
<ul>
<li><p>泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</p>
</li>
<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是<code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</p>
</li>
<li><p>泛型的类型参数不能用在<code>Java</code>异常处理的<code>catch</code>语句中。因为异常处理是由<code>JVM</code>在运行时刻来进行的。由于类型信息被擦除，<code>JVM</code>是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于<code>JVM</code>来说，它们都是<code>MyException</code>类型的，也就无法执行与异常对应的<code>catch</code>语句。</p>
</li>
</ul>
<p>当执行类型擦除时，首先是找到用来替换类型参数的具体类。这个具体类一般是<code>Object</code>。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>的内容。比如<code>T get()</code>方法声明就变成了<code>Object get()</code>；<code>List&lt;String&gt;</code>就变成了<code>List</code>。接下来就可能需要生成一些桥接方法（<code>bridge method</code>），这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当类型信息被擦除之后，上述类的声明变成了<code>class MyString implements Comparable</code>。但是这样类<code>MyString</code>就会有编译错误，因为没有实现接口<code>Comparable</code>声明的<code>compareTo(Object)</code>方法。这个时候就由编译器来动态生成这个方法。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>了解类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>为例来具体分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspect</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(Object obj : list) &#123;</div><div class="line">		System.out.println(obj);</div><div class="line">	&#125;</div><div class="line">	list.add(<span class="number">1</span>);    <span class="comment">//这个操作在当前方法的上下文是合法的</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">	List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	inspect(strs);    <span class="comment">//编译错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中，<code>inspect</code>方法接受<code>List&lt;Object&gt;</code>作为参数，当在<code>test</code>方法中试图传入<code>List&lt;String&gt;</code>的时候，会出现编译错误。假设这样的做法是允许的，那么在<code>inspect</code>方法中就可以通过<code>list.add(1)</code>来向集合中添加一个数字。这样在<code>test</code>方法看来，其声明为<code>List&lt;String&gt;</code>的集合中被添加了一个<code>Integer</code>类型的对象，这显然是违反类型安全原则的，在某个时候肯定会抛出<code>ClassCastException</code>。因此，编译器禁止这样的行为。</p>
<h2 id="通配符与上下界"><a href="#通配符与上下界" class="headerlink" title="通配符与上下界"></a>通配符与上下界</h2><p>在使用泛型类的时候，既可以指定一个具体的类型，如<code>List&lt;String&gt;</code>就声明了具体的类型是<code>String</code>；也可以用通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就声明了<code>List</code>中包含的元素类型是未知的。通配符所代表的其实是一组类型，但具体的类型是未知的。<code>List&lt;?&gt;</code>所声明的就是所有的类型都是可以的。但是<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。<code>List&lt;Object&gt;</code>实际上确定了<code>List</code>中包含的是<code>Object</code>及其子类，在使用的时候可以通过<code>Object</code>来进行引用。而<code>List&lt;?&gt;</code>则表示其中所包含的元素类型是不确定。其中可能包含的是<code>String</code>，也可能是<code>Integer</code>。如果它包含了<code>String</code>的话，往里面添加<code>Integer</code>类型的元素就是错误的。正因为类型未知，就不能通过<code>new ArrayList&lt;?&gt;()</code>的方法来创建一个新的<code>ArrayList</code>对象。因为编译器无法知道具体的类型是什么。但是对于<code>List&lt;?&gt;</code>中的元素总是可以用<code>Object</code>来引用的，因为虽然类型未知，但肯定是<code>Object</code>及其子类。考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wildcard</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</div><div class="line">	list.add(<span class="number">1</span>);    <span class="comment">//编译错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。</p>
<p>因为对于<code>List&lt;?&gt;</code>中的元素只能用<code>Object</code>来引用，在有些情况下不是很方便。在这些情况下，可以使用上下界来限制未知类型的范围。如<code>List&lt;? extends Number&gt;</code>说明<code>List</code>中包含的是<code>Number</code>及其子类。而<code>List&lt;? super Number&gt;</code>则说明<code>List</code>中包含的是<code>Number</code>及其父类。当引入了上界时候，在使用类型的时候就可以使用上界类中定义的方法。比如访问<code>List&lt;? extends Number&gt;</code>的时候，就可以使用<code>Number</code>类的<code>intValue</code>等方法。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>在<code>Java</code>中，比较常见的是通过继承机制而产生的类型体系结构。比如<code>String</code>继承自<code>Object</code>。根据<a href="https://zh.wikipedia.org/wiki/里氏替换原则" target="_blank" rel="external">Liskov替换原则</a>，子类是可以替换父类的。当需要<code>Object</code>类的引用的时候，如果传入一个<code>String</code>对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用时，就需要进行强制类型转换。编译器并不能保证运行时刻的这种转换一定是合法的。这种自动的子类替换父类的转换机制，对于数组也是适用的。<code>String[]</code>可以替换<code>Object[]</code>。但是泛型的引入，对于这个类型系统产生了一定的影响。例如<code>List&lt;String&gt;</code>是不能替换<code>List&lt;Object&gt;</code>的。</p>
<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数<code>String</code>继承自<code>Object</code>。而第二种指的是<code>List</code>接口继承自<code>Collection</code>接口。对于这个类型系统，有如下的一些规则：</p>
<ul>
<li><p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。</p>
</li>
<li><p>当泛型类的类型声明中使用了通配符的时候，其子类可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在<code>Collection</code>这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在<code>Number</code>这个维度展开，即<code>Collection&lt;Double&gt;</code>和<code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和<code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。</p>
</li>
<li><p>如果泛型类中包含多个类型参数，则对每个类型参数分别应用上面的规则。</p>
</li>
</ul>
<p>因此，对于上面错误的代码，只需要将<code>List&lt;Object&gt;</code>修正为<code>List&lt;?&gt;</code>即可。<code>List&lt;String&gt;</code>是<code>List&lt;?&gt;</code>的子类型。</p>
<h2 id="开发自己的泛型类"><a href="#开发自己的泛型类" class="headerlink" title="开发自己的泛型类"></a>开发自己的泛型类</h2><p>泛型类与一般的<code>Java</code>类基本相同，只是在类和接口定义上多出来了用<code>&lt;&gt;</code>声明的类型参数。一个类可以有多个类型参数，比如<code>MyClass&lt;X, Y, Z&gt;</code>。每个类型参数在声明的时候可以指定上下界。所声明的类型参数在<code>Java</code>类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。由于类型擦除机制，类型参数并不能用来创建对象或是作为静态变量的类型。考虑下面的泛型类中的正确和错误的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span>&lt;<span class="title">X</span> <span class="keyword">extends</span> <span class="title">Number</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> X x;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Y y;    <span class="comment">//编译错误，不能用在静态变量中</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> X <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> x;    <span class="comment">//正确用法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</div><div class="line">		Z z = <span class="keyword">new</span> Z();    <span class="comment">//编译错误，不能查创建对象</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设允许类型参数声明为静态属性，那么如下代码将会非常混乱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(T os)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.os = os;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> os;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</div><div class="line">        Computer&lt;Linux&gt; c1 = <span class="keyword">new</span> Computer&lt;&gt;();</div><div class="line">        Computer&lt;MacOS&gt; c2 = <span class="keyword">new</span> Computer&lt;&gt;();</div><div class="line">        Computer&lt;Windows&gt; c3 = <span class="keyword">new</span> Computer&lt;&gt;();</div><div class="line"></div><div class="line">        System.out.println(c1.getOS());</div><div class="line">        System.out.println(c2.getOS());</div><div class="line">        System.out.println(c3.getOS());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为<code>os</code>为<code>Computer</code>类的静态属性，所以<code>c1</code>，<code>c2</code>，<code>c3</code>这<code>3</code>个<code>Computer</code>实例共享这个属性，那么此时<code>os</code>的类型是什么？因此，不允许声明静态的类型参数属性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用<code>Java</code>泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>
<ul>
<li><p>在代码中避免泛型类和原始类型的混用。比如<code>List&lt;String&gt;</code>和<code>List</code>不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。</p>
</li>
<li><p>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</p>
</li>
<li><p>泛型类最好不要同数组一块儿使用。只能创建<code>new List&lt;?&gt;[10]</code>这样的数组，无法创建<code>new List&lt;String&gt;[10]</code>这样的。这限制了数组的使用能力，而且会带来很多费解的问题。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="external">InfoQ</a></li>
<li><a href="http://findingsea.github.io/2015/10/09/java-generic-type-erasure/" target="_blank" rel="external">Java泛型：类型擦除</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt;泛型是&lt;code&gt;JDK5&lt;/code&gt;引入的一个新特性，允许在定义类和接口的时候使用类型参数（&lt;code&gt;type parameter&lt;/code&gt;）。声明的类型参数在使用的时候使用具体的类型来替换。泛型最主要的应用是在&lt;code&gt;JDK
    
    </summary>
    
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>I/O重定向和管道</title>
    <link href="http://tinylcy.me/2016/08/19/IO%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93/"/>
    <id>http://tinylcy.me/2016/08/19/IO重定向和管道/</id>
    <published>2016-08-18T16:01:24.000Z</published>
    <updated>2017-04-25T04:47:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准I-O与重定向的若干概念"><a href="#标准I-O与重定向的若干概念" class="headerlink" title="标准I/O与重定向的若干概念"></a>标准I/O与重定向的若干概念</h2><h3 id="3个标准文件描述符"><a href="#3个标准文件描述符" class="headerlink" title="3个标准文件描述符"></a>3个标准文件描述符</h3><p>所有的<code>Unix</code>工具都使用文件描述符<code>0</code>、<code>1</code>和<code>2</code>。如下图所示，标准输入文件的描述符是<code>0</code>，标准输出的文件描述符是<code>1</code>，标准错误输出的文件描述符则是<code>2</code>。<code>Unix</code>假设文件描述符<code>0</code>、<code>1</code>和<code>2</code>都已经被打开，可以分别进行读、写和写的操作。</p>
<p><img src="/img/2016-08-18-Image 1.png" alt="Alt text"></p>
<h3 id="重定向I-O的是shell而不是程序"><a href="#重定向I-O的是shell而不是程序" class="headerlink" title="重定向I/O的是shell而不是程序"></a>重定向I/O的是shell而不是程序</h3><p>通过使用输出重定向标志，命令<code>cmd&gt;filename</code>告诉<code>shell</code>将文件描述符1定位到文件。于是<code>shell</code>就将文件描述符与指定的文件连接起来。程序持续不断地将数据写到文件描述符<code>1</code>中，根本没有意识到数据的目的地已经改变了。<code>listargs.c</code>展示了程序甚至没有看到命令行中的重定向符号。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span>* av[])</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Number of args: %d, Args are: \n"</span>, ac);</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ac; i++) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"args[%d] %s\n"</span>, i, av[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This message is sent to stderr.\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序<code>listargs</code>将命令行参数打印到标准输出。注意<code>listargs</code>并没有打印出重定向符号和文件名。</p>
<p><img src="/img/2016-08-18-Image 2.png" alt="Alt text"></p>
<p>如上图所示验证了关于<code>shell</code>输出重定向的一些重要概念。</p>
<ul>
<li><code>shell</code>并不将重定向标记和文件名传递给程序。</li>
<li>重定向可以出现在命令行中的任何地方，并且在重定向标识符周围并不需要空格来区分。例如上图命令<code>./listargs testing &gt;xyz one two 2&gt;oops</code>也可以写成<code>./listargs &gt;xyz testing one two 2&gt;oops</code>，如下图所示。</li>
</ul>
<p><img src="/img/2016-08-18-Image 3.png" alt="Alt text"></p>
<h3 id="最低可用文件描述符原则"><a href="#最低可用文件描述符原则" class="headerlink" title="最低可用文件描述符原则"></a>最低可用文件描述符原则</h3><p>文件描述符是一个数组的索引号。每个进程都有其打开的一组文件，这些打开的文件被保持在一个数组中。文件描述符即为某文件在此数组中的索引。并且，当打开文件时，为此文件安排的文件描述符总是此数组中最低可用位置的索引。</p>
<h2 id="将stdin重定向到文件"><a href="#将stdin重定向到文件" class="headerlink" title="将stdin重定向到文件"></a>将stdin重定向到文件</h2><p>考虑如何将标准输入重定向以至可以从文件中读取数据。更加精确的说，进程并不是从文件读数据，而是从文件描述符读取数据。如果将文件描述符<code>0</code>重定向到一个文件，那么此文件就成为标准输入的源。</p>
<h3 id="方法1：close-then-open"><a href="#方法1：close-then-open" class="headerlink" title="方法1：close-then-open"></a>方法1：close-then-open</h3><p>第一种放方法是<code>close-then-open</code>策略，具体步骤如下：</p>
<ul>
<li>开始时，系统中采用的是典型的设置，即三种标准流是被连接到终端设备上的。输入的数据流经过文件描述符<code>0</code>而输出的流经过文件描述符<code>1</code>和<code>2</code>。</li>
<li>接下来，调用<code>close(0)</code>，将标准输入与终端设备的连接切断。</li>
<li>最后，使用<code>open(filename, O_RDONLY)</code>打开一个想连接到<code>stdin</code>上的文件。当前的最低可用文件描述符是<code>0</code>，因此所打开的文件将被连接到标准输入上。任何从标准输入读取数据的函数都将从此文件中读取数据。</li>
</ul>
<h3 id="方法2：open-close-dup-close"><a href="#方法2：open-close-dup-close" class="headerlink" title="方法2：open-close-dup-close"></a>方法2：open-close-dup-close</h3><p><code>Unix</code>系统调用<code>dup</code>建立指向已经存在的文件描述符的第二个连接，这种方法需要<code>4</code>个步骤。</p>
<ul>
<li><code>open(file)</code>，打开<code>stdin</code>将要重定向的文件。这个调用返回一个文件描述符<code>fd</code>，这个描述符并不是<code>0</code>，因为<code>0</code>在当前已经被打开了。</li>
<li><code>close(0)</code>，将文件描述符<code>0</code>关闭，现在文件描述符<code>0</code>已经空闲了。</li>
<li><code>dup(fd)</code>，系统调用<code>dup(fd)</code>将文件描述符<code>fd</code>做了一个复制。此处复制使用最低可用的文件描述符号。因此获得的文件描述符是<code>0</code>。这样，就将磁盘文件与文件描述符<code>0</code>连接在一起了。</li>
<li><code>close(fd)</code>，使用<code>close(fd)</code>来关闭原始连接，只留下文件描述符<code>0</code>的连接。</li>
</ul>
<p><code>dup</code>在学习管道的时候非常重要，一个简单一点的方案是将<code>close(0)和dup(fd)</code>结合在一起作为一个单独的系统调用<code>dup2</code>。</p>
<h2 id="重定向I-O：who-gt-userlist"><a href="#重定向I-O：who-gt-userlist" class="headerlink" title="重定向I/O：who&gt;userlist"></a>重定向I/O：who&gt;userlist</h2><p>当输入<code>who&gt;userlist</code>时，<code>shell</code>运行<code>who</code>程序，并将<code>who</code>的标准输出重定向到名为<code>userlist</code>的文件上。<code>shell</code>实现该重定向的关键之处在于<code>fork</code>和<code>exec</code>之间的时间间隙。在<code>fork</code>执行完后，子进程仍然在运行父进程也就是<code>shell</code>程序，并准备执行<code>exec</code>。<code>exec</code>将替换进程中运行的程序，但是它不会改变进程的属性和进程中所有的连接。也就是说，在运行<code>exec</code>之后，进程的用户<code>ID</code>不会改变，其优先级也不会改变，并且其文件描述符也和运行<code>exec</code>之前一样。因此，利用这个原则来实现重定向标准输出。</p>
<p>此时<code>who</code>就是子进程要执行的命令，当执行<code>fork</code>前，父进程的文件描述符<code>1</code>指向终端。当执行<code>fork</code>之后，子进程的文件描述符也喜欢指向终端，此时，子进程尝试执行<code>close(1)</code>，<code>close(1)</code>之后，文件描述符<code>1</code>成为最低未用文件描述符，子进程现在再执行<code>creat(userlist, mode)</code>打开文件<code>userlist</code>，文件描述符<code>1</code>被连接到文件<code>userlist</code>。因此，子进程的标准输出被重定向到文件<code>userlist</code>，子进程然后调用<code>exec</code>执行<code>who</code>。</p>
<p>子进程执行了<code>who</code>程序，于是子进程中的代码和数据都被<code>who</code>程序的代码和数据所替换了，然而文件描述符被保留下来。因为打开的文件并非是程序的代码也不是数据，它们属于进程的属性，因此<code>exec</code>调用并不改变它们。</p>
<h2 id="管道编程"><a href="#管道编程" class="headerlink" title="管道编程"></a>管道编程</h2><p>管道是内核中一个单向的数据通道，管道有一个读取端和一个写入端，可以用来连接一个进程的输出和另一个进程的输入。</p>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>使用系统调用<code>result = pipe(int array[2])</code>来创建管道，并将其两端连接到两个文件描述符。如下图所示，<code>array[0]</code>为读取数据端的文件描述符，而<code>array[1]</code>则为写数据端的文件描述符。类似与<code>open</code>调用，<code>pipe</code>调用也使用最低可用文件描述符。</p>
<p><img src="/img/2016-08-18-Image 4.png" alt="Alt text"></p>
<p>程序<code>pipedemo.c</code>展示了如何创建管道并使用管道向自己发送数据。核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> len, i, apipe[<span class="number">2</span>];</div><div class="line"><span class="keyword">char</span> buf[BUFSIZ];</div><div class="line"></div><div class="line"><span class="keyword">if</span>(pipe(apipe) == <span class="number">-1</span>) &#123;</div><div class="line">	perror(<span class="string">"could not make pipe."</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"Got a pipe! It is file descriptors: &#123;%d %d&#125;\n"</span>, apipe[<span class="number">0</span>], apipe[<span class="number">1</span>]);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(fgets(buf, BUFSIZ, <span class="built_in">stdin</span>)) &#123;</div><div class="line">	len = <span class="built_in">strlen</span>(buf);</div><div class="line">	<span class="keyword">if</span>(write(apipe[<span class="number">1</span>], buf, len) != len) &#123;</div><div class="line">		perror(<span class="string">"writing to pipe."</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">		buf[i] = <span class="string">'X'</span>;</div><div class="line">	&#125;</div><div class="line">	len = read(apipe[<span class="number">0</span>], buf, BUFSIZ);</div><div class="line">	<span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</div><div class="line">		perror(<span class="string">"reading from pipe."</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(write(<span class="number">1</span>, buf, len) != len) &#123;</div><div class="line">		perror(<span class="string">"writing to stdout"</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据流从键盘到进程，从进程到管道，再从管道到进程以及从进程回到终端。</p>
<h3 id="使用fork来共享管道"><a href="#使用fork来共享管道" class="headerlink" title="使用fork来共享管道"></a>使用fork来共享管道</h3><p>当进程创建一个管道之后，该进程就有了连向管道两端的连接。当这个进程调用<code>fork</code>的时候，它的子进程也得到了这两个连向管道的连接。父进程和子进程都可以将数据写到管道的写数据端口，并从读数据端口将数据读出。但是当一个进程读，而另一个进程写的时候，管道的使用效率是最高的。程序<code>pipedemo2.c</code>说明了如何将<code>pipe</code>和<code>fork</code>结合起来，创建一对通过管道来通信的进程，核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">char</span> buf[BUFSIZ];</div><div class="line"><span class="keyword">int</span> read_len;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>) &#123;</div><div class="line">	oops(<span class="string">"cannot get a pipe"</span>, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span>(fork()) &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</div><div class="line">		oops(<span class="string">"cannot fork"</span>, <span class="number">2</span>);</div><div class="line">	<span class="comment">/*子进程*/</span></div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">		len = <span class="built_in">strlen</span>(CHILD_MESS);</div><div class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(write(pipefd[<span class="number">1</span>], CHILD_MESS, len) != len) &#123;</div><div class="line">				oops(<span class="string">"write"</span>, <span class="number">3</span>);</div><div class="line">			&#125;</div><div class="line">			sleep(<span class="number">5</span>);</div><div class="line">		&#125;</div><div class="line">	<span class="comment">/*父进程*/</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		len = <span class="built_in">strlen</span>(PAR_MESS);</div><div class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(write(pipefd[<span class="number">1</span>], PAR_MESS, len) != len) &#123;</div><div class="line">				oops(<span class="string">"write"</span>, <span class="number">4</span>);</div><div class="line">			&#125; </div><div class="line">			sleep(<span class="number">1</span>);</div><div class="line">			read_len = read(pipefd[<span class="number">0</span>], buf, BUFSIZ);</div><div class="line">			<span class="keyword">if</span>(read_len &lt;= <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			write(<span class="number">1</span>, buf, read_len);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><ul>
<li><p>从管道中读取数据</p>
<ul>
<li>当进程试图从管道读取数据时，进程被挂起直到数据被写进管道。</li>
<li>当所有的写进程关闭了管道的写数据端时，试图从管道中读取数据的调用会返回<code>0</code>，这意味这文件的结束。</li>
</ul>
</li>
<li><p>向管道中写数据</p>
<ul>
<li>写入数据阻塞直到管道有空间去容纳新的数据。</li>
<li>如果所有的读进程都已关闭了管道的读数据端，那么对管道的写入调用将会执行失败。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Unix</code>默认从文件描述符<code>0</code>读取数据，写数据到文件描述符<code>1</code>，将错误信息输出到文件描述符<code>2</code>。</li>
<li>创建文件描述符的系统调用总是使用最低可用文件描述符号。</li>
<li>重定向标准输入、标准输出和错误输出意味着改变文件描述符<code>0</code>、<code>1</code>和<code>2</code>的连接。</li>
<li>管道是内核中的一个数据队列，其每一端连接一个文件描述符。程序通过<code>pipe</code>系统调用来创建管道。</li>
<li>当父进程调用<code>fork</code>的时候，管道的两端都被复制到子进程中。</li>
<li>只有有共同父进程的进程之间才可以用管道连接。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>相关代码见<a href="https://github.com/tinylcy/LeetCode/tree/master/Linux%20Commands%20Implementation/io" target="_blank" rel="external">Github</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="external">Unix/Linux编程实践教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标准I-O与重定向的若干概念&quot;&gt;&lt;a href=&quot;#标准I-O与重定向的若干概念&quot; class=&quot;headerlink&quot; title=&quot;标准I/O与重定向的若干概念&quot;&gt;&lt;/a&gt;标准I/O与重定向的若干概念&lt;/h2&gt;&lt;h3 id=&quot;3个标准文件描述符&quot;&gt;&lt;a hre
    
    </summary>
    
    
      <category term="Unix/Linux" scheme="http://tinylcy.me/tags/Unix-Linux/"/>
    
  </entry>
  
  <entry>
    <title>TCP拥塞控制</title>
    <link href="http://tinylcy.me/2016/08/14/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <id>http://tinylcy.me/2016/08/14/TCP拥塞控制/</id>
    <published>2016-08-14T03:25:21.000Z</published>
    <updated>2017-04-25T04:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h2><p>网络的传输层有两种方式——<code>TCP</code>和<code>UDP</code>，其中<code>TCP</code>是基于连接的，而<code>UDP</code>不需要连接。它们各自支持一些应用层协议，但也有些协议是两者都支持的，比如<code>DNS</code>，我们通过<code>DNS</code>来比较<code>TCP</code>和<code>UDP</code>的差别。当前我的计算机的<code>ip</code>为<code>192.168.199.134</code>，向<code>DNS</code>服务器发起一个<code>DNS</code>查询，以期获得<code>tinylcy.me</code>所对应的<code>ip</code>地址。<code>DNS</code>默认使用<code>UDP</code>的情况如下所示：</p>
<p><img src="/img/2016-08-14-Image 1.png" alt="Alt text"></p>
<p>通过<code>Wireshark</code>抓取这个过程的网络包，如下所示：</p>
<p><img src="/img/2016-08-14-Image 2.png" alt="Alt text"></p>
<p>使用<code>set vc</code>强制<code>DNS</code>使用<code>TCP</code>：</p>
<p><img src="/img/2016-08-14-Image 3.png" alt="Alt text"></p>
<p>这个过程所有的网络包如下所示：</p>
<p><img src="/img/2016-08-14-Image 4.png" alt="Alt text"></p>
<p>从以上两种情况可以得知，真正起查询作用的只有两个<code>DNS</code>包。在使用<code>UDP</code>的情况下，确实只需要两个包就可以完成<code>DNS</code>查询，但是在使用<code>TCP</code>时，要先用<code>3</code>个包来建立连接。可以看到，如果<code>DNS</code>使用<code>TCP</code>，那么连接的成本将会远远大于<code>DNS</code>查询本身，这对于繁忙的<code>DNS</code>服务器来说无疑是巨大的压力，因此，<code>DNS</code>服务器默认使用<code>UDP</code>来传输数据。</p>
<p>但是大多数应用层协议还是基于<code>TCP</code>，因为<code>TCP</code>可靠的连接带来的好处更多。首先，需要理解几个重要的<code>TCP</code>参数。</p>
<ul>
<li><code>Seq</code>：表示数据段的序号。<code>TCP</code>提供有序的传输，所以每个数据包都要标上一个序号。当接收方收到乱序的包时，有了这个序号就可以重新排序了。如下图所示，数据包<code>6</code>的起始序号为<code>1</code>，长度为<code>20</code>，那么数据包<code>7</code>的<code>Seq</code>号即为<code>1 + 20 = 21</code>。数据段<code>7</code>的长度为<code>433</code>，所以数据包<code>8</code>的<code>Seq</code>为<code>21 + 433 = 454</code>。</li>
</ul>
<p><img src="/img/2016-08-14-Image 5.png" alt="Alt text"></p>
<ul>
<li><code>Len</code>：对应数据包的长度，注意这个长度不包括<code>TCP</code>头，很多情况下，包的<code>Len = 0</code>，但其实是有<code>TCP</code>头的，并且头部携带的信息量还很大。</li>
<li><code>Ack</code>：确认号，如下图所示，数据段<code>91</code>的<code>Seq = 438</code>，<code>Len = 20</code>，来自接收方的<code>92</code>号数据包的<code>Ack = 438 + 20 = 458</code>，表示收到了之前的<code>458</code>字节。理论上，接收方回复的<code>Ack</code>号恰好等于发送方的下一个<code>Seq</code>号，所以可以看到<code>93</code>号数据包的<code>Seq = 458</code>。</li>
</ul>
<p><img src="/img/2016-08-14-Image 6.png" alt="Alt text"></p>
<p>由于网络传输的不确定性，因此接收方收到的数据包往往是乱序的，此时，接收方只需要根据<code>Seq</code>号从小到大重新排序就好了，这样就保证了<code>TCP</code>的有序性。若存在数据包的丢失，接收方通过前一个<code>Seq + Len</code>的值与下一个<code>Seq</code>的差，就能判断丢失了哪些包，这保证了<code>TCP</code>的可靠性。</p>
<h2 id="TCP窗口"><a href="#TCP窗口" class="headerlink" title="TCP窗口"></a>TCP窗口</h2><p><code>TCP</code>传输数据包之后，需要等待确认包是否到达，这样就花费了一个往返时间。如果每发送一个包就停下来确认，那么在一个往返时间只能发送一个包，这样的传输效率太低。最快的方式就是一次把所有的包全部发送出去，然后一起确认，但是现实存在着限制：接收方的缓存（接收窗口）可能一下子接受不了这么多数据；网络带宽也不一定足够大，一次发太多数据会导致丢包事故。因此，发送方要知道接收方的接收窗口和网络这两个限制因素哪一个更加严格然后在其限制范围内尽可能的多发包。这个一口气能够发送的数据量就是所谓的<code>TCP</code>发送窗口。</p>
<h3 id="Window-size-value"><a href="#Window-size-value" class="headerlink" title="Window size value"></a>Window size value</h3><p>如下图所示，每个包的<code>TCP</code>层都含有<code>Window size value</code>，这个值并不是指发送窗口的大小，而是在向对方声明自己的接收窗口。</p>
<p><img src="/img/2016-08-14-Image 7.png" alt="Alt text"></p>
<p><code>151.101.24.133</code>向<code>192.168.199.134</code>声明自己的接收窗口是<code>28800</code>字节，<code>192.168.199.134</code>收到之后，就会把自己的发送窗口限制在<code>28800</code>字节内。</p>
<h3 id="发送窗口大小"><a href="#发送窗口大小" class="headerlink" title="发送窗口大小"></a>发送窗口大小</h3><p>如果发送窗口的大小由接收窗口决定，那么可以通过<code>Window size value</code>来判断，而当发送窗口的大小由网络因素决定，事情就会变得很复杂。大多数时候，甚至不确定哪个因素在起作用，只能大概推理。如果接收窗口的大小声明为<code>0</code>，那么接收窗口肯定会起作用，因为不能再小了，可以推断对应的发送方的发送窗口就为<code>0</code>。</p>
<h3 id="发送窗口和MSS"><a href="#发送窗口和MSS" class="headerlink" title="发送窗口和MSS"></a>发送窗口和MSS</h3><p>发送窗口决定一次能够发送的字节数，而<code>MSS</code>决定了这些字节需要分多少个包才能发完。举例：在发送窗口为<code>16000</code>字节的情况下，如果<code>MSS</code>是<code>1000</code>字节，那么需要发送<code>16</code>个包；如果<code>MSS</code>为<code>8000</code>字节，那么发送的包数即为<code>2</code>。</p>
<h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><p>网络之所以要限制发送窗口，是因为一次收到太多数据就会拥塞，拥塞的结果就是丢包，能导致网络拥塞的数据流称为拥塞点。发送方希望能够把发送窗口的控制在拥塞点以下，但是网络设备并不知道自己的拥塞点，即便知道了也无法通知给发送方。</p>
<p>目前并没有完美的解决方案，相对靠谱的策略是在发送方维护一个虚拟的拥塞窗口，并利用算法使它尽可能的接近真实的拥塞点，网络对发送窗口的限制，就是通过拥塞窗口来实现的。</p>
<ul>
<li>连接刚刚建立，发送方对网络状况一无所知。如果一次发送太多的数据就可能遭遇拥塞，所以把发送方的拥塞窗口初始值定的很小，RFC的建议是<code>2</code>个、<code>3</code>个或者<code>4</code>个<code>MSS</code>。</li>
<li>用过发出去的包都得到确认，表明还没有到达拥塞点，可以增大拥塞窗口。由于这个阶段发送拥塞的概率很低，所以增速可以快一些。<code>RFC</code>建议的算法是每收到<code>n</code>个确认，可以把拥塞窗口增加<code>n</code>个<code>MSS</code>。这个过程的增速很快，但是由于基数低，传输速度还是比较慢的，所以被称为慢启动过程。</li>
<li>慢启动过程持续一段时间后，拥塞窗口达到一个较大的值。这时候传输速度比较快，触碰拥塞点的概率也大了，所以不能再采用翻倍的慢启动算法了，而是要更加缓慢一些。<code>RFC</code>建议是每个往返时间增加一个<code>MSS</code>。这个过程被称为拥塞避免。从慢启动过渡到拥塞避免的临界窗口值很有讲究。如果之前发生过拥塞，那么就把该拥塞点作为参考依据，如果从来没有发生过拥塞就可以取相对较大的值，比如和最大接收窗口相等。</li>
</ul>
<p>拥塞之后，对于发送方来说就是发出去的包得不到确认了，不过收不到确认也可能是网络延迟导致，所以发送方会等待一会儿再判断，如果迟迟收不到，那么就认定包已经丢失，只能重传了。这个过程被称为超时重传。从发出原始包到重传该包的时间被称为<code>RTO</code>。</p>
<p>重传之后的拥塞窗口非常有必要调整，<code>RFC</code>建议把拥塞窗口下降到<code>1</code>个<code>MSS</code>，然后再次进入慢启动过程。这一次从慢启动过程过渡到拥塞避免的临界窗口值就有参考依据了。<code>RFC</code>建议临界窗口值为发生拥塞时没被确认的数据量的<code>1/2</code>，但是不能小于<code>2</code>个<code>MSS</code>。</p>
<p>下图模拟了慢启动和拥塞避免两个过程，并且在此期间发生了超时重传。<br><img src="/img/2016-08-14-Image 8.png" alt="Alt text"></p>
<p>可以看到超时重传对传输性能有着严重影响。因为<code>RTO</code>阶段没有传输数据，相当于浪费了一段时间，并且拥塞敞口急剧减小，相当于接下来传的慢多了。</p>
<p>有时候拥塞很轻微，只有少量的包丢失，还有一些偶然因素，比如校验码不对，也会导致单个丢包。但是这种丢包和严重拥塞时的丢包并不一样，因为后续有包正常到达。当后续的包到达接收方时，会发现其<code>Seq</code>比期望的大，所以接收方每收到一个包就<code>Ack</code>一次期望的<code>Seq</code>号。当发送方收到<code>3</code>个或者以上的重复确认（<code>Dup Ack</code>）时，就意识到相应的包已经丢失了，因此立即重传它。这个过程被称为快速重传。之所以称为快速，是因为它不需要像超时重传那样等待一段时间。</p>
<p>前面提到发送方在收到<code>3</code>个或者以上的<code>Dup Ack</code>时才会启动快速重传，这是因为网络包有时会乱序，乱序的包也会导致触发重复的<code>Ack</code>，但是没有必要为了乱序而重传。由于一般乱序的距离不会相差太大，所以限定成<code>3</code>个 或者以上可以很大程度上避免因为乱序而出发快速重传。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26268767/" target="_blank" rel="external">Wireshark网络分析就这么简单</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP基础&quot;&gt;&lt;a href=&quot;#TCP基础&quot; class=&quot;headerlink&quot; title=&quot;TCP基础&quot;&gt;&lt;/a&gt;TCP基础&lt;/h2&gt;&lt;p&gt;网络的传输层有两种方式——&lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt;UDP&lt;/code&gt;，其中&lt;code&gt;TCP
    
    </summary>
    
    
      <category term="TCP/IP" scheme="http://tinylcy.me/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>目录与文件属性：编写ls</title>
    <link href="http://tinylcy.me/2016/07/30/%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%EF%BC%9A%E7%BC%96%E5%86%99ls/"/>
    <id>http://tinylcy.me/2016/07/30/目录与文件属性：编写ls/</id>
    <published>2016-07-29T17:12:33.000Z</published>
    <updated>2017-04-25T04:47:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>ls</code>命令可以列出目录中所有文件的名字，以及这些文件的其它信息。注意，<code>ls</code>对文件和目录所做的操作是不同的，<code>ls</code>能判定参数指定的是文件还是目录。如果要自己编写<code>ls</code>，需要掌握三点：</p>
<ul>
<li>如何列出目录的内容。</li>
<li>如何读取并显示文件的属性。</li>
<li>给出一个名字，如何能够判断出它是目录还是文件。</li>
</ul>
<h2 id="编写ls"><a href="#编写ls" class="headerlink" title="编写ls"></a>编写ls</h2><p>目录是一种特殊的文件，它的内容是文件和目录的名字。与普通文件不同的是，目录文件永远不会为空，每个目录至少包含两个特殊的项目：<code>.</code>和<code>..</code>，分别代表当前目录和上一级目录。</p>
<p>什么函数可以读目录？在联机帮助中根据关键字<code>direct</code>来查找答案，用<code>grep</code>过滤出包含<code>read</code>的主题：</p>
<p><img src="/img/2016-07-30-Image 1.png" alt="Alt text"></p>
<p>其中<code>readdir (3)</code>正是需要的，查看它<code>readdir</code>的联机帮助：</p>
<p><img src="/img/2016-07-30-Image 2.png" alt="Alt text"></p>
<blockquote>
<p>The readdir_r() function is a reentrant version of readdir().  It  reads the next  directory  entry  from  the  directory stream  dirp, and returns it in the caller-allocated buffer pointed to by entry. (See NOTES for information on allocating this buffer.)  A pointer to the returned item is placed in <em>result; if the end of the directory stream  was  encountered, then NULL is instead returned in </em>result.</p>
</blockquote>
<p><code>dirent</code>结构中的成员<code>d_name</code>存放文件名，于是，可以开始编写<code>ls</code>。</p>
<p><code>ls</code>的算法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">main()</div><div class="line">    <span class="function">opendir</span></div><div class="line">    <span class="title">while</span><span class="params">(readdir)</span></div><div class="line">        print d_name</div><div class="line">    closedir</div></pre></td></tr></table></figure>
<h2 id="编写ls-l"><a href="#编写ls-l" class="headerlink" title="编写ls -l"></a>编写ls -l</h2><p><code>ls -l</code>要做两件事情，一是列出目录的内容，二是显示文件的详细信息，这实际上是两件不同的工作，目录包含文件名，文件信息则需要从另外的途径获得。先来看<code>ls -l</code>的输出：</p>
<p><img src="/img/2016-07-30-Image 3.png" alt="Alt text"></p>
<p>每行都包含<code>7</code>个字段：模式<code>(mode)</code>、链接数<code>(links)</code>、文件所有者<code>(owner)</code>、组<code>(group)</code>、大小<code>(size)</code>、最后修改时间<code>(last-modified)</code>和文件名<code>(name)</code>。如何得到文件的信息？依旧通过联机帮助：</p>
<p><img src="/img/2016-07-30-Image 4.png" alt="Alt text"></p>
<p>可以看到提取文件状态的系统调用为<code>stat (2)</code>，继续查看<code>stat (2)</code>的联机帮助：</p>
<p><img src="/img/2016-07-30-Image 5.png" alt="Alt text"></p>
<p><code>stat</code>把文件<code>path</code>的信息复制到<code>stat</code>结构的<code>buf</code>中，程序可以从<code>buf</code>中获取文件的属性，联机帮助中说明了<code>struct stat</code>的成员变量：</p>
<p><img src="/img/2016-07-30-Image 6.png" alt="Alt text"></p>
<p>如果仅仅是把<code>stat</code>中的这些信息打印出来，基本上已经实现了<code>ls -l</code>，但是存在显示的问题：打印出来的<code>mode</code>是一个八进制数，所属用户和所属组都是以<code>id</code>的形式显示。因此，为了完善<code>ls -l</code>，需要进一步处理模式、用户名和组的显示。</p>
<h3 id="将模式字段转换成字符串"><a href="#将模式字段转换成字符串" class="headerlink" title="将模式字段转换成字符串"></a>将模式字段转换成字符串</h3><p><code>st_mode</code>是一个<code>16</code>位的二进制数，文件类型和权限被编码在这个数中。其中前<code>4</code>位用作文件类型。接下来<code>3</code>位是文件的特殊属性，<code>1</code>代表具有某个属性，<code>0</code>代表没有，这<code>3</code>位分别是<code>set-user-ID</code>位、<code>set-group-ID</code>位和<code>sticky</code>位。最后的<code>9</code>位是许可权限，分为<code>3</code>组，对应于<code>3</code>种用户：文件所有者、同组用户和其它用户。</p>
<p>文件类型可以通过掩码来将其它部分置<code>0</code>，从而得到文件类型的值，在<code>&lt;sys/stat.h&gt;</code>中有如下定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _POSIX_SOURCE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFMT	 0170000		<span class="comment">/* type of file mask */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFIFO	 0010000		<span class="comment">/* named pipe (fifo) */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFCHR	 0020000		<span class="comment">/* character special */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFDIR	 0040000		<span class="comment">/* directory */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFBLK	 0060000		<span class="comment">/* block special */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFREG	 0100000		<span class="comment">/* regular */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFLNK	 0120000		<span class="comment">/* symbolic link */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_IFSOCK 0140000		<span class="comment">/* socket */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISVTX	 0001000		<span class="comment">/* save swapped text even after use */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p><code>S_IFMT</code>是一个掩码，它的值是<code>0170000</code>，可以用来过滤出前<code>4</code>位表示的文件类型。<code>S_IFREG</code>代表普通文件，<code>S_IFDIR</code>代表目录文件。通过掩码把其它无关的部分置<code>0</code>，再与表示目录的代码比较，从而判定是否是一个目录。更简单的方法是使用<code>&lt;sys/stat.h&gt;</code>中的宏来判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISDIR(m)	((m &amp; 0170000) == 0040000)	<span class="comment">/* directory */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISCHR(m)	((m &amp; 0170000) == 0020000)	<span class="comment">/* char special */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISBLK(m)	((m &amp; 0170000) == 0060000)	<span class="comment">/* block special */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span>	S_ISREG(m)	((m &amp; 0170000) == 0100000)	<span class="comment">/* regular file */</span></span></div></pre></td></tr></table></figure>
<h3 id="将用户-组ID转换成字符串"><a href="#将用户-组ID转换成字符串" class="headerlink" title="将用户/组ID转换成字符串"></a>将用户/组ID转换成字符串</h3><p>我们知道，在<code>/etc/passwd</code>中包含着用户列表，但是搜索文件显然不合理。查看联机帮助，可以通过库函数<code>getpwuid</code>来得到完整的用户列表。</p>
<p><img src="/img/2016-07-30-Image 7.png" alt="Alt text"></p>
<p><code>getpwuid</code>需要<code>uid</code>作为参数，返回一个指向<code>struct passwd</code>的指针，<code>passwd</code>这个结构体定义在<code>/usr/include/pwd.h</code>中。</p>
<p><img src="/img/2016-07-30-Image 8.png" alt="Alt text"></p>
<p>类似的，用户所属的组信息保存在<code>/etc/group</code>中，通过<code>getgrgid</code>来访问组列表。联机文档如下所示。</p>
<p><img src="/img/2016-07-30-Image 9.png" alt="Alt text"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><code>ls</code>和<code>ls -l</code>的实现代码见<a href="https://github.com/tinylcy/LeetCode/tree/master/Linux%20Commands%20Implementation/ls" target="_blank" rel="external">Github</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><code>Unix</code>将数据存放于文件中，目录是特殊的文件，它的内容就是其中的文件和子目录的名字，还包含自己的名字，<code>Unix</code>提供一系列函数对目录操作，打开、读、定位和关闭等，但是不提供写目录的函数。</p>
</li>
<li><p>每个文件都有很多属性，程序通过系统调用<code>stat</code>来得到文件的属性。</p>
</li>
<li><p><code>Unix</code>提供的系统调用和库函数众多，要学会查阅联机帮助。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ls&lt;/code&gt;命令可以列出目录中所有文件的名字，以及这些文件的其它信息。注意，&lt;code&gt;ls&lt;/code&gt;对文件和目录所做
    
    </summary>
    
    
      <category term="Unix/Linux" scheme="http://tinylcy.me/tags/Unix-Linux/"/>
    
  </entry>
  
  <entry>
    <title>用机器指令和汇编指令编程（三）</title>
    <link href="http://tinylcy.me/2016/06/25/%E7%94%A8%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://tinylcy.me/2016/06/25/用机器指令和汇编指令编程（三）/</id>
    <published>2016-06-25T15:12:42.000Z</published>
    <updated>2017-04-25T04:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序执行过程的跟踪"><a href="#程序执行过程的跟踪" class="headerlink" title="程序执行过程的跟踪"></a>程序执行过程的跟踪</h2><p>可以使用<code>Debug</code>来跟踪一个程序的执行过程，示例程序<code>1.asm</code>如下所示。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">assume</span> cs:codesg</div><div class="line"></div><div class="line"><span class="symbol">codesg</span> segment</div><div class="line"></div><div class="line">    <span class="keyword">mov </span>ax,<span class="number">0123</span>h</div><div class="line">    <span class="keyword">mov </span><span class="keyword">bx,0456h</span></div><div class="line">    <span class="keyword">add </span>ax,<span class="keyword">bx</span></div><div class="line">    <span class="keyword">add </span>ax,ax</div><div class="line"></div><div class="line">    <span class="keyword">mov </span>ax,<span class="number">4</span>c00h</div><div class="line">    int <span class="number">21</span>h</div><div class="line"></div><div class="line"><span class="symbol">codesg</span> ends</div><div class="line"><span class="symbol">end</span></div></pre></td></tr></table></figure>
<p>使用<code>masm</code>编译<code>1.asm</code>，生成<code>1.obj</code>，然后将<code>1.obj</code>使用连接器<code>Link.exe</code>连接，生成<code>1.exe</code>。输入<code>debug 1.exe</code>，将程序载入内存，并使用<code>R</code>命令查看各个寄存器的设置情况。</p>
<p><img src="/img/2016-06-25-Image 1.png" alt="Alt text"></p>
<p>当程序载入内存后，<code>cx</code>中存放的是程序的长度。<code>1.exe</code>中程序的机器码共有<code>15</code>字节，所以此时<code>cx</code>的值为<code>000FH</code>。</p>
<p>现在考虑程序被装载到内存的什么地方？从上图中可以得到如下信息。</p>
<ul>
<li>程序加载后<code>ds</code>中存放着程序所在内存区的段地址，并且这个内存区的偏移地址为<code>0</code>。因此，程序所在的内存区的地址为<code>ds:0</code>。</li>
<li>这个内存区的前<code>256</code>字节存放的是<code>PSP</code>，<code>DOS</code>通过<code>PSP</code>和程序进行通信。从<code>256</code>字节处开始存放的是我们编写的程序。</li>
</ul>
<p>所以，从<code>ds</code>中可以得到<code>PSP</code>的段地址<code>SA</code>，且<code>PSP</code>的偏移地址为<code>0</code>，所以<code>PSP</code>的物理地址为<code>SA × 16 + 0</code>。因为<code>PSP</code>占据了<code>256(100H)</code>字节，所以程序的物理地址为<code>SA × 16 + 100H = (SA + 16) × 16 + 0</code>。这个地址可以通过段地址和偏移地址表示：<code>SA + 10H:0</code>。</p>
<p>从上图可知，此时<code>ds</code>的值为<code>075AH</code>，则<code>PSP</code>的地址为<code>075AH:0</code>，所以程序的地址应为<code>076A:0</code>，注意此时<code>CS:IP</code>的值正为<code>076A:0</code>，进一步证明了<code>CS:IP</code>指向的是程序执行的下一条指令<code>(MOV AX,0123)</code>。</p>
<p>使用<code>U</code>命令查看从<code>076A:0</code>开始的其它命令。</p>
<p><img src="/img/2016-06-25-Image 2.png" alt="Alt text"></p>
<h2 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h2><h3 id="BX"><a href="#BX" class="headerlink" title="[BX]"></a>[BX]</h3><p>要完成的描述一个内存单元，需要两种信息：①内存单元的地址；②内存单元的长度。</p>
<ul>
<li><code>mov ax,[0]</code>表示将一个内存单元的内容送入<code>ax</code>，这个内存单元的长度为<code>2</code>字节，偏移地址为<code>0</code>，段地址存放在<code>ds</code>中。</li>
<li><code>mov al,[0]</code>表示将一个内存单元的内容送入<code>al</code>，内存单元的长度为<code>1</code>字节，偏移地址为<code>0</code>，段地址存放在<code>ds</code>中。</li>
<li><code>mov ax,[bx]</code>表示将一个内存单元的内容送入<code>ax</code>，内存单元的长度为<code>2</code>字节，偏移地址存放在<code>bx</code>中，段地址在<code>ds</code>中。</li>
<li><code>mov al,[bx]</code>表示将一个内存单元的内容送入<code>al</code>，内存单元的长度为<code>1</code>字节，偏移地址存放在<code>bx</code>中，段地址在<code>ds</code>中。</li>
</ul>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p><code>loop</code>指令的格式是：<code>loop 标号</code>，<code>CPU</code>执行<code>loop</code>指令的时候，执行两步操作，①<code>(cx) = (cx) - 1</code>；②判断<code>cx</code>中的值，不为<code>0</code>则转至标号处指向，如果为<code>0</code>则向下执行。注意到<code>cx</code>中存放着循环次数，影响着<code>loop</code>执行的执行结果。</p>
<p>使用<code>loop</code>实现一个具体的任务：实现<code>2^12</code>的计算。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></div><div class="line"></div><div class="line"><span class="symbol">code</span> segment</div><div class="line">	</div><div class="line">	<span class="keyword">mov </span>ax,<span class="number">2</span></div><div class="line">	<span class="keyword">mov </span>cx,<span class="number">11</span></div><div class="line">	s:<span class="keyword">add </span>ax,ax</div><div class="line">	loop s</div><div class="line"></div><div class="line">	<span class="keyword">mov </span>ax,<span class="number">4</span>c00h</div><div class="line">	int <span class="number">21</span>h</div><div class="line"></div><div class="line"><span class="symbol">code</span> ends</div><div class="line"><span class="symbol">end</span></div></pre></td></tr></table></figure>
<p>分析这段程度的运行过程：当首次执行到<code>add ax,ax</code>时，<code>ax = ax + ax</code>，然后开始执行<code>loop s</code>，先将<code>cx</code>中的值减<code>1</code>，然后判断<code>cx</code>中的值是否为<code>0</code>，若不为<code>0</code>，则跳转到<code>s</code>处执行<code>add ax,ax</code>，如下图所示。</p>
<p><img src="/img/2016-06-25-Image 3.png" alt="Alt text"></p>
<p>查看从<code>CS:IP</code>处的指令，如下图所示。<code>076A:0008</code>为<code>loop s</code>指令的地址，并且标号<code>s</code>已经被翻译成一个地址<code>0006H</code>，如果在执行<code>loop 0006</code>时，<code>cx</code>减<code>1</code>不为<code>0</code>，那么就把<code>IP</code>设置为<code>0006H</code>，从而使<code>CS:IP</code>再次指向<code>076A:0006</code>，实现跳转。因此，<code>loop</code>指令的本质就是检查<code>cx</code>，修改<code>IP</code>。</p>
<p><img src="/img/2016-06-25-Image 4.png" alt="Alt text"></p>
<h3 id="loop和-bx-的联合应用"><a href="#loop和-bx-的联合应用" class="headerlink" title="loop和[bx]的联合应用"></a>loop和[bx]的联合应用</h3><p>考虑这样一个问题：计算<code>FFFF:0~FFFF:B</code>单元中的数据的和，将结果存储在<code>dx</code>中。</p>
<p>分析：</p>
<ul>
<li>运算后的结果是否会超出<code>dx</code>所能存储的范围？<br><code>FFFF:0~FFFF:B</code>内存单元中的数据是字节型的数据，范围在<code>0~255</code>，<code>12</code>个这样的整数相加不会超过<code>65535</code>。</li>
<li>能否将<code>FFFF:0~FFFF:B</code>中的数据直接累加到<code>dx</code>中？<br>不行，因为<code>FFFF:0~FFFF:B</code>中的数据是<code>8</code>位的，不能直接累加到<code>16</code>位的寄存器中。</li>
<li>能否将<code>FFFF:0~FFFF:B</code>累加到<code>dl</code>中，并设置<code>(dh) = 0</code>，从而实现累加？<br> 不能，因为<code>dl</code>是<code>8</code>位寄存器，累加会造成进位丢失。</li>
</ul>
<p>解决办法：用一个<code>16</code>位的寄存器作为中介，将内存单元中的<code>8</code>位数据赋值到<code>16</code>位的寄存器中，然后再将该寄存器中的数据加到<code>dx</code>上。</p>
<p>使用<code>ax</code>作为中介寄存器，并通过<code>loop</code>循环将<code>FFFF:0~FFFF:B</code>内存单元中的值赋值到<code>ax</code>中，再进行累加。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">assume</span> cs:<span class="meta">code</span></div><div class="line"></div><div class="line"><span class="symbol">code</span> segment</div><div class="line">	</div><div class="line">	<span class="keyword">mov </span>ax,<span class="number">0</span>FFFFH</div><div class="line">	<span class="keyword">mov </span>ds,ax</div><div class="line">	<span class="keyword">mov </span><span class="keyword">bx,0</span></div><div class="line">	<span class="keyword">mov </span>dx,<span class="number">0</span></div><div class="line">	<span class="keyword">mov </span>cx,<span class="number">12</span></div><div class="line">	s : <span class="keyword">mov </span>al,[<span class="keyword">bx]</span></div><div class="line">	<span class="keyword">mov </span>ah,<span class="number">0</span></div><div class="line">	<span class="keyword">add </span>dx,ax</div><div class="line">	inc <span class="keyword">bx</span></div><div class="line">	loop s</div><div class="line"></div><div class="line">	<span class="keyword">mov </span>ax,<span class="number">4</span>c00H</div><div class="line">	int <span class="number">21</span>h</div><div class="line"></div><div class="line"><span class="symbol">code</span> ends</div><div class="line"><span class="symbol">end</span></div></pre></td></tr></table></figure>
<p>注意第一条指令<code>mov ax,0FFFFH</code>，在汇编源程序中，数据不能以字母开头，所以要在前面加上<code>0</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>程序被加载进内存后，会创建一个<code>256</code>字节的<code>PSP</code>，从这段内存区的<code>256</code>字节处开始，才将程序装入。<code>ds</code>中存放着<code>PSP</code>的段地址，且此时偏移地址为<code>0</code>。我们所编写的汇编指令是从<code>(ds) + 10H:0</code>处开始，即<code>CS = (ds + 10H)</code>，<code>IP = 0</code>。</li>
<li><code>loop s</code>实现程序循环的本质是修改<code>IP</code>的值。在执行<code>loop s</code>时，需要先将<code>(cx)</code>减<code>1</code>，然后检查<code>(cx)</code>是否为<code>0</code>，若不为<code>0</code>则修改<code>IP</code>，再次执行循环体。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/3037562/" target="_blank" rel="external">汇编语言</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序执行过程的跟踪&quot;&gt;&lt;a href=&quot;#程序执行过程的跟踪&quot; class=&quot;headerlink&quot; title=&quot;程序执行过程的跟踪&quot;&gt;&lt;/a&gt;程序执行过程的跟踪&lt;/h2&gt;&lt;p&gt;可以使用&lt;code&gt;Debug&lt;/code&gt;来跟踪一个程序的执行过程，示例程序&lt;co
    
    </summary>
    
    
      <category term="Assembly" scheme="http://tinylcy.me/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC Context启动过程解析</title>
    <link href="http://tinylcy.me/2016/06/21/Spring-IoC-Context%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/06/21/Spring-IoC-Context启动过程解析/</id>
    <published>2016-06-21T13:57:12.000Z</published>
    <updated>2017-04-25T04:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p><code>Web</code>容器在启动的过程中，会为每个<code>Web</code>应用程序创建一个对应的<code>ServletContext</code>对象，它代表了当前的<code>Web</code>应用，为<code>Spring IoC</code>容器提供宿主环境。</p>
<p>在部署<code>Web</code>工程的时候，<code>Web</code>容器会读取<code>web.xml</code>，创建<code>ServletContext</code>，当前<code>Web</code>工程所有部分都共享这个<code>Context</code>。<code>context-param</code>为<code>ServletContext</code>提供键值对，即<code>Servlet</code>上下文的信息，这些信息<code>Listener</code>、<code>Filter</code>和<code>Servlet</code>都有可能使用到，因此先加载<code>context-param</code>，创建<code>ServletContext</code>，然后加载<code>Listener</code>，再加载<code>Filter</code>，最后加载<code>Servlet</code>。</p>
<p>接下来我将按照这个加载顺序来分析<code>Spring</code>容器的启动过程。</p>
<h2 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h2><p><code>web.xml</code>中配置有<code>ContextLoaderListener</code>，也可以自定义一个实现了<code>ServletContextListener</code>接口的<code>Listener</code>类，<code>web.xml</code>中的配置实例如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>Web</code>容器在启动的过程中会触发<code>ServletContextEvent</code>事件，会被<code>ContextLoaderListener</code>监听到，并调用<code>ContextLoaderListener</code>中的<code>contextInitialized</code>方法，<code>contextInitialized</code>方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ContextLoaderListener</code>类继承了<code>ContextLoader</code>，在初始化<code>Context</code>的过程中，调用<code>ContextLoader</code>的<code>initWebApplicationContext</code>方法初始化<code>WebApplicationContext</code>。<code>WebApplicationContext</code>是一个接口，<code>Spring</code>默认的实现类为<code>XmlWebApplicationContext</code>，<code>XmlWebApplicationContext</code>就是<code>Spring</code>的<code>IoC</code>容器。</p>
<p>在初始化<code>XmlWebApplicationContext</code>之前，<code>Web</code>容器已经加载了<code>context-param</code>，<code>web.xml</code>中的<code>context-param</code>实例如下所示。作为<code>Spring</code>的<code>IoC</code>容器，其对应的<code>Bean</code>定义的配置正是<code>context-param</code>指定的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></div></pre></td></tr></table></figure>
<p>接着进入到<code>initWebApplicationContext</code>方法内，<code>initWebApplicationContext</code>方法定义如下（已省略部分代码）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;      </div><div class="line">    <span class="keyword">if</span>(servletContext.getAttribute(</div><div class="line">        WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"..."</span>);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.context = <span class="keyword">this</span>.createWebApplicationContext(servletContext);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Spring IoC</code>容器初始化前，<code>initWebApplicationContext</code>先检测以<code>ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>为<code>key</code>的值是否为空，若不为空，则初始化<code>IoC Context</code>，并在初始化完毕后，以<code>ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>为<code>key</code>将<code>IoC Context</code>存储到<code>ServletContext</code>中。</p>
<h2 id="初始化Servlet"><a href="#初始化Servlet" class="headerlink" title="初始化Servlet"></a>初始化Servlet</h2><p><code>Servlet</code>可以在<code>web.xml</code>中配置多个，在<code>Spring</code>中，最基本的<code>Servlet</code>为<code>DispatcherServlet</code>，对应的配置实例如下所示。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/spring/appServlet/appServlet-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>DispatcherServlet</code>会建立自己的<code>IoC Context</code>，用以持有相关的<code>Bean</code>，在初始化自己的<code>IoC Context</code>的过程中，先通过<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>，从<code>ServletContext</code>中获取<code>WebApplicationContext</code>，将<code>WebApplicationContext</code>作为<code>DispatcherServlet的IoC Context</code>的 <code>parent Context</code>。<code>DispatcherServlet</code>自己的<code>IoC Context</code>的初始化工作在<code>DispatcherServlet</code>的<code>initStrategies</code>方法中完成，包括控制器映射，视图解析等，<code>initStrategies</code><br>方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</div><div class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</div><div class="line">    <span class="keyword">this</span>.initThemeResolver(context);</div><div class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</div><div class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</div><div class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</div><div class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</div><div class="line">    <span class="keyword">this</span>.initViewResolvers(context);</div><div class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>DispatcherServlet</code>自己的<code>IoC Context</code>的类型也是<code>XmlWebApplicationContext</code>，初始化完毕后，<code>Spring</code>将以与<code>DispatcherServlet</code>的<code>servlet-name</code>属性相关的符号作为<code>key</code>，将<code>IoC Context</code>保存到    <code>ServletContext</code>中。这样每个<code>Servlet</code>就都可以持有自己的<code>Context</code>，也就是都拥有自己的<code>Bean</code>空间，同时，各个<code>Servlet</code>之间还共享着<code>key</code>为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>的<code>WebApplicationContext</code>，其中定义的<code>Bean</code>为各个<code>Servlet</code>共享的<code>Bean</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/q/1010000000210417" target="_blank" rel="external">segmentfault</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ServletContext&quot;&gt;&lt;a href=&quot;#ServletContext&quot; class=&quot;headerlink&quot; title=&quot;ServletContext&quot;&gt;&lt;/a&gt;ServletContext&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Web&lt;/code&gt;容器在启动的
    
    </summary>
    
    
      <category term="Spring" scheme="http://tinylcy.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码分析</title>
    <link href="http://tinylcy.me/2016/06/10/LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/06/10/LinkedList源码分析/</id>
    <published>2016-06-10T13:48:56.000Z</published>
    <updated>2017-04-25T04:47:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文涉及的<code>JDK</code>源码版本为<code>1.7.0_79</code>。</p>
<h2 id="LinkedList类定义"><a href="#LinkedList类定义" class="headerlink" title="LinkedList类定义"></a>LinkedList类定义</h2><p><code>LinkedList</code>是基于双向链表实现的，<code>LinkedList</code>除了被当做数组来使用，还可以作为栈、队列来使用。由于<code>LinkedList</code>内部采用链表的形式存储元素，因此随机访问会比较慢，但是插入、删除元素比较快。</p>
<p>和<code>ArrayList</code>一样，<code>LinkedList</code>也是非线程安全的，只有在单线程下才可以使用。为了防止非同步访问，可以采用如下方式创建<code>LinkedList</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List list= Collections.synchronizedList(<span class="keyword">new</span> LinkedList());</div></pre></td></tr></table></figure></p>
<p><code>LinkedList</code>的类定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<ul>
<li><code>LinkedList</code>继承了抽象类<code>AbstractSequentialList</code>。</li>
<li><code>LinkedList</code>实现了<code>Serializable</code>接口，可以被序列化，能通过序列化传输。</li>
<li><code>LinkedList</code>实现了<code>Cloneable</code>接口，可以被克隆。</li>
<li><code>LinkedList</code>实现了<code>Deque</code>接口，<code>Deque</code>是双端队列接口，提供了类似<code>push</code>、<code>pop</code>和<code>peek</code>等适用于栈和队列的方法。</li>
</ul>
<p><code>LinkedList</code>中定义了内部类<code>Node</code>来代表链表中的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Node</code>节点 一共有三个属性：<code>item</code>代表节点值，<code>prev</code>代表节点的前一个节点，<code>next</code>代表节点的后一个节点。</p>
<h2 id="LinkedList类属性"><a href="#LinkedList类属性" class="headerlink" title="LinkedList类属性"></a>LinkedList类属性</h2><p><code>LinkedList</code>一共包含三个类成员变量，<code>size</code>代表链表含有节点的个数，<code>first</code>指向链表的首节点，<code>last</code>指向链表的尾节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</div></pre></td></tr></table></figure>
<h2 id="LinkedList类构造函数"><a href="#LinkedList类构造函数" class="headerlink" title="LinkedList类构造函数"></a>LinkedList类构造函数</h2><p><code>LinkedList</code>含有两个构造函数，分别是默认构造函数和带有一个集合对象的构造函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>();</div><div class="line">    addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认构造函数构建了一个空链表，带参数的构造函数将结合对象传入，调用<code>addAll</code>方法初始化链表。既然这里涉及了<code>addAll</code>方法，所以继续追踪下去，<code>addAll</code>方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> addAll(size, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>addAll</code>方法调用了另一个<code>addAll</code>方法，并将链表长度<code>size</code>作为参数传入，该<code>addAll</code>方法如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    checkPositionIndex(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    Node&lt;E&gt; pred, succ;</div><div class="line">    <span class="keyword">if</span> (index == size) &#123;</div><div class="line">        succ = <span class="keyword">null</span>;</div><div class="line">        pred = last;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        succ = node(index);</div><div class="line">        pred = succ.prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">            first = newNode;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            pred.next = newNode;</div><div class="line">        pred = newNode;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</div><div class="line">        last = pred;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pred.next = succ;</div><div class="line">        succ.prev = pred;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    size += numNew;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对该<code>addAll</code>方法进行分析：当调用<code>new LinkedList(Collection c)</code>时，此时<code>size = 0</code>, <code>first = last = null</code>，且此时<code>index = size = 0</code>。<code>addAll</code>方法内创建了两个<code>Node</code>节点的引用<code>pred</code>和<code>succ</code>，<code>pred</code>指向链表构建过程中节点插入位置的前一个节点。当创建新的<code>LinkedList</code>时，<code>succ = null</code>，当向已经存在的<code>LinkedList</code>中插入元素时，<code>succ</code>指向了以当前链表的第<code>index</code>个结点，也就是指向插入位置的后一个结点（此处调用了<code>node(index)</code>方法，后面会介绍）。将<code>Collection</code>转化为<code>Array</code>,进行遍历，将每个元素插入到双向链表。对于一个插入到链表的<code>Node</code>，通过<code>Node</code>的构造函数维护<code>Node</code>的和<code>pred</code>的关系，即让<code>Node</code>的<code>prev</code>指向<code>pred</code>且让<code>pred</code>的<code>next</code>指向<code>Node</code>。当所有的元素都插入到链表后，使<code>pred</code>的<code>next</code>指向<code>succ</code>且让<code>succ</code>的<code>prev</code>指向<code>pred</code>。最后，更新<code>size</code>的大小。</p>
<h2 id="LinkedList类核心方法"><a href="#LinkedList类核心方法" class="headerlink" title="LinkedList类核心方法"></a>LinkedList类核心方法</h2><p><code>linkFirst</code>、<code>linkLast</code>和<code>linkBefore</code>，以及未显示的<code>unlinkFirst</code>、<code>unlinkLast</code>和<code>unlink</code>方法是用于实现一系列的<code>add</code>和<code>remove</code>方法，是<code>LinkedList</code>的实现基础。这些方法如果学习过数据结构的话很好理解。<code>linkFisrst</code>将元素<code>e</code>插入到当前链表的首节点之前，并作为新的首节点。同理，<code>linkLast</code>将元素插入到当前链表末尾，并作为新的尾节点。<code>linkBefore</code>是将元素插入到指定的某个节点之前，其操作同向双向链表插入一个节点一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</div><div class="line">    first = newNode;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        last = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        f.prev = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</div><div class="line">    last = newNode;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        l.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert succ != null;</span></div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</div><div class="line">    succ.prev = newNode;</div><div class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">        first = newNode;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        pred.next = newNode;</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来是一系列<code>get</code>方法、<code>remove</code>方法和<code>add</code>方法，这些方法都是借助于上面提到的<code>linkXX</code>、<code>unlinkXX</code>方法实现。另外，在分析<code>`LinkedList</code>构造函数时，曾涉及<code>addAll(Collcetion c)</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> f.item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> l.item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</div><div class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkFirst(f);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</div><div class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="keyword">return</span> unlinkLast(l);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkFirst(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    linkLast(e);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">                unlink(x);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">                unlink(x);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意到在<code>addAll(Collection c)</code>方法内，调用过<code>node(int index)</code>方法，<code>node</code>方法返回双向链表的第<code>index</code>个节点，<code>node</code>方法定义如下。这儿用到了一个小策略，当<code>index</code>小于链表长度的一半，那么从前往后遍历，否则，从后往前遍历，在<code>O(n/2)</code>时间内可以找到节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法内，先将<code>Collection</code>转化为<code>Array</code>，然后再遍历，这是出于什么考虑？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文涉及的&lt;code&gt;JDK&lt;/code&gt;源码版本为&lt;code&gt;1.7.0_79&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;LinkedList类定义&quot;&gt;&lt;a href=&quot;#LinkedList类定义&quot; class=&quot;headerlink&quot; title=&quot;LinkedList
    
    </summary>
    
    
      <category term="JDK" scheme="http://tinylcy.me/tags/JDK/"/>
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
</feed>
