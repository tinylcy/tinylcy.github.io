<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tinylcy</title>
  <subtitle>辰洋的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tinylcy.me/"/>
  <updated>2017-10-16T13:43:12.000Z</updated>
  <id>http://tinylcy.me/</id>
  
  <author>
    <name>tinylcy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CUDA Lab: Sum of Squares &amp; Matrix Multiplication</title>
    <link href="http://tinylcy.me/2017/10/16/CUDA-Lab-Sum-of-Squares-Matrix-Multiplication/"/>
    <id>http://tinylcy.me/2017/10/16/CUDA-Lab-Sum-of-Squares-Matrix-Multiplication/</id>
    <published>2017-10-16T13:24:12.000Z</published>
    <updated>2017-10-16T13:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>CUDA（Compute Unified Device Architecture）是显卡厂商 NVIDIA 推出的运算平台，是一种通用的并行计算架构，该架构使 GPU 能够解决复杂的计算问题。我们可以使用 GPU 来并行例如神经网络、图像处理等在 CPU 上运行起来比较耗时的程序，通过 GPU 并行计算可以大大提高算法的运行速度。</p>
<a id="more"></a>
<p>本实验包含两部分。</p>
<ul>
<li>第一部分（Sum of Squares）：计算数组元素的平方和，并通过不断的优化来提高程序的性能，以此来学习和理解 CUDA 编程需要注意之处。</li>
<li>第二部分（Matrix Multiplication）：利用 CUDA 实现矩阵乘法并行化。</li>
</ul>
<h3 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h3><ul>
<li>Visual Studio 2015 Community <a href="https://www.visualstudio.com/zh-hans/vs/older-downloads/" target="_blank" rel="external">Download</a>，CUDA Tookit 与 Visual Studio 2017 Community 暂不兼容。</li>
<li>CUDA Tookit <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external">Download</a>。</li>
</ul>
<p>下载 CUDA Tookit 时选择相应的操作系统及版本等平台参数。例如，在 Win10 下进行实验，参数选择如下。</p>
<p><img src="/img/2017-10-16-Image-1.png" alt=""></p>
<p><strong>注意：应先安装 Visual Studio 再安装 CUDA Tookit，因为在安装 CUDA Tookit 时会自动配置 CUDA for Visual Studio，CUDA Tookit 安装成功后可以在 Visual Studio 中创建 CUDA Project。</strong></p>
<p><img src="/img/2017-10-16-Image-2.png" alt=""></p>
<h3 id="CPU-amp-GPU"><a href="#CPU-amp-GPU" class="headerlink" title="CPU &amp; GPU"></a>CPU &amp; GPU</h3><p>下图为CPU和GPU的对比图，相比于CPU，GPU更加适用于计算强度高，多并行的计算中。GPU拥有更多的晶体管，而不是数据Cache和控制器，这样设计的意图是在并行计算过程时每个数据单元经常执行相同的程序，不需要繁琐的复杂流程控制和Cache，更需要强大的计算能力。</p>
<p><img src="/img/2017-10-16-Image-3.png" alt=""></p>
<p>使用 GPU 来进行运算工作，和使用 CPU 相比，主要有以下优势。</p>
<ul>
<li>显示芯片通常具有更大的内存带宽。例如，NVIDIA 的 GeForce 8800GTX 具有超过50GB/s 的内存带宽，而目前高阶 CPU 的内存带宽则在 10GB/s 左右。 </li>
<li>显示芯片具有更大量的执行单元。例如 GeForce 8800GTX 具有 128 个 “stream processors”，频率为 1.35GHz。CPU 频率通常较高，但是执行单元的数目则要少得多。</li>
<li>和高阶 CPU 相比，显卡的价格较为低廉。例如目前一张 GeForce 8800GT 包括512MB 内存的价格，和一颗 2.4GHz 四核心 CPU 的价格相当。 </li>
</ul>
<h3 id="CUDA架构"><a href="#CUDA架构" class="headerlink" title="CUDA架构"></a>CUDA架构</h3><p>在 CUDA 架构下，一个程序被划分为两个部分：Host 端和 Device 端。Host 端是指运行在 CPU 的部分，而 Device 端则是在 GPU 上运行的部分，如下图所示。</p>
<p><img src="/img/2017-10-16-Image-4.png" alt=""></p>
<p>在程序执行过程中，通常 Host 端程序会将数据在主内存中准备好并复制到显存，再由 GPU 执行 Device 端程序，完成后再由 Host 端程序将结果从显存拷贝至主内存。由于 CPU 存取显存时只能通过 PCI Express 接口，因此速度较慢（PCI Express x16 的理论带宽是双向各 4 GB/s），因此不能太频繁的执行这类操作，以免降低效率。</p>
<p>在 CUDA  架构下，GPU 执行时的最小单元是 Thread，数个 Thread 可以组成一个 Block ，<strong>一个 Block 中的 Thread 能够存取同一块共享的内存，而且可以快速进行同步操作</strong>。每一个 Block 所能包含的 Thread 数目是有限的，但是执行相同程序的 Block 可以组成 Grid。不同 Block 中的 Thread 无法存取同一个共享内存，因此无法进行通信和同步。</p>
<p>由于 GPU 具备大量适用于并行计算的特性，因此 GPU 处理问题的方式和 CPU 是不同的，主要体现在以下两点。</p>
<ul>
<li>内存存取 latency 的问题：CPU 通常使用 Cache 开减少存取主内存的次数，以避免内存 latency 影响到执行效率。GPU 通常没有 Cache（或很小），其利用并行化的方式来隐藏内存的 latency（当一个 Thread 需要等待内存读取时，开始执行另一个 Thread）。</li>
<li>分支指令的问题：CPU 通常利用分支预测等方式来减少分支指令造成的 pipeline bubble。GPU 则多半使用类似处理内存 latency 的方式。不过，通常 GPU 处理分支的效率会比较差。</li>
</ul>
<h3 id="Section-1-Sum-of-Squares"><a href="#Section-1-Sum-of-Squares" class="headerlink" title="Section 1: Sum of Squares"></a>Section 1: Sum of Squares</h3><p><strong>目标</strong>：对于给定数组，利用 CUDA 编程实现对该数组所有元素的平方进行求和，并计算每次求和<strong>所消耗的时间</strong>及<strong>显存带宽</strong>。</p>
<p>我们首先实现在 GPU 上的串行求和程序，然后将串行程序并行化，并从两个维度对并行程序进行优化。</p>
<h4 id="Step-1-CUDA初始化"><a href="#Step-1-CUDA初始化" class="headerlink" title="Step 1: CUDA初始化"></a>Step 1: CUDA初始化</h4><p>首先实验需要使用 CUDA 的 RunTime API，所以需要引入头文件 <code>cuda_runtime.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CUDA Runtime API</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cuda_runtime.h&gt;</span></span></div></pre></td></tr></table></figure>
<p>编写程序对当前环境进行检测，如果存在支持 CUDA 的设备，需要设置相应的设备。如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* CUDA初始化 */</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initCUDA</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count, i;</div><div class="line">    <span class="comment">// 取得支持CUDA的装置的数目</span></div><div class="line">    cudaGetDeviceCount(&amp;count);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"There is no device.\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        cudaDeviceProp prop;</div><div class="line">        <span class="keyword">if</span> (cudaGetDeviceProperties(&amp;prop, i) == cudaSuccess) &#123;</div><div class="line">            <span class="keyword">if</span> (prop.major &gt;= <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (i == count) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"There is no device.\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cudaSetDevice(i);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段程序首先调用<code>cudaGetDeviceCount</code>函数获取支持 CUDA 的设备的数量，如果不存在支持 CUDA 的设备 ，则会传入 1（ Device 0），Device 0 只是一个仿真设备，CUDA 的很多功能都不支持，因此如果要真正的确定是否存在支持 CUDA 的设备，需要对每个设备调用<code>cudaGetDeviceProperties</code>函数来获取具体的参数。</p>
<h4 id="Step-2-CUDA核函数"><a href="#Step-2-CUDA核函数" class="headerlink" title="Step 2: CUDA核函数"></a>Step 2: CUDA核函数</h4><p>在介绍核函数前，通过一段程序创建待求和的数组，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 产生0-9之间的随机数 */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateNumbers</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">        numbers[i] = rand() % <span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果要进行求和计算，需要将生成的数组从主内存拷贝至显存。因此，我们需要在显存开辟一块合适的空间，然后将数组拷贝至显存空间，相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *gpudata, *result;</div><div class="line"></div><div class="line">generateNumbers(data, DATA_SIZE);</div><div class="line"></div><div class="line"><span class="comment">// 在显存上分配空间</span></div><div class="line"><span class="comment">// 思考：为什么cudaMalloc函数原型的第一个参数类型为 (void **)？</span></div><div class="line"><span class="comment">// 原因：gpudata指向某块内存区域的首地址，cudaMalloc在显存中分配一块内存，然后将该内存区域的首地址</span></div><div class="line"><span class="comment">//      赋值给gpudata，因此cudaMalloc修改的是gpudata本身的值，而不是gpudata指向的内存区域的值。</span></div><div class="line">cudaMalloc((<span class="keyword">void</span>**)&amp;gpudata, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * DATA_SIZE);</div><div class="line">cudaMalloc((<span class="keyword">void</span>**)&amp;result, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line"></div><div class="line"><span class="comment">// 将数据从内存复制到显存</span></div><div class="line">cudaMemcpy(gpudata, data, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * DATA_SIZE, cudaMemcpyHostToDevice);</div></pre></td></tr></table></figure>
<p>在完成主内存和显存的数据拷贝后，开始着手编写核函数实现在 GPU 上的求和计算，核函数在编写时需要在函数返回值（<code>void</code>）加添加<code>__global__</code>，同时，核函数不允许有返回值。目前我们仅实现串行求和，其核函数如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *result)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum, i;</div><div class="line">    sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DATA_SIZE; i++) &#123;</div><div class="line">        sum += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line">    *result = sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Step-3-执行核函数"><a href="#Step-3-执行核函数" class="headerlink" title="Step 3: 执行核函数"></a>Step 3: 执行核函数</h4><p>在 CUDA 中，使用如下规则执行核函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">函数名称&lt;&lt;&lt;Block Num, Thread Num, Shared Memory Size&gt;&gt;&gt;(参数...);</div></pre></td></tr></table></figure>
<p>因为目前我们仅需要实现串行计算，因此设置Block Num = 1，Thread Num = 1，Shared Memory Size = 0，相关程序如下所示。同时，在执行核函数后不要忘记释放程序分配的显存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sumOfSquares &lt;&lt; &lt; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &gt;&gt; &gt; (gpudata, result);</div><div class="line"><span class="comment">// 把计算结果从显存复制到内存</span></div><div class="line">cudaMemcpy(&amp;sum, result, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cudaMemcpyDeviceToHost);</div><div class="line">cudaFree(gpudata);</div><div class="line">cudaFree(result);</div></pre></td></tr></table></figure>
<p>Step 1，Step 2 和 Step 3 的完整程序<code>sum_squares_1.cu</code>见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_1.cu" target="_blank" rel="external">GitHub</a> 。</p>
<h4 id="Step-4-评估程序表现"><a href="#Step-4-评估程序表现" class="headerlink" title="Step 4: 评估程序表现"></a>Step 4: 评估程序表现</h4><p>在介绍 CUDA 架构时提到，GPU 通常没有 Cache（或很小），因此我们在编写程序时需要避免内存 latency 影响到执行效率。<strong>本实验通过核函数的运行时间来计算程序所使用的显存带宽在评估程序的性能表现。</strong></p>
<p>对<code>sum_squares_1.cu</code>进行部分改动：利用<code>clock</code>函数获取当前时间，时间差值即为核函数的运行时间。相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *result, <span class="keyword">clock_t</span> *time)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum, i;</div><div class="line">    <span class="keyword">clock_t</span> start, end;</div><div class="line"></div><div class="line">    <span class="comment">// 获取起始时间</span></div><div class="line">    start = clock();</div><div class="line"></div><div class="line">    sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DATA_SIZE; i++) &#123;</div><div class="line">        sum += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line">    *result = sum;</div><div class="line"></div><div class="line">    <span class="comment">// 获取结束时间</span></div><div class="line">    end = clock();</div><div class="line"></div><div class="line">    *time = end - start;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于核函数不能有返回值，因此在显存开辟一块空间来保存运行时间，然后将该运行时间值拷贝至内存。注意，该时间值的单位是时钟周期，我们需要将消耗的时钟周期数除以 GPU 自身的频率得到以秒为单位的时间值。</p>
<p>对于显存带宽的计算，整个过程程序传输的数据量大小为 4 <em> 1024 </em> 1024 Bytes，将其除以时间得到程序运行过程中占用的显存带宽。</p>
<p>Step 4 的完整程序 <code>sum_squares_2.cu</code> 见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_2.cu" target="_blank" rel="external">GitHub</a>。</p>
<h4 id="Step-5-串行程序并行化"><a href="#Step-5-串行程序并行化" class="headerlink" title="Step 5: 串行程序并行化"></a>Step 5: 串行程序并行化</h4><p>在 CUDA 中，数据是从主内存复制到显存的 Global Memory，而Global Memory 是没有 Cache 的 ，因此存取 Global Memory 所需要的时间是非常长的（通常有数百个时钟周期）。由于之前的程序只有一个线程，当线程读取 Global Memory 时，线程会等待至实际数据读取成功，才能进行下一步计算。</p>
<p>如果程序有多个线程，当其中一个线程在等待读取 Global Memory 时，GPU 可以立即切换至另一个线程。因此，通过增加线程的数量来提高显存的带宽是有效的策略。</p>
<p>首先在程序中定义线程的数量，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 线程数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUM 256</span></div></pre></td></tr></table></figure>
<p>程序将数组划分为 <code>THREAD_NUM</code>段，每个线程负责计算其中一段。最后，CPU 负责将各个线程计算得到的子结果进行累加。相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *sub_sum, <span class="keyword">clock_t</span> *time)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 获取当前线程Id（从0开始）</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> thread_id = threadIdx.x;</div><div class="line">    <span class="comment">// 每个线程累加元素的个数</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> size = DATA_SIZE / THREAD_NUM;</div><div class="line"></div><div class="line">    sub_sum[thread_id] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = thread_id * size; i &lt; (thread_id + <span class="number">1</span>) * size; i++) &#123;</div><div class="line">        sub_sum[thread_id] += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Step 5 的完整程序<code>sum_squares_3.cu</code>见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_3.cu" target="_blank" rel="external">GitHub</a>。</p>
<h4 id="Step-6-改进显存存取模式"><a href="#Step-6-改进显存存取模式" class="headerlink" title="Step 6: 改进显存存取模式"></a>Step 6: 改进显存存取模式</h4><p>显卡内存一般都是 DRAM，因此最有效的显存存取方式为连续存取。对于<code>cuda_sample_3</code>，虽然每个线程操作的都是一块连续的内存，但是考虑当一个线程等待 Global Memory 的数据时，GPU 切换至另一个线程，而另一个线程会从显存的其它位置存取数据，下图描述了上述过程。</p>
<p><img src="/img/2017-10-16-Image-5.png" alt=""></p>
<p>综上分析，虽然在同一个线程中是在一块连续的显存空间读取数据，但是在实际执行时并不是连续读取的，而是跳跃式的存取模式。因此，我们需要将显存的存取模式改进为连续存取模式，如下图所示。</p>
<p><img src="/img/2017-10-16-Image-6.png" alt=""></p>
<p>修改核函数，改进显存的存取模式，相关程序如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *sub_sum, <span class="keyword">clock_t</span> *time)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> thread_id = threadIdx.x;</div><div class="line">  </div><div class="line">    sub_sum[thread_id] = <span class="number">0</span>;</div><div class="line">    <span class="comment">// 线程0获取第0个元素，线程1获取第1个元素，以此类推... </span></div><div class="line">    <span class="keyword">for</span> (i = thread_id; i &lt; DATA_SIZE; i += THREAD_NUM) &#123;</div><div class="line">        sub_sum[thread_id] += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Step 6 的完整程序<code>sum_squares_4.cu</code>见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_4.cu" target="_blank" rel="external">GitHub</a>。</p>
<h4 id="Step-7-进一步并行"><a href="#Step-7-进一步并行" class="headerlink" title="Step 7: 进一步并行"></a>Step 7: 进一步并行</h4><p>在介绍 CUDA 架构时提到，CUDA 除了提供了 Thread，还提供了 Block 及 Grid等重要的机制。每个 Block 的数量是有限的，但是可以通过增加 Block 的数量来成倍的增加线程的数量。需要注意的是，不同 Block 内的线程相互不能同步和通信，不过在我们的程序中线程之间并不需要进行同步或通信。因此，Step 7 将会使用多个 Block 来进一步并行化程序。相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *sub_sum, <span class="keyword">clock_t</span> *time)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 获取当前线程所属的Block号（从0开始）</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> block_id = blockIdx.x;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> thread_id = threadIdx.x;</div><div class="line"></div><div class="line">    sub_sum[block_id * THREAD_NUM + thread_id] = <span class="number">0</span>;</div><div class="line">    <span class="comment">// Block0-线程0获取第0个元素，Block0-线程1获取第1个元素...Block1-线程0获取第THREAD_NUM个元素，以此类推... </span></div><div class="line">    <span class="keyword">for</span> (i = block_id * THREAD_NUM + thread_id; i &lt; DATA_SIZE; i += BLOCK_NUM * THREAD_NUM) &#123;</div><div class="line">        sub_sum[block_id * THREAD_NUM + thread_id] += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Step 7 的完整程序<code>sum_squares_5.cu</code>见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_5.cu" target="_blank" rel="external">GitHub</a>。</p>
<h4 id="Step-8-共享内存和线程同步"><a href="#Step-8-共享内存和线程同步" class="headerlink" title="Step 8: 共享内存和线程同步"></a>Step 8: 共享内存和线程同步</h4><p>在 Step 7 中，CPU 需要进行 <code>BLOCK_NUM * THREAD_NUM</code> 个元素的累加，如果可以让 GPU 执行一部分的累加，理应能够进一步提高程序的并行度。因为在一个 Block 内，线程是可以共享内存的，因此可以在 GPU 上实现一个 Block 内的线程结果累加，CPU 仅需要完成各个 Block 的计算结果的累加。</p>
<p>需要注意：需要等待一个 Block 内的所有线程都完成计算才进行各个线程的计算结果的类型。因此，程序需要进行线程的同步，在 CUDA 中，通过<code>__syncthreads</code>函数进行线程的同步，相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *sub_sum, <span class="keyword">clock_t</span> *time)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// 声明共享内存区域，用于存储每个Block中线程计算结果的累加和</span></div><div class="line">    <span class="keyword">extern</span> __shared__ <span class="keyword">int</span> shared[];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> block_id = blockIdx.x;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> thread_id = threadIdx.x;</div><div class="line">  </div><div class="line">    shared[thread_id] = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (i = block_id * THREAD_NUM + thread_id; i &lt; DATA_SIZE; i += BLOCK_NUM * THREAD_NUM) &#123;</div><div class="line">        shared[thread_id] += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 线程同步，所有线程需要执行到此处方可继续向下执行</span></div><div class="line">    __syncthreads();</div><div class="line"></div><div class="line">    <span class="comment">// 线程0负责计算所有线程的计算结果累加和</span></div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span> == thread_id) &#123;</div><div class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; THREAD_NUM; i++) &#123;</div><div class="line">            shared[<span class="number">0</span>] += shared[i];</div><div class="line">        &#125;</div><div class="line">        sub_sum[block_id] = shared[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Step 8 的完整程序<code>sum_squares_6.cu</code>见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_6.cu" target="_blank" rel="external">GitHub</a>。</p>
<h4 id="Step-9-树状加法"><a href="#Step-9-树状加法" class="headerlink" title="Step 9: 树状加法"></a>Step 9: 树状加法</h4><p>在 Step 8 中，一个 Block 中所有线程的结果的累加是通过一个线程（Thread 0）实现的，如果能够把每个 Block 内的加法并行化，那么程序的并行度应该能够进一步提高。我们利用树状加法将加法并行，树状加法计算过程如下图所示。</p>
<p><img src="/img/2017-10-16-Image-7.png" alt=""></p>
<p>上图一个格子代表一个线程的计算结果，当进行第一轮迭代时，步长等于 1，Thread 0 和 Thread 1 相加，Thread 2 和 Thread 3 相加，依次类推…当进行第二轮迭代时，步长等于 1 + 1 = 2，Thread 0 和 Thread 2 相加，Thread 4 和 Thread 6 相加，依次类推…当进行第三轮迭代时，步长等于 2 + 2 = 4， Thread 0 和 Thread 4 相加，Thread 8 和 Thread 12 相加…依次类推。相关代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算平方和（__global__函数运行于GPU）*/</span></div><div class="line">__<span class="function">global__ <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sumOfSquares</span><span class="params">(<span class="keyword">int</span> *numbers, <span class="keyword">int</span> *sub_sum, <span class="keyword">clock_t</span> *time)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line"></div><div class="line">    <span class="keyword">extern</span> __shared__ <span class="keyword">int</span> shared[];</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> block_id = blockIdx.x;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> thread_id = threadIdx.x;</div><div class="line">    <span class="comment">// 定义步长和计算掩码</span></div><div class="line">    <span class="keyword">int</span> offset, mask;</div><div class="line">  </div><div class="line">    shared[thread_id] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i = block_id * THREAD_NUM + thread_id; i &lt; DATA_SIZE; i += BLOCK_NUM * THREAD_NUM) &#123;</div><div class="line">        shared[thread_id] += numbers[i] * numbers[i];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __syncthreads();</div><div class="line"></div><div class="line">    <span class="comment">/* 并行加法代码段 */</span></div><div class="line">    offset = <span class="number">1</span>;</div><div class="line">    mask = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (offset &lt; THREAD_NUM) &#123;</div><div class="line">        <span class="comment">// 注意 &amp; 的优先级小于 ==</span></div><div class="line">        <span class="keyword">if</span> ((thread_id &amp; mask) == <span class="number">0</span> &amp;&amp; thread_id + offset &lt; THREAD_NUM) &#123;</div><div class="line">            shared[thread_id] += shared[thread_id + offset];</div><div class="line">        &#125;</div><div class="line">        offset += offset;</div><div class="line">        mask += offset;</div><div class="line">        <span class="comment">// 每迭代一轮需要所有线程进行一次同步</span></div><div class="line">        __syncthreads();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sub_sum[block_id] = shared[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Step 9 的完整程序<code>sum_squares_7.cu</code>见 <a href="https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_7.cu" target="_blank" rel="external">GitHub</a>。</p>
<h3 id="Section-2-Matrix-Multiplication"><a href="#Section-2-Matrix-Multiplication" class="headerlink" title="Section 2: Matrix Multiplication"></a>Section 2: Matrix Multiplication</h3><p>目标：利用 CUDA 编写矩阵乘法并行程序，为了简化程序编写，假设待相乘的两个矩阵均为方块矩阵。</p>
<p>在 CUDA 上实现矩阵乘法有多种方法，我自己实现了一个<a href="https://github.com/tinylcy/cuda_lab/blob/master/MatrixMultiplication/matrix_multiplication.cu" target="_blank" rel="external">版本</a>，供参考。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/column/details/computervision.html" target="_blank" rel="external">计算机视觉编程</a></li>
<li><a href="http://www.smallgui.com/wp-content/uploads/2016/04/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B0%88CUDA.pdf" target="_blank" rel="external">深入浅出谈 CUDA</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CUDA（Compute Unified Device Architecture）是显卡厂商 NVIDIA 推出的运算平台，是一种通用的并行计算架构，该架构使 GPU 能够解决复杂的计算问题。我们可以使用 GPU 来并行例如神经网络、图像处理等在 CPU 上运行起来比较耗时的程序，通过 GPU 并行计算可以大大提高算法的运行速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CUDA" scheme="http://tinylcy.me/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>初探Webx之约定胜于配置</title>
    <link href="http://tinylcy.me/2017/07/12/%E5%88%9D%E6%8E%A2Webx%E4%B9%8B%E7%BA%A6%E5%AE%9A%E8%83%9C%E4%BA%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://tinylcy.me/2017/07/12/初探Webx之约定胜于配置/</id>
    <published>2017-07-12T14:15:18.000Z</published>
    <updated>2017-07-12T14:26:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>实习期间接触到了早有耳闻的<code>Webx</code>，于是很自然的按照官方文档运行了一个 <a href="http://openwebx.org/docs/firstapp.html" target="_blank" rel="external">Demo</a> ，粗略的阅读了一下代码，发现并不能很快的梳理清<code>Web</code>请求的处理逻辑，以及视图层和控制层之间的关联关系。<code>execute()</code>为什么会被调用？<code>doChinese()</code>为什么会被调用？这是我当时的两个疑问，为了解答这些疑问，需要理解<code>Web</code>请求在<code>Webx</code>中经历的处理流程，为此我阅读了<code>Webx</code>部分源码，并以此文作为小结。</p>
<p>在分析之前，我们需要强调<code>Webx</code>的一个重要设计理念——约定胜于配置。“约定”即规则，规则是预先定义的，工程师只需要按着规则来做事，就不需要额外的“配置”。对比其它一些框架，往往每增加一个页面，都需要在配置文件中增加若干行内容。</p>
<p>注意，本篇文章仅用于解答上文提出的两个疑问，更多<code>Webx</code>的设计理念及原理性知识请参阅<a href="http://openwebx.org/docs/" target="_blank" rel="external">官方文档</a>。</p>
<h2 id="execute-为什么会被调用？"><a href="#execute-为什么会被调用？" class="headerlink" title="execute()为什么会被调用？"></a>execute()为什么会被调用？</h2><p>本文以解析请求<code>http://localhost:8080/webx/simple/say_hi.do</code>为例来回答第一个问题，在<code>SayHi</code>类中<code>execute()</code>处添加断点，启动<code>Tomcat</code>，程序执行至断点处，查看此时当前线程的函数调用栈，如下图所示（截取了部分）。</p>
<p><img src="/img/2017-07-12-image.png" alt=""></p>
<p>想要更好的理解该函数调用栈的信息，需要先从理论上对<code>Webx</code>处理一个<code>Web</code>请求有一个认知。</p>
<ul>
<li>首先，增强<code>request</code>、<code>response</code>、<code>session</code>的功能，并把它们打包成更易使用的<code>RequestContext</code>对象。</li>
<li>其次，它会调用相应子应用的<code>pipeline</code>，用它来做进一步的处理。</li>
</ul>
<p><code>pipeline</code>是<code>Webx</code>的一种机制，这种机制给予开发者极大的自由来自定制处理请求的流程。<code>pipeline</code>由一系列的<code>valve</code>构成，一个请求在获取响应（<code>Module</code>）前需经历这一系列<code>valve</code>。<code>Webx</code>将<code>URL</code>映射成<code>target</code>，由开发者定制不同类型的<code>target</code>所匹配的<code>pipeline</code>。例如，当前请求的<code>target</code>为<code>/simple/say_hi.do</code>，与之对应的<code>pipeline</code>如下所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">when</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 执行不带模板的screen，无layout。 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pl-conditions:target-extension-condition</span> <span class="attr">extension</span>=<span class="string">"do"</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pl-valves:performAction</span> /&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">pl-valves:performScreen</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></div></pre></td></tr></table></figure>
<p>结合<code>pipeline</code>与函数调用栈，在执行<code>execute()</code>之前，请求经历了一系列<code>invoke()</code>与<code>invokeNext()</code>。首先执行<code>&lt;pl-valves:performAction /&gt;</code>对应<code>PerformActionValve</code>中的<code>invoke()</code>与<code>invokeNext()</code>，由于当前请求并不包含表单提交，所以<code>PerformActionValve</code>不做任何操作。接着执行<code>&lt;pl-valves:performScreen /&gt;</code>对应的<code>PerformScreenValve</code>中的<code>invoke()</code>，这也是我们分析的重点，该<code>invoke</code>方法对应的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(PipelineContext pipelineContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    TurbineRunData rundata = TurbineUtil.getTurbineRunData(<span class="keyword">this</span>.request);</div><div class="line">    <span class="keyword">if</span>(!rundata.isRedirected()) &#123;</div><div class="line">        <span class="keyword">this</span>.setContentType(rundata);</div><div class="line">        Object result = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            result = <span class="keyword">this</span>.performScreenModule(rundata);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setOutputValue(pipelineContext, result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    pipelineContext.invokeNext();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入<code>performScreenModule</code>方法，其源码如下所示（省略部分无关代码）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">performScreenModule</span><span class="params">(TurbineRunData rundata)</span> </span>&#123;</div><div class="line">    PerformScreenValve.ModuleFinder finder = <span class="keyword">new</span> PerformScreenValve.ModuleFinder(rundata.getTarget());</div><div class="line">    rundata.setLayoutEnabled(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Module e = finder.getScreenModule();</div><div class="line">        <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123;</div><div class="line">            ScreenEventUtil.setEventName(rundata.getRequest(), finder.event);</div><div class="line">            Object var4;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span>(!(e <span class="keyword">instanceof</span> ModuleReturningValue)) &#123;</div><div class="line">                    e.execute();</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">                var4 = ((ModuleReturningValue)e).executeAndReturn();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> var4;</div><div class="line">        &#125; </div><div class="line">        ...</div><div class="line">    &#125; </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>performScreenModule</code>首先根据当前<code>target</code>获取对应的<code>Module</code>。在<code>Webx</code>中，<code>Module</code>承担了用户提交数据的接收与处理、请求的控制与转发、处理结果的展示等重要功能。<code>Webx</code>缺省定义了三种类型的<code>Module</code>。</p>
<ul>
<li><code>action</code>：主要用于处理用户提交的数据，以及请求的控制与转发。</li>
<li><code>screen</code>：主要用于处理页面的主体内容。</li>
<li><code>control</code>：主要用于处理页面的部分内容，特别是可重用的内容。</li>
</ul>
<p>我们接着进入<code>finder.getScreenModule()</code>，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Module <span class="title">getScreenModule</span><span class="params">()</span> <span class="keyword">throws</span> ModuleLoaderException </span>&#123;</div><div class="line">    <span class="keyword">this</span>.moduleName = PerformScreenValve.<span class="keyword">this</span>.getModuleName(<span class="keyword">this</span>.target);</div><div class="line">    Module <span class="keyword">module</span> = PerformScreenValve.<span class="keyword">this</span>.moduleLoaderService.getModuleQuiet(<span class="string">"screen"</span>, <span class="keyword">this</span>.moduleName);</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">module</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.parseEvent()) &#123;</div><div class="line">            <span class="keyword">module</span> = PerformScreenValve.<span class="keyword">this</span>.moduleLoaderService.getModuleQuiet(<span class="string">"screen"</span>, <span class="keyword">this</span>.eventModuleName);</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">module</span> <span class="keyword">instanceof</span> ModuleEvent) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">module</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打断点一步一步深入下去，进入<code>getModuleQuiet()</code>，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Module <span class="title">getModuleQuiet</span><span class="params">(String moduleType, String moduleName)</span> <span class="keyword">throws</span> ModuleLoaderException </span>&#123;</div><div class="line">    ModuleKey moduleKey = <span class="keyword">new</span> ModuleKey(moduleType, moduleName);</div><div class="line">    moduleType = moduleKey.getModuleType();</div><div class="line">    moduleName = moduleKey.getModuleName();</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.cacheEnabled.booleanValue()) &#123;</div><div class="line">        Module moduleObject = (Module)<span class="keyword">this</span>.moduleCache.get(moduleKey);</div><div class="line">        <span class="keyword">if</span>(moduleObject != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> moduleObject;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Object var10 = <span class="keyword">null</span>;</div><div class="line">    Module <span class="keyword">module</span> = <span class="keyword">null</span>;</div><div class="line">    ModuleFactory[] arr$ = <span class="keyword">this</span>.factories;</div><div class="line">    <span class="keyword">int</span> len$ = arr$.length;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i$;</div><div class="line">    <span class="keyword">for</span>(i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</div><div class="line">        ModuleFactory adapter = arr$[i$];</div><div class="line">        var10 = adapter.getModule(moduleType, moduleName);</div><div class="line">        <span class="keyword">if</span>(var10 != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(var10 != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(var10 <span class="keyword">instanceof</span> Module) &#123;</div><div class="line">            <span class="keyword">module</span> = (Module)var10;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ModuleAdapterFactory[] var11 = <span class="keyword">this</span>.adapters;</div><div class="line">            len$ = var11.length;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</div><div class="line">                ModuleAdapterFactory var12 = var11[i$];</div><div class="line">                <span class="keyword">module</span> = var12.adapt(moduleType, moduleName, var10);</div><div class="line">                <span class="keyword">if</span>(<span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">module</span> == <span class="keyword">null</span> &amp;&amp; var10 != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnadaptableModuleException(<span class="string">"Could not adapt object to module: type="</span> + moduleType + <span class="string">", name="</span> + moduleName + <span class="string">", class="</span> + var10.getClass());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.cacheEnabled.booleanValue() &amp;&amp; <span class="keyword">module</span> != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">this</span>.moduleCache.put(moduleKey, <span class="keyword">module</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">module</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>getModuleQuiet()</code>中，首先根据<code>moduleType</code>和<code>moduleName</code>创建<code>modulekey</code>，<code>Webx</code>会对<code>Module</code>进行缓存，因此首先根据<code>moduleKey</code>从缓存中获取<code>Module</code>。如果缓存中还不存在当前<code>target</code>对应的<code>Module</code>，继续深入，进入<code>DataBindingAdapterFactory</code>类的<code>adapt</code>方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Module <span class="title">adapt</span><span class="params">(String type, String name, Object moduleObject)</span> </span>&#123;</div><div class="line">    ModuleInfo moduleInfo = <span class="keyword">new</span> ModuleInfo(type, name);</div><div class="line">    Class moduleClass = moduleObject.getClass();</div><div class="line">    Method executeMethod = <span class="keyword">this</span>.getMethod(moduleClass, <span class="string">"execute"</span>);</div><div class="line">    <span class="keyword">if</span>(executeMethod != <span class="keyword">null</span>) &#123;</div><div class="line">        FastClass fc = FastClass.create(moduleClass);</div><div class="line">        FastMethod fm = fc.getMethod(executeMethod);</div><div class="line">        <span class="keyword">boolean</span> skippable = <span class="string">"action"</span>.equalsIgnoreCase(type);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataBindingAdapter(moduleObject, <span class="keyword">this</span>.getMethodInvoker(fm, moduleInfo, skippable));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>adapt</code>方法中，一切开始变得清晰起来：首先尝试获取<code>moduleObject</code>的<code>execute()</code>方法，若存在，那么当前<code>target</code>对应的Module的最关键部分也就构建完成了。<strong>至此，第一个疑问“为什么<code>execute()</code>会被调用”得到了解答</strong>。</p>
<p>获取了<code>Module</code>之后，<code>executeAndReturn()</code>调用<code>execute()</code>，完成页面主体内容的处理。<code>executeAndReturn()</code>源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">executeAndReturn</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.executeMethod.invoke(<span class="keyword">this</span>.moduleObject, <span class="keyword">this</span>.log);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="doChinese-为什么会被调用？"><a href="#doChinese-为什么会被调用？" class="headerlink" title="doChinese()为什么会被调用？"></a>doChinese()为什么会被调用？</h2><p>此时<code>Web</code>请求<code>URL</code>为 <code>http://localhost:8080/webx/multievent/say_hello_1/chinese.do</code> ，因此相应的<code>target</code>即为<code>/multievent/say_hello_1/chinese.do</code>。与第一个问题的请求处理流程相同，<code>Webx</code>首先根据当前<code>target</code>去获取<code>Module</code>，若无法获取，那么认为当前<code>target</code>是由两部分组成：<code>event</code>和<code>eventModuleName</code>，解析<code>target</code>的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> slashIndex = <span class="keyword">this</span>.target.lastIndexOf(<span class="string">"/"</span>);</div><div class="line">    <span class="keyword">int</span> dotIndex = <span class="keyword">this</span>.target.lastIndexOf(<span class="string">"."</span>);</div><div class="line">    <span class="keyword">if</span>(slashIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.event = <span class="keyword">this</span>.target.substring(slashIndex + <span class="number">1</span>, dotIndex &gt; slashIndex?dotIndex:<span class="keyword">this</span>.target.length());</div><div class="line">        <span class="keyword">this</span>.eventModuleName = PerformScreenValve.<span class="keyword">this</span>.getModuleName(<span class="keyword">this</span>.target.substring(<span class="number">0</span>, slashIndex));</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>继续打断点深入源码，<code>Webx</code>会将<code>eventModuleName</code>作为<code>moduleName</code>获取<code>Module</code>。同样的，首先尝试获取<code>execute()</code>，如果获取不到便获取所有的<code>EventHandler</code>，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Map&lt;String, Method&gt; <span class="title">getEventHandlers</span><span class="params">(Class&lt;?&gt; moduleClass)</span> </span>&#123;</div><div class="line">    HashMap handlers = <span class="keyword">null</span>;</div><div class="line">    Method[] arr$ = moduleClass.getMethods();</div><div class="line">    <span class="keyword">int</span> len$ = arr$.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</div><div class="line">        Method method = arr$[i$];</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.checkMethod(method)) &#123;</div><div class="line">            String methodName = method.getName();</div><div class="line">            <span class="keyword">if</span>(methodName.length() &gt; <span class="number">2</span> &amp;&amp; methodName.startsWith(<span class="string">"do"</span>) &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">2</span>))) &#123;</div><div class="line">                String eventName = StringUtil.toCamelCase(methodName.substring(<span class="number">2</span>));</div><div class="line">                <span class="keyword">if</span>(<span class="string">"perform"</span>.equals(eventName)) &#123;</div><div class="line">                    eventName = <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(handlers == <span class="keyword">null</span>) &#123;</div><div class="line">                    handlers = CollectionUtil.createHashMap();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                handlers.put(eventName, method);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> handlers;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此我们理解为什么<code>doChinese()</code>为什么会被调用了：获取当前<code>target</code>对应的<code>screen</code>的类的所有以<code>do</code>开头的方法，构建<code>eventName</code>与<code>Method</code>的映射关系，存储在一个<code>Map</code>中，注意我们的<code>target</code>已被划分为<code>event</code>和<code>eventModuleName</code>，在<code>executeAndReturn()</code>中根据<code>event</code>从<code>Map</code>中获取相应的<code>Method</code>并执行，源码如下（省略部分无关代码）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">executeAndReturn</span><span class="params">()</span> <span class="keyword">throws</span> ModuleEventException, ModuleEventNotFoundException </span>&#123;</div><div class="line">    Object result = <span class="keyword">null</span>;</div><div class="line">    String event = <span class="keyword">this</span>.getEventName(<span class="keyword">this</span>.request);</div><div class="line">    MethodInvoker handler = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span>(event != <span class="keyword">null</span>) &#123;</div><div class="line">        handler = (MethodInvoker)<span class="keyword">this</span>.handlers.get(event);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</div><div class="line">        handler = (MethodInvoker)<span class="keyword">this</span>.handlers.get((Object)<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">...</div><div class="line">    result = handler.invoke(<span class="keyword">this</span>.moduleObject, <span class="keyword">this</span>.log);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>所以第二个疑问也得到了解答 :P</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实习期间接触到了早有耳闻的&lt;code&gt;Webx&lt;/code&gt;，于是很自然的按照官方文档运行了一个 &lt;a href=&quot;http://openwebx.org/docs/firstapp.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;
    
    </summary>
    
    
      <category term="Webx" scheme="http://tinylcy.me/tags/Webx/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个分布式RPC框架</title>
    <link href="http://tinylcy.me/2017/07/04/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6/"/>
    <id>http://tinylcy.me/2017/07/04/如何实现一个分布式RPC框架/</id>
    <published>2017-07-04T03:57:15.000Z</published>
    <updated>2017-07-04T03:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>远程过程调用（<code>Remote Procedure Call</code>，<code>RPC</code>）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。<code>RPC</code>的主要目标是让构建分布式应用更加容易，在提供强大的远程调用能力的同时不损失本地调用的语义的简洁性。</p>
<p>趁实习前的这段业余时间，我实现了一个轻量级的分布式<code>RPC</code>框架，名字叫做 <a href="https://github.com/tinylcy/buddha" target="_blank" rel="external">buddha</a>，代码量不大，但是麻雀虽小却五脏俱全。本篇文章将一步步阐明<code>buddha</code>的设计、框架组件的拆解以及需要考虑的因素。</p>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>在网络中，所有的数据都将会被转化为字节进行传送，所以在代码层面上，一个<code>RPC</code>框架需要实现特定格式的数据与字节数组之间的相互转化。像<code>Java</code>已经提供了默认的序列化方式，但是如果是在高并发的场景下，使用<code>Java</code>原生的序列化方式可能会遇到性能瓶颈。于是，出现了许多开源的、高效的序列化框架：如<code>Kryo</code>、<code>fastjson</code>和<code>Protobuf</code>等。<code>buddha</code>目前支持<code>Kryo</code>和<code>fastjson</code>两种序列化框架。</p>
<h2 id="TCP拆包、粘包"><a href="#TCP拆包、粘包" class="headerlink" title="TCP拆包、粘包"></a>TCP拆包、粘包</h2><p>由于<code>TCP</code>只关心字节流，并不知晓上层的数据格式。如果客户端应用层一次要发送的数据过大时，<code>TCP</code>会将该数据进行分解传送，因此在服务端需要进行粘包处理（由<code>TCP</code>来保证数据的有序性）；如果客户端一次要发送的数据量很小时，<code>TCP</code>并不会马上把数据发送出去，而是将其存储在缓冲区，当达到某个阈值的时候再发送出去，因此在服务端需要进行拆包的工作。</p>
<p>通过以上分析，我们了解了<code>TCP</code>粘包或者拆包的原因，解决这个问题的关键在于向数据包添加边界信息，常用的方法有如下三个。</p>
<ul>
<li>发送端给每个数据包添加包首部，首部中至少包含数据包的长度，这样在接收端接收到数据时，通过读取首部的长度信息得到该数据包有效数据的长度。</li>
<li>发送端将每个数据包封装为固定长度（多余用<code>0</code>填充），这样接收端在接收到数据后根据约定好的固定长度读取每个数据包的数据。</li>
<li>使用特殊符号将每个数据包区分开来，接收端也是通过该特殊符号的划分数据包的边界。</li>
</ul>
<p><code>buddha</code>采用第一种方式来解决<code>TCP</code>拆包、粘包的问题。</p>
<h2 id="BIO与NIO"><a href="#BIO与NIO" class="headerlink" title="BIO与NIO"></a>BIO与NIO</h2><p><code>BIO</code>往往用于经典的每连接每线程模型，之所以使用多线程，是因为像<code>accept()</code>、<code>read()</code>和<code>write()</code>等函数都是同步阻塞的，这意味着当应用为单线程且进行<code>IO</code>操作时，如果线程阻塞那么该应用必然会进入挂死状态，但是实际上此时<code>CPU</code>是处于空闲状态的。开启多线程，就可以让<code>CPU</code>去为更多的线程服务，提高<code>CPU</code>的利用率。但是在活跃线程数较多的情况下，采用多线程模型回带来如下几个问题。</p>
<ul>
<li>线程的创建和销毁代价颇高，在<code>Linux</code>操作系统中，线程本质上就是一个进程，创建和销毁线程属于重量级的操作。</li>
<li>在<code>JVM</code>中，每个线程会占用固定大小的栈空间，而<code>JVM</code>的内存空间是有限的，因此如果线程数量过多那么线程本身就会占据过多的资源。</li>
<li>线程的切换成本较高，每次线程切换需要涉及上下文的保存、恢复以及用户态和内核态的切换。如果线程数过多，那么会有较大比例的<code>CPU</code>时间花费在线程切换上。</li>
</ul>
<p>使用线程池的方式解决前两个问题，但是线程切换带来的开销还是存在。所以在高并发的场景下，传统的<code>BIO</code>是无能为力的。而<code>NIO</code>的重要特点是：读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，可以立即返回，这就允许我们不使用多线程充分利用<code>CPU</code>。如果一个连接不能读写，可以把这个事件记录下来，然后切换到别的就绪的连接进行数据读写。在<code>buddha</code>中，<code>Netty</code>被用来编写结构更加清晰的<code>NIO</code>程序。</p>
<h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>在实际应用中，<code>RPC</code>服务的提供者往往需要使用集群来保证服务的稳定性与可靠性。因此需要实现一个服务注册中心，服务提供者将当前可用的服务地址信息注册至注册中心，而客户端在进行远程调用时，先通过服务注册中心获取当前可用的服务列表，然后获取具体的服务提供者的地址信息（该阶段可以进行负载均衡），根据地址信息向服务提供者发起调用。客户端可以缓存可用服务列表，当注册中心的服务列表发生变更时需要通知客户端。同时，当服务提供者变为不可用状态时也需要通知注册中心服务不可用。<code>buddha</code>使用<code>ZooKeeper</code>实现服务注册与发现功能。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>buddha</code>是我学习验证<code>RPC</code>过程中诞生的一个轻量级分布式<code>RPC</code>框架，代码放在了 <a href="https://github.com/tinylcy/buddha" target="_blank" rel="external">GitHub</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://mindwind.me/blog/2016/05/22/RPC-%E7%9A%84%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html" target="_blank" rel="external">RPC 的概念模型与实现解析</a></li>
<li><a href="https://github.com/luxiaoxun/NettyRpc" target="_blank" rel="external">NettyRpc</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;远程过程调用（&lt;code&gt;Remote Procedure Call&lt;/code&gt;，&lt;code&gt;RPC&lt;/code&gt;）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。&lt;code&gt;RPC&lt;/code&gt;的主要
    
    </summary>
    
    
      <category term="DistributedSystems" scheme="http://tinylcy.me/tags/DistributedSystems/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP: Attack Lab</title>
    <link href="http://tinylcy.me/2017/05/06/CSAPP-Attack-Lab/"/>
    <id>http://tinylcy.me/2017/05/06/CSAPP-Attack-Lab/</id>
    <published>2017-05-06T14:38:55.000Z</published>
    <updated>2017-05-06T16:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Attack Lab</code>是<code>CS:APP</code>一书中第三个<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf" target="_blank" rel="external">实验</a>，包括<code>Part I</code>和<code>Part II</code>两部分，分别实现<code>Code Injection Attacks</code>和<code>Return-Oriented Programming</code>。<code>Code Injection Attacks</code>主要利用缓冲区溢出执行不安全的代码片段；当栈被标记为<code>nonexecutable</code>或者位置随机时，可以利用<code>Return-Oriented Programming</code>达到攻击的目的。</p>
<a id="more"></a>
<p>目前的进度是完成了<code>Part I</code>，等有时间再回来完成<code>Part II</code>。</p>
<h2 id="Part-I-Code-Injection-Attacks"><a href="#Part-I-Code-Injection-Attacks" class="headerlink" title="Part I: Code Injection Attacks"></a>Part I: Code Injection Attacks</h2><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p><code>Level 1</code>利用输入字符串使当前执行的代码段跳转到预设的代码片段，不会涉及到<code>code injection</code>：当<code>test()</code>中<code>getbuf()</code>返回后，我们要改变<code>test()</code>正常的执行逻辑，不再执行下一条指令，而是让<code>test()</code>跳转至<code>touch1()</code>执行指令。 <code>test()</code>以及<code>touch1()</code>对应的代码如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    val = getbuf();</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"No exploit. Getbuf returned 0x%x\n"</span>, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    vlevel = <span class="number">1</span>; / * Part of validation protocol * /</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</div><div class="line">    validate(<span class="number">1</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要实现<code>Level 1</code>中的跳转，关键是利用缓冲区溢出来修改<code>test()</code>调用<code>getbuf()</code>时栈帧中的返回地址。使用<code>objdump</code>将<code>ctarget</code>反编译，提取<code>getbuf()</code>关联的的汇编代码，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">00000000004017a8 &lt;getbuf&gt;:</div><div class="line">  4017a8:       48 83 ec 28             sub    $0x28,%rsp</div><div class="line">  4017ac:       48 89 e7                mov    %rsp,%rdi</div><div class="line">  4017af:       e8 8c 02 00 00          callq  401a40 &lt;Gets&gt;</div><div class="line">  4017b4:       b8 01 00 00 00          mov    $0x1,%eax</div><div class="line">  4017b9:       48 83 c4 28             add    $0x28,%rsp</div><div class="line">  4017bd:       c3                      retq</div><div class="line">  4017be:       90                      nop</div><div class="line">  4017bf:       90                      nop</div></pre></td></tr></table></figure>
<p>注意到<code>%rsp</code>被减小了<code>$0x28</code>即<code>40</code>字节，这意味着<code>getbuf()</code>开辟了<code>40</code>字节的缓冲区，而缓冲区以上的<code>4</code>字节则是<code>getbuf()</code>执行<code>ret</code>指令后<code>test()</code>继续执行的指令的地址。<code>Level 1</code>要做的就是利用缓冲区溢出，修改这<code>4</code>字节的值，使之等于<code>touch1()</code>的地址。根据反编译<code>ctarget</code>得到的汇编代码，<code>touch1()</code>的起始地址为<code>0x4017c0</code>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">00000000004017c0 &lt;touch1&gt;:</div><div class="line">  4017c0:       48 83 ec 08             sub    $0x8,%rsp</div><div class="line">  4017c4:       c7 05 0e 2d 20 00 01    movl   $0x1,0x202d0e(%rip)        # 6044dc &lt;vlevel&gt;</div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>综上，<code>Level 1</code>所需的输入字符串长度为<code>44</code>字节，前<code>40</code>字节用于填充缓冲区，具体的值不重要，后<code>4</code>字节等于<code>touch1()</code>的地址值<code>0x4017c0</code>，注意内存存储规则为<code>Little Endian</code>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00</div></pre></td></tr></table></figure>
<p>我们利用<code>hex2raw</code>将输入字符串(<code>level1.txt</code>)转化为字节码，并将字节码文件(<code>level1_bc.txt</code>)作为<code>ctarget</code>的输入，如下图所示。</p>
<p><img src="/img/2017-05-06-Image 1.png" alt=""></p>
<p><code>Level 1</code>通过缓冲区溢出帮助我们理解函数与函数之间跳转的原理，但是并未涉及到参数的传递，这需要通过<code>code injection</code>来实现。</p>
<h3 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h3><p><code>Level 2</code>的流程与<code>Level 1</code>相似：<code>test()</code>调用<code>getbuf()</code>，当<code>getbuf()</code>返回之后，开始执行<code>touch2()</code>的指令。<code>touch2()</code>有着如下的代码逻辑。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></div><div class="line">&#123;</div><div class="line">    vlevel = <span class="number">2</span>; / * Part of validation protocol * /</div><div class="line">    <span class="keyword">if</span> (val == cookie) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</div><div class="line">        validate(<span class="number">2</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</div><div class="line">        fail(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与<code>Level 1</code>不同，<code>Level 2</code>除了需要实现指令跳转，还需要将<code>cookie</code>作为参数传递至<code>touch2()</code>。这意味着需要执行一段我们自定义的代码来实现参数的传递，这就是所谓的<code>code injection</code>。</p>
<p>在<code>Level 1</code>中，我们通过改写返回地址值达到跳转至<code>touch1()</code>的目的，如果我们现在也仅仅是将返回地址修改为<code>touch2()</code>的地址，那么参数传递的问题并没有解决。根据<code>x86-64</code>寄存器使用规范，<code>touch2()</code>的参数<code>val</code>存储于寄存器<code>%rdi</code>，此时<code>%rdi</code>的值并不是我们期望的<code>cookie</code>值。如果在跳转至<code>touch2()</code>执行指令之前，先跳转到某个区域执行一段代码，这段代码能够设置寄存器<code>%rdi</code>的值，然后再跳转到<code>touch2()</code>执行，就可以达到我们的目的。关键是这段代码存储于内存的哪块区域？答案是由<code>getbuf()</code>开辟的缓冲区，也就是<code>Level 1</code>中可以是任意值的<code>40</code>字节。基于以上思路，我们需要明确缓冲区的地址以及待注入的代码。</p>
<p><code>getbuf()</code>调用<code>Gets()</code>函数开辟缓冲区，而<code>Gets()</code>的返回值即是缓冲区的地址，根据<code>x86-64</code>寄存器使用规范，返回值存储于寄存器<code>%rax</code>。利用<code>gdb</code>查看寄存器<code>%rax</code>的值，如下图所示，缓冲区的起始地址为<code>0x5561dc78</code>。</p>
<p><img src="/img/2017-05-06-Image 2.png" alt=""></p>
<p>待注入的代码设置寄存器<code>%rdi</code>的值等于<code>cookie</code>值，然后跳转至<code>touch2()</code>执行指令。用汇编代码来描述，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov $0x59b997fa,%rdi</div><div class="line">pushq $0x4017ec</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>将以上汇编代码进行汇编，然后进行反编译得到机器代码，如下图所示。</p>
<p><img src="/img/2017-05-06-Image 3.png" alt=""></p>
<p>至此，可以写出<code>Level 2</code>所需的输入字符串，如下所示。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55</div></pre></td></tr></table></figure>
<p>利用<code>hex2raw</code>将输入字符串转化为字节码，并将字节码文件作为<code>ctarget</code>的输入，运行结果如下图所示。</p>
<p><img src="/img/2017-05-06-Image 4.png" alt=""></p>
<h3 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h3><p><code>Level 3</code>也需要通过<code>code injection</code>来传递参数。比<code>Level 2</code>更复杂的是，<code>Level 3</code>传递的参数类型是字符串，更确切的说，应该是字符串的地址。与<code>Level 3</code>相关联的<code>touch3()</code>如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></div><div class="line">&#123;</div><div class="line">    vlevel = <span class="number">3</span>; / * Part of validation protocol * /</div><div class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Touch3!: You called touch3(\"%s\")\n"</span>, sval);</div><div class="line">        validate(<span class="number">3</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch3(\"%s\")\n"</span>, sval);</div><div class="line">        fail(<span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到<code>touch3()</code>内部调用了<code>hexmatch()</code>，其代码如下所示。同时，根据<code>hexmatch()</code>的代码逻辑我们推断出<code>touch3()</code>期待的参数为<code>cookie</code>值的字符串表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/ * Compare <span class="built_in">string</span> to hex represention of <span class="keyword">unsigned</span> value * /</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</div><div class="line">    / * Make position of check <span class="built_in">string</span> unpredictable * /</div><div class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</div><div class="line">    <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与<code>Level 2</code>的思路类似，<code>Level 3</code>通过向<code>getbuf()</code>开辟的缓冲区中注入代码来达到设置参数值的目的，但是我们发现<code>touch3()</code>调用了<code>hexmatch()</code>，<code>hexmatch()</code>又调用了<code>strncmp()</code>，这就出现了问题：函数的调用会导致新的数据被<code>push</code>到栈中，这意味着栈中原有的数据会被覆盖。那么，我们传递的参数，也就是字符串，应该存储在内存的什么位置？</p>
<p>基于以上分析，<code>Level 3</code>中待注入的代码与<code>Level 2</code>非常类似，唯一不同的就是<code>Level 2</code>向寄存器<code>%rdi</code>存储的是<code>cookie</code>值，而<code>Level 3</code>向寄存器<code>%rdi</code>存储的是<code>cookie</code>字符串的地址值。我们借助<code>gdb</code>对比<code>touch3()</code>调用<code>hexmatch()</code>前后缓冲区的变化情况，以此定位安全的存储字符串的地址。为此，我们先通过<code>Level 1</code>中的方法进入<code>touch3()</code>，并将指令执行至<code>hexmatch()</code>前一条的指令，如下图所示。</p>
<p><img src="/img/2017-05-06-Image 5.png" alt=""></p>
<p>接着执行<code>callq 0x40184c &lt;hexmatch&gt;</code>指令，对比执行前后缓冲区内容的变化，可以发现缓冲区的    前<code>40</code>个字节并没有连续的<code>8</code>个安全的字节供<code>cookie</code>字符串存储，但是从<code>0x5561dca0</code>开始的<code>40</code>个字节在<code>hexmatch()</code>调用前后并没有发生变化。因此，可以把字符串存储在缓冲区以外的这片内存区域中(我选择以<code>0x5561dca8</code>为首地址的<code>8</code>个字节)。</p>
<p>现在可以将已确定的字符串地址存储至寄存器<code>%rdi</code>，对应的汇编代码如下所示，获取对应机器码的方式与<code>Level 2</code>一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mov $0x5561dca8,%rdi</div><div class="line">pushq $0x4018fa</div><div class="line">ret</div></pre></td></tr></table></figure>
<p>同时，<code>Level 3</code>的输入字符串需要根据字符串的存储地址做相应的补充，由于字符串的首地址为<code>0x5561dca8</code>，且字符串长度为<code>8</code>，因此输入字符串的总长度为<code>56</code>字节，如下所示。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61</div></pre></td></tr></table></figure>
<p>借助<code>hex2raw</code>将输入字符串转化为字节码，并将其作为<code>ctarget</code>的输入，结果如下图所示。</p>
<p><img src="/img/2017-05-06-Image 6.png" alt=""></p>
<h2 id="Part-II-Return-Oriented-Programming"><a href="#Part-II-Return-Oriented-Programming" class="headerlink" title="Part II: Return-Oriented Programming"></a>Part II: Return-Oriented Programming</h2><h3 id="TODO"><a href="#TODO" class="headerlink" title="// TODO"></a>// TODO</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Attack Lab&lt;/code&gt;是&lt;code&gt;CS:APP&lt;/code&gt;一书中第三个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/attacklab.pdf&quot;&gt;实验&lt;/a&gt;，包括&lt;code&gt;Part I&lt;/code&gt;和&lt;code&gt;Part II&lt;/code&gt;两部分，分别实现&lt;code&gt;Code Injection Attacks&lt;/code&gt;和&lt;code&gt;Return-Oriented Programming&lt;/code&gt;。&lt;code&gt;Code Injection Attacks&lt;/code&gt;主要利用缓冲区溢出执行不安全的代码片段；当栈被标记为&lt;code&gt;nonexecutable&lt;/code&gt;或者位置随机时，可以利用&lt;code&gt;Return-Oriented Programming&lt;/code&gt;达到攻击的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://tinylcy.me/tags/CSAPP/"/>
    
      <category term="Assembly" scheme="http://tinylcy.me/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>6.824 Lab 1: MapReduce</title>
    <link href="http://tinylcy.me/2017/05/03/6-824-Lab-1-MapReduce/"/>
    <id>http://tinylcy.me/2017/05/03/6-824-Lab-1-MapReduce/</id>
    <published>2017-05-03T14:25:41.000Z</published>
    <updated>2017-05-12T05:11:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习大名鼎鼎的<a href="http://nil.csail.mit.edu/6.824/2016/index.html" target="_blank" rel="external">MIT 6.824: Distributed Systems</a>课程，我跟的是<code>2016</code>年的课程，课程的主要内容是读<code>Paper</code>和做<code>Lab</code>，使用的语言为<code>Go</code>。五一假期期间我基本做完了<a href="http://nil.csail.mit.edu/6.824/2016/labs/lab-1.html" target="_blank" rel="external">Lab 1</a>，感觉难度还是相当大的。本篇文章是我对<code>Lab 1</code>的一个总结。</p>
<a id="more"></a>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>每次读<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce</a>论文，都会有新的收获，也自知还有理解不到位的地方。</p>
<h3 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h3><ul>
<li>输入数据被划分为<code>M</code>个分片，由<code>map worker</code>产生的中间<code>key-value pairs</code>被划分为<code>R</code>个分片。其中<code>M</code>的大小取决于<code>GFS</code>块的大小，<code>R</code>取决于<code>reduce worker</code>的个数。所以，整个<code>MapReduce Job</code>包括<code>M</code>个<code>map task</code>和<code>R</code>个<code>reduce task</code>。</li>
<li>在<code>map</code>阶段，<code>map worker</code>把输出的中间<code>key-value pairs</code>分割成<code>R</code>个<code>region</code>，注意<code>pairs</code>首先会存储在缓冲区中，然后定期的写入本地磁盘。<code>pairs</code>在<code>map worker</code>上的位置信息会发送给<code>master</code>，由<code>master</code>通知<code>reduce worker</code>数据读取位置信息。</li>
<li>在<code>reduce</code>阶段，当<code>reduce worker</code>获取了输入数据的位置信息后，通过<code>RPC</code>读取数据。当<code>reduce worker</code>获取了所有的相关数据之后，会对它们进行一次排序，排序的目的在于不同<code>key</code>的<code>pairs</code>会汇聚到同一个<code>reduce worker</code>。</li>
<li>当所有的<code>task</code>完成后，一共会产生<code>R</code>个输出文件，每个<code>reduce worker</code>对应一个。一般来说没有必要将这<code>R</code>个文件合并成一个文件，因为这<code>R</code>个文件往往会作为下一个<code>MapReduce Job</code>的输入数据。</li>
</ul>
<h3 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h3><ul>
<li><code>master</code>会记录所有<code>map task</code>和<code>reduce task</code>的状态(<code>idle</code>，<code>in-progress</code>和<code>completed</code>)信息。同时，<code>master</code>还会保存那些处于<code>non-idle</code>状态的<code>task</code>所关联的<code>worker</code>的信息。</li>
<li>对于每个状态为<code>completed</code>的<code>map task</code>，<code>master</code>会保存该<code>map task</code>对应的<code>R</code>个<code>region</code>的位置信息和大小信息。</li>
</ul>
<h3 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h3><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><ul>
<li><code>master</code>通过周期性的<code>ping</code>所有的<code>worker</code>来确认<code>worker</code>是否可用，如果某个<code>worker</code>崩溃了，那么在该<code>worker</code>上完成的所有<code>map task</code>都会回退到<code>idle</code>状态，因此这些<code>task</code>会被重新调度到可用的<code>worker</code>上。同理，如果处于<code>in-progress</code>的<code>map task</code>或<code>reduce task</code>所在的<code>worker</code>崩溃了，那么这些<code>task</code>也会被重新调度到可用的<code>worker</code>上重新执行。</li>
<li>如果某个<code>worker</code>崩溃了，其上处于<code>completed</code>状态的<code>map task</code>需要重新被调度执行，这是因为<code>map task</code>的输出数据是存储于<code>local disk</code>。相反，如果某个<code>worker</code>崩溃了，其上处于<code>completed</code>状态的<code>reduce task</code>不需要重新被调度执行，因为<code>reduce task</code>的输出数据是存储在<code>global file system</code>上的。</li>
<li>当<code>reduce worker</code>在执行<code>reduce task</code>时，如果某个<code>map task</code>对应的<code>worker</code>由<code>worker A</code>切换到了<code>worker B</code>(可能是因为<code>worker A</code>崩溃了)，那么<code>master</code>会通知该<code>reduce worker</code>从<code>worker B</code>读取数据。</li>
</ul>
<h4 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h4><ul>
<li><code>master</code>通过定期的做<code>checkpoints</code>来保证<code>master</code>的容错性。</li>
<li>由于<code>master</code>只有一个，所以可以认为<code>master</code>出故障的概率很小。如果真的出故障了，那么根据需要重新执行<code>MapReduce Job</code>。</li>
</ul>
<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p><code>Lab 1</code>包括<code>4</code>个<code>Part</code>，<code>Part 1 &amp; Part 2</code>实现<code>Sequential MapReduce</code>，<code>Part 3 &amp; Part 4</code>实现<code>Distributed MapReduce</code>，并且要解决<code>worker failure</code>。同时，<code>Lab 1</code>提供了<code>MapReduce</code>的整个框架，并实现了与核心内容无关的代码。在完成各个<code>Part</code>之前，我们需要理解<code>Lab 1</code>实现的两个版本的<code>MapReduce</code>框架的设计思路。</p>
<ul>
<li><code>master</code>和<code>worker</code>以<code>goroutine</code>的形式存在，当<code>worker</code>可用时，以<code>RPC</code>的方式向<code>master</code>注册，<code>master</code>通过调用<code>schedule()</code>来实现<code>task</code>的调度。同时，在<code>Distributed MapReduce</code>中<code>schedule()</code>还需要处理<code>worker failure</code>。<code>schedule()</code>将会以参数的形式存在于<code>Sequential/Distributed MapReduce</code>。</li>
<li>论文中<code>map task</code>以块作为分割，而<code>Lab</code>中的<code>map task</code>将以文件作为分割。</li>
<li>在<code>map</code>阶段，对于每个<code>map task</code>(一个输入文件)，<code>master</code>会至少调用一次<code>doMap()</code>。同理在<code>reduce</code>阶段，<code>master</code>对每个<code>reduce task</code>至少调用一次<code>doReduce()</code>。在<code>Sequential MapReduce</code>中，<code>Sequential()</code>[<code>master.go</code>]的核心参数<code>schedule()</code>遍历了<code>file slice</code>，根据当前所处的<code>phase</code>对每个<code>task</code>调用<code>doMap()</code>或<code>doReduce()</code>。在<code>Distributed MapReduce</code>中，<code>Distributed()</code>[<code>master.go</code>]的核心参数<code>schedule()</code>需要我们去实现(<code>Part 3 &amp; Part 4</code>)。</li>
<li>在完成了所有的<code>map task</code>和<code>reduce task</code>之后，<code>master</code>会调用<code>merge()</code>对<code>reduce worker</code>的输出文件进行合并。</li>
<li>最后<code>master</code>向每个<code>worker</code>发送<code>Shutdown RPC</code>，然后关闭整个应用。</li>
</ul>
<p>理解完整个<code>Lab</code>的框架，下面谈谈每个<code>Part</code>需要注意的地方。</p>
<h3 id="Part-1-Map-Reduce-input-and-output"><a href="#Part-1-Map-Reduce-input-and-output" class="headerlink" title="Part 1: Map/Reduce input and output"></a>Part 1: Map/Reduce input and output</h3><p><code>Part 1</code>主要的内容是完成<code>doMap()</code>和<code>doReduce()</code>，在编码前一定要仔细阅读注释给我们提供的信息。</p>
<ul>
<li><code>doMap()</code>读取输入文件(<code>inFile</code>)的内容，通过<code>mapF</code>将其转化为<code>[]KeyValue</code>。对于每个<code>inFile</code>，<code>doMap</code>将产生<code>nReduce</code>(对应于论文中的<code>R</code>)个输出文件。同时，数据以<code>JSON</code>的格式存储至输出文件中。</li>
<li><code>doReduce()</code>从<code>nMap</code>(对应于论文中的<code>M</code>)个<code>map worker</code>读取输入数据(<code>[]KeyValue</code>)，注意输入数据的格式为<code>JSON</code>。根据<code>key</code>构建出<code>map[key]values</code>数据结构，对每个<code>key</code>(<code>string</code>)和对应的<code>values</code>(<code>[]string</code>)调用<code>reduceF()</code>。<code>doReduce()</code>产生一个输出文件。</li>
</ul>
<h3 id="Part-2-Single-worker-word-count"><a href="#Part-2-Single-worker-word-count" class="headerlink" title="Part 2: Single-worker word count"></a>Part 2: Single-worker word count</h3><p><code>Part 2</code>实现经典的<code>WordCount</code>，需要我们实现<code>mapF</code>和<code>reduceF</code>中的逻辑。需要注意的是要按照<code>Lab</code>提供的切词规范(<code>determined by unicode.IsLetter</code>)去分词，而不要想当然的用空格作为分隔符。</p>
<h3 id="Part-3-Distributing-MapReduce-tasks"><a href="#Part-3-Distributing-MapReduce-tasks" class="headerlink" title="Part 3: Distributing MapReduce tasks"></a>Part 3: Distributing MapReduce tasks</h3><p><code>Part 3</code>着手实现<code>Distributed MapReduce</code>，为了模拟真正的分布式环境，<code>master</code>和<code>worker</code>之间的通信和同步仅通过<code>RPC</code>和<code>channel</code>来实现。<code>Part 3</code>需要我们实现<code>schedule()</code>的调度逻辑。</p>
<ul>
<li><code>Distributed MapReduce</code>的实现逻辑在上文已有所提及，<code>Sequential MapReduce</code>顺序调度每个<code>task</code>执行，而在<code>Distributed MapReduce</code>中，<code>schedule()</code>将<code>task</code>调度到当前可用的<code>worker</code>上去执行。</li>
<li>只有当<code>map/reduce</code>阶段所有的<code>task</code>全部完成后，<code>schedule()</code>才能返回。这一点在代码中我是通过<code>sync.WaitGroup</code>来实现。</li>
<li>在分布式环境下，<code>schedule()</code>通过<code>RPC</code>调度<code>worker</code>执行<code>task</code>，同时输入文件的信息也是作为<code>RPC</code>参数传递。</li>
<li>当前可用的<code>worker</code>存储于<code>master</code>的<code>registerChannel</code>中。如果当前没有可用的<code>worker</code>，那么<code>schedule()</code>会进入阻塞状态，直至出现新的可用的<code>worker</code>。只有当存在可用的<code>worker</code>时才允许创建<code>goroutine</code>执行<code>task</code>(这一点体现在<code>schedule.go</code>的<code>line 38</code>和<code>line 42</code>)。</li>
</ul>
<h3 id="Part-4-Handling-worker-failures"><a href="#Part-4-Handling-worker-failures" class="headerlink" title="Part 4: Handling worker failures"></a>Part 4: Handling worker failures</h3><p><code>Part 4</code>需要解决<code>worker failure</code>，映射到具体的代码实现上，<code>work failure</code>是指在进行<code>RPC</code>时，<code>RPC</code>服务器返回了<code>call failed</code>信息。根据论文，我们只需要将<code>task</code>重新分配给另一个可用的<code>worker</code>，并将上次<code>RPC</code>失败的输入文件信息作为本次<code>RPC</code>的参数传递。</p>
<p>需要注意的是，<code>RPC</code>失败并不一定意味着<code>worker</code>崩溃了，也有可能是因为网络原因导致<code>worker</code>不可达，所以有可能导致多个<code>worker</code>在执行着相同的<code>task</code>。不过由于<code>task</code>的幂等性，这并没有什么问题，<code>master</code>记录着每个<code>task</code>对应的真正有效的<code>worker</code>。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p><code>Lab 1</code>的代码实现在<a href="https://github.com/tinylcy/mit-6.824" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习大名鼎鼎的&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2016/index.html&quot;&gt;MIT 6.824: Distributed Systems&lt;/a&gt;课程，我跟的是&lt;code&gt;2016&lt;/code&gt;年的课程，课程的主要内容是读&lt;code&gt;Paper&lt;/code&gt;和做&lt;code&gt;Lab&lt;/code&gt;，使用的语言为&lt;code&gt;Go&lt;/code&gt;。五一假期期间我基本做完了&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2016/labs/lab-1.html&quot;&gt;Lab 1&lt;/a&gt;，感觉难度还是相当大的。本篇文章是我对&lt;code&gt;Lab 1&lt;/code&gt;的一个总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DistributedSystems" scheme="http://tinylcy.me/tags/DistributedSystems/"/>
    
      <category term="6.824" scheme="http://tinylcy.me/tags/6-824/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP: Bomb Lab</title>
    <link href="http://tinylcy.me/2017/04/26/CSAPP-Bomb-Lab/"/>
    <id>http://tinylcy.me/2017/04/26/CSAPP-Bomb-Lab/</id>
    <published>2017-04-26T11:14:51.000Z</published>
    <updated>2017-05-06T16:37:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Bomb Lab</code>是<code>CS:APP</code>一书中第二个<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf" target="_blank" rel="external">实验</a>，实验中的<code>bomb</code>实际上是一个程序的二进制文件，该程序由一系列<code>phase</code>组成，每个<code>phase</code>需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印<code>BOOM!!!</code>。</p>
<a id="more"></a>
<p>完成整个实验的思路是通过<code>objdump</code>对<code>bome</code>进行反编译（<code>objdump -d bomb &gt; bomb.txt</code>），获取所有的汇编代码。提取每个阶段对应的代码并借助<code>gdb</code>进行分析，逐一拆弹。</p>
<h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><p><code>phase_1</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">0000000000400ee0 &lt;phase_1&gt;:</div><div class="line">  400ee0: 48 83 ec 08           sub    $0x8,%rsp</div><div class="line">  400ee4: be 00 24 40 00        mov    $0x402400,%esi</div><div class="line">  400ee9: e8 4a 04 00 00        callq  401338 &lt;strings_not_equal&gt;</div><div class="line">  400eee: 85 c0                 test   %eax,%eax</div><div class="line">  400ef0: 74 05                 je     400ef7 &lt;phase_1+0x17&gt;</div><div class="line">  400ef2: e8 43 05 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400ef7: 48 83 c4 08           add    $0x8,%rsp</div><div class="line">  400efb: c3                    retq</div></pre></td></tr></table></figure>
<p>由<code>callq</code>指令可以得知，<code>phase_1</code>调用了<code>strings_not_equal</code>，并将返回值存储于<code>%eax</code>中，<code>test</code>指令计算<code>%eax</code>的值是否等于<code>0</code>，<code>je</code>指令决定是否跳转，若<code>%eax</code>的值等于<code>0</code>，则跳转至<code>0x400ef7</code>处，也就是安全区域，拆弹成功，否则不跳转，即执行<code>explode_bomb</code>，拆弹失败。通过以上分析，可以得知<code>phase_1</code>的关键在于控制<code>strings_not_equal</code>的返回值。</p>
<p>在执行<code>callq strings_not_equal</code>指令之前，<code>mov $0x402400,%esi</code>将常数<code>0x402400</code>传递至<code>%esi</code>，根据<code>x86-64</code>寄存器使用规范，<code>%esi</code>的值是<code>strings_not_equal</code>函数的第二个参数，而第一个参数则是我们输入的值。因此，问题的关键在于如何得到<code>%esi</code>的值。</p>
<p>利用<code>gdb</code>对<code>bomb</code>进行调试，并在<code>phase_1</code>处设置断点，通过<code>disassemble</code>对当前函数进行反编译，使用<code>stepi</code>对指令进行单步调试，运行至<code>phase_1</code>第一条指令的初始状态如下图所示。</p>
<p><img src="/img/2017-04-26-Image 1.png" alt=""></p>
<p>在进入<code>phase_1</code>之前，<code>read_line</code>函数从终端读取输入（可从<code>bomb.c</code>得知该信息，我输入的是<code>tinylcy</code>）。接着，通过<code>stepi</code>单步执行指令，直至指令<code>mov $0x402400,%esi</code>执行完毕，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 2.png" alt=""></p>
<p>此时，<code>strings_not_equal</code>函数的第二个参数已经存储于<code>%esi</code>，通过<code>print</code>打印<code>%esi</code>的值，可以得知<code>%esi</code>存储的是一个内存地址，这是因为参数类型是字符串类型，因此寄存器存储的是内存地址，而非确切的字符串值，使用<code>x</code>打印位于地址<code>%esi</code>处的内容，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 3.png" alt=""></p>
<p>由此，我们得到了拆除<code>pahse_1</code>炸弹所需要的字符串。</p>
<h2 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h2><p><code>phase_2</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">0000000000400efc &lt;phase_2&gt;:</div><div class="line">  400efc: 55                    push   %rbp</div><div class="line">  400efd: 53                    push   %rbx</div><div class="line">  400efe: 48 83 ec 28           sub    $0x28,%rsp</div><div class="line">  400f02: 48 89 e6              mov    %rsp,%rsi</div><div class="line">  400f05: e8 52 05 00 00        callq  40145c &lt;read_six_numbers&gt;</div><div class="line">  400f0a: 83 3c 24 01           cmpl   $0x1,(%rsp)</div><div class="line">  400f0e: 74 20                 je     400f30 &lt;phase_2+0x34&gt;</div><div class="line">  400f10: e8 25 05 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400f15: eb 19                 jmp    400f30 &lt;phase_2+0x34&gt;</div><div class="line">  400f17: 8b 43 fc              mov    -0x4(%rbx),%eax</div><div class="line">  400f1a: 01 c0                 add    %eax,%eax</div><div class="line">  400f1c: 39 03                 cmp    %eax,(%rbx)</div><div class="line">  400f1e: 74 05                 je     400f25 &lt;phase_2+0x29&gt;</div><div class="line">  400f20: e8 15 05 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400f25: 48 83 c3 04           add    $0x4,%rbx</div><div class="line">  400f29: 48 39 eb              cmp    %rbp,%rbx</div><div class="line">  400f2c: 75 e9                 jne    400f17 &lt;phase_2+0x1b&gt;</div><div class="line">  400f2e: eb 0c                 jmp    400f3c &lt;phase_2+0x40&gt;</div><div class="line">  400f30: 48 8d 5c 24 04        lea    0x4(%rsp),%rbx</div><div class="line">  400f35: 48 8d 6c 24 18        lea    0x18(%rsp),%rbp</div><div class="line">  400f3a: eb db                 jmp    400f17 &lt;phase_2+0x1b&gt;</div><div class="line">  400f3c: 48 83 c4 28           add    $0x28,%rsp</div><div class="line">  400f40: 5b                    pop    %rbx</div><div class="line">  400f41: 5d                    pop    %rbp</div><div class="line">  400f42: c3                    retq</div></pre></td></tr></table></figure>
<p>由<code>callq read_six_numbers</code>可知，<code>phase_2</code>调用了<code>read_six_numbers</code>函数并读取了<code>6</code>个数值。根据<code>cmpl $0x1,(%rsp)</code>可知，若地址<code>%rsp</code>处的值等于<code>1</code>，那么进入安全区域，否则就会引爆炸弹。由此可以得知，我们输入的第<code>1</code>个数字应该为<code>1</code>。然后<code>phase_2</code>跳转至<code>0x400f30</code>处执行指令<code>lea 0x4(%rsp),%rbx</code>，该指令的效果是将<code>%rsp</code>的值加<code>4</code>并存储于<code>%rbx</code>，这意味着<code>%rbx</code>的值实际上是下一个数的地址值。<code>lea 0x18(%rsp),%rbp</code>用于控制循环的次数，<code>6</code>个整型共占用<code>24</code>字节，恰好等于<code>0x18</code>。接着<code>phase_2</code>跳转至<code>0x400f17</code>处执行<code>mov -0x4(%rbx),%eax</code>指令，该指令的效果是使<code>%eax</code>的值等于<code>M[%rbx-4]</code>的值，即<code>M[%rsp]</code>的值，也就是第<code>1</code>个数的值。<code>add %eax,%eax</code>使<code>%eax</code>的值扩大为原来的<code>2</code>倍，<code>cmp %eax,(%rbx)</code>将下一个数的值与<code>%eax</code>的值作比较，若相等则跳转至安全区域<code>0x400f25</code>，否则拆弹失败。<code>0x400f25</code>处的指令为<code>add $0x4,%rbx</code>，该指令的效果是使<code>%rbx</code>存储下一个数的地址，与<code>%rbp</code>的值比较并在不相等的情况下跳转至<code>0x400f17</code>处循环执行指令。</p>
<p>综上，<code>phase_2</code>通过<code>%rbx</code>来获取输入的<code>6</code>个数字，通过<code>%eax</code>来控制比较的数值大小，<code>%eax</code>初始化为第<code>1</code>个数字的值，并在每次循环后增长至原来的<code>2</code>倍，一共<code>6</code>次循环。所以<code>phase_2</code>的解为<code>1 2 4 8 16 32</code>。</p>
<h2 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase 3"></a>Phase 3</h2><p><code>phase_3</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">0000000000400f43 &lt;phase_3&gt;:</div><div class="line">  400f43: 48 83 ec 18           sub    $0x18,%rsp</div><div class="line">  400f47: 48 8d 4c 24 0c        lea    0xc(%rsp),%rcx</div><div class="line">  400f4c: 48 8d 54 24 08        lea    0x8(%rsp),%rdx</div><div class="line">  400f51: be cf 25 40 00        mov    $0x4025cf,%esi</div><div class="line">  400f56: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  400f5b: e8 90 fc ff ff        callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</div><div class="line">  400f60: 83 f8 01              cmp    $0x1,%eax</div><div class="line">  400f63: 7f 05                 jg     400f6a &lt;phase_3+0x27&gt;</div><div class="line">  400f65: e8 d0 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400f6a: 83 7c 24 08 07        cmpl   $0x7,0x8(%rsp)</div><div class="line">  400f6f: 77 3c                 ja     400fad &lt;phase_3+0x6a&gt;</div><div class="line">  400f71: 8b 44 24 08           mov    0x8(%rsp),%eax</div><div class="line">  400f75: ff 24 c5 70 24 40 00  jmpq   *0x402470(,%rax,8)</div><div class="line">  400f7c: b8 cf 00 00 00        mov    $0xcf,%eax</div><div class="line">  400f81: eb 3b                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f83: b8 c3 02 00 00        mov    $0x2c3,%eax</div><div class="line">  400f88: eb 34                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f8a: b8 00 01 00 00        mov    $0x100,%eax</div><div class="line">  400f8f: eb 2d                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f91: b8 85 01 00 00        mov    $0x185,%eax</div><div class="line">  400f96: eb 26                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f98: b8 ce 00 00 00        mov    $0xce,%eax</div><div class="line">  400f9d: eb 1f                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400f9f: b8 aa 02 00 00        mov    $0x2aa,%eax</div><div class="line">  400fa4: eb 18                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400fa6: b8 47 01 00 00        mov    $0x147,%eax</div><div class="line">  400fab: eb 11                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400fad: e8 88 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400fb2: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  400fb7: eb 05                 jmp    400fbe &lt;phase_3+0x7b&gt;</div><div class="line">  400fb9: b8 37 01 00 00        mov    $0x137,%eax</div><div class="line">  400fbe: 3b 44 24 0c           cmp    0xc(%rsp),%eax</div><div class="line">  400fc2: 74 05                 je     400fc9 &lt;phase_3+0x86&gt;</div><div class="line">  400fc4: e8 71 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  400fc9: 48 83 c4 18           add    $0x18,%rsp</div><div class="line">  400fcd: c3                    retq</div></pre></td></tr></table></figure>
<p>前<code>3</code>条指令非常普通，并不能吸引我们的注意，能够吸引我们的是<code>mov $0x4025cf,%esi</code>这条指令，常数<code>0x4025cf</code>应该是个内存地址，打印该内存地址的值，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 4.png" alt=""></p>
<p>很容易把<code>%d %d</code>与<code>callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</code>这条指令联系起来，由此我们基本知道，<code>phase_3</code>会输入<code>2</code>个值。<code>scanf</code>函数的返回值存储于<code>%eax</code>，该值代表输入值的个数，<code>cmp $0x1,%eax</code>将<code>%eax</code>的值与<code>1</code>做比较，如果输入值的个数大于<code>1</code>，跳转至安全区域，即指令<code>cmpl $0x7,0x8(%rsp)</code>处，否则拆弹失败。<code>cmpl   $0x7,0x8(%rsp)</code>将输入的第一个数(以<code>6</code>为例)与<code>7</code>作比较，如果大于<code>7</code>，那么拆弹失败，否则执行指令<code>mov 0x8(%rsp),%eax</code>，该指令将第一个数存储于<code>%eax</code>中。接着执行指令<code>jmpq *0x402470(,%rax,8)</code>，该指令是一个间接跳转指令，通过<code>gdb</code>得到执行该指令后的跳转位置，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 5.png" alt=""></p>
<p><code>mov $0x2aa,%eax</code>指令将常数<code>0x2aa</code>移至<code>%eax</code>，然后执行<code>jmp 0x400fbe &lt;phase_3+123&gt;</code>跳转至<code>0x400fbe</code>处执行指令<code>cmp 0xc(%rsp),%eax</code>，该指令将第二个数与<code>%eax</code>做比较，若相等，安全退出，拆弹成功，否则拆弹失败。<code>0x2aa</code>的十进制值为<code>682</code>，因此<code>phase_3</code>输入的两个数应为<code>6</code>，<code>682</code>。</p>
<p>注意，第一个数并不一定是<code>6</code>，只要小于<code>7</code>即可。当第一个数的取值改变，那么在获取第二个数时会跳转到不同的分支，因此会得到不同的值。例如当第一个数等于<code>5</code>，那么第二个数应为<code>206</code>。</p>
<h2 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase 4"></a>Phase 4</h2><p><code>phase_4</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">000000000040100c &lt;phase_4&gt;:</div><div class="line">  40100c: 48 83 ec 18           sub    $0x18,%rsp</div><div class="line">  401010: 48 8d 4c 24 0c        lea    0xc(%rsp),%rcx</div><div class="line">  401015: 48 8d 54 24 08        lea    0x8(%rsp),%rdx</div><div class="line">  40101a: be cf 25 40 00        mov    $0x4025cf,%esi</div><div class="line">  40101f: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  401024: e8 c7 fb ff ff        callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</div><div class="line">  401029: 83 f8 02              cmp    $0x2,%eax</div><div class="line">  40102c: 75 07                 jne    401035 &lt;phase_4+0x29&gt;</div><div class="line">  40102e: 83 7c 24 08 0e        cmpl   $0xe,0x8(%rsp)</div><div class="line">  401033: 76 05                 jbe    40103a &lt;phase_4+0x2e&gt;</div><div class="line">  401035: e8 00 04 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  40103a: ba 0e 00 00 00        mov    $0xe,%edx</div><div class="line">  40103f: be 00 00 00 00        mov    $0x0,%esi</div><div class="line">  401044: 8b 7c 24 08           mov    0x8(%rsp),%edi</div><div class="line">  401048: e8 81 ff ff ff        callq  400fce &lt;func4&gt;</div><div class="line">  40104d: 85 c0                 test   %eax,%eax</div><div class="line">  40104f: 75 07                 jne    401058 &lt;phase_4+0x4c&gt;</div><div class="line">  401051: 83 7c 24 0c 00        cmpl   $0x0,0xc(%rsp)</div><div class="line">  401056: 74 05                 je     40105d &lt;phase_4+0x51&gt;</div><div class="line">  401058: e8 dd 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  40105d: 48 83 c4 18           add    $0x18,%rsp</div><div class="line">  401061: c3                    retq</div></pre></td></tr></table></figure>
<p>和<code>phase_3</code>类似，首先将内存地址为<code>0x4025cf</code>的内容打印出来，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 6.png" alt=""></p>
<p>由此得知，<code>phase_4</code>的输入应该为<code>2</code>个整数。在执行<code>callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</code>指令后，返回值存储于<code>%eax</code>，然后判断<code>%eax</code>的值是否等于<code>2</code>，若不等于则会引爆炸弹，否则执行指令<code>cmpl $0xe,0x8(%rsp)</code>，该指令将输入的第一个数与常数<code>0xe</code>做比较，根据<code>jbe 40103a &lt;phase_4+0x2e&gt;</code>，如果输入的第一个数大于<code>0xe</code>，那么拆弹失败，否则跳转到<code>0x40103a</code>处执行<code>mov $0xe,%edx</code>指令。接下来可以看到<code>phase_4</code>调用了函数<code>func4</code>，而<code>mov $0xe,%edx</code>、<code>mov $0x0,%esi</code>和<code>mov 0x8(%rsp),%edi</code>这三条指令用于设置<code>func4</code>的参数，根据<code>x86-64</code>寄存器使用规范，第一个、第二个和第三个参数分别存储于寄存器<code>%edi</code>、<code>%esi</code>和<code>%edx</code>。</p>
<p>在查看<code>func4</code>对应的代码之前，先观察执行<code>callq  400fce &lt;func4&gt;</code>指令之后<code>phase_4</code>的操作：<code>test %eax,%eax</code>指令检查<code>%eax</code>的值是否等于<code>0</code>，如果不等于<code>0</code>，则会引爆炸弹，否则执行指令<code>cmpl $0x0,0xc(%rsp)</code>，该指令将输入的第二个数与<code>0</code>做比较，如果相等，那么<code>phase_4</code>正常退出，拆弹成功。因此，<code>phase_4</code>的第二个输入值即为<code>0</code>。</p>
<p>经过以上的分析，可以意识到<code>phase_4</code>的核心目标在于要让<code>func4</code>执行后，<code>%eax</code>的值等于<code>0</code>，这取决于输入的第一个数。接着需要分析<code>func4</code>执行的操作，其对应代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">0000000000400fce &lt;func4&gt;:</div><div class="line">  400fce: 48 83 ec 08           sub    $0x8,%rsp</div><div class="line">  400fd2: 89 d0                 mov    %edx,%eax</div><div class="line">  400fd4: 29 f0                 sub    %esi,%eax</div><div class="line">  400fd6: 89 c1                 mov    %eax,%ecx</div><div class="line">  400fd8: c1 e9 1f              shr    $0x1f,%ecx</div><div class="line">  400fdb: 01 c8                 add    %ecx,%eax</div><div class="line">  400fdd: d1 f8                 sar    %eax</div><div class="line">  400fdf: 8d 0c 30              lea    (%rax,%rsi,1),%ecx</div><div class="line">  400fe2: 39 f9                 cmp    %edi,%ecx</div><div class="line">  400fe4: 7e 0c                 jle    400ff2 &lt;func4+0x24&gt;</div><div class="line">  400fe6: 8d 51 ff              lea    -0x1(%rcx),%edx</div><div class="line">  400fe9: e8 e0 ff ff ff        callq  400fce &lt;func4&gt;</div><div class="line">  400fee: 01 c0                 add    %eax,%eax</div><div class="line">  400ff0: eb 15                 jmp    401007 &lt;func4+0x39&gt;</div><div class="line">  400ff2: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  400ff7: 39 f9                 cmp    %edi,%ecx</div><div class="line">  400ff9: 7d 0c                 jge    401007 &lt;func4+0x39&gt;</div><div class="line">  400ffb: 8d 71 01              lea    0x1(%rcx),%esi</div><div class="line">  400ffe: e8 cb ff ff ff        callq  400fce &lt;func4&gt;</div><div class="line">  401003: 8d 44 00 01           lea    0x1(%rax,%rax,1),%eax</div><div class="line">  401007: 48 83 c4 08           add    $0x8,%rsp</div><div class="line">  40100b: c3                    retq</div></pre></td></tr></table></figure>
<p>在分析<code>func4</code>之前，不要忘了传递到<code>func4</code>的三个参数分别存储于寄存器<code>%edi</code>、<code>%esi</code>和<code>%edx</code>，其值分别为<code>x</code>(输入的第一个数)、<code>0</code>和<code>14</code>。在<code>0x400fe9</code>处执行了指令<code>callq 400fce &lt;func4&gt;</code>，因此<code>func4</code>很可能是个递归函数，我们将<code>func4</code>翻译成等价的<code>C</code>代码，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> t = z - y;</div><div class="line">    <span class="keyword">int</span> k = t &gt;&gt; <span class="number">31</span>;</div><div class="line">    t = (t + k) &gt;&gt; <span class="number">1</span>;</div><div class="line">    k = t + y;</div><div class="line">    <span class="keyword">if</span>(k &lt;= x) &#123;</div><div class="line">        t = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span>(k &gt;= x) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            y = k + <span class="number">1</span>;</div><div class="line">            func4(x, y, z);</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        z = k - <span class="number">1</span>;</div><div class="line">        func4(x, y, z);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>func4</code>的目的是要让函数退出后<code>%eax</code>的值为<code>0</code>，而在<code>0x400ff2</code>处<code>mov $0x0,%eax</code>显示的将<code>%eax</code>的值设置为<code>0</code>，该指令对应于<code>C</code>代码中的<code>t = 0</code>。并且，<code>func4</code>执行递归的退出条件为<code>k == x</code>，其中<code>x</code>对应于输入的第一个数，而<code>k</code>则可以通过一系列计算得到，由于<code>y = 0</code>且<code>z = 14</code>，易知<code>k = 7</code>，因此输入的第一个数即为<code>7</code>。将字符串<code>7 0</code>作为<code>phase_4</code>的输入，拆弹成功，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 7.png" alt=""></p>
<h2 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase 5"></a>Phase 5</h2><p><code>phase_5</code>对应的代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">0000000000401062 &lt;phase_5&gt;:</div><div class="line">  401062: 53                    push   %rbx</div><div class="line">  401063: 48 83 ec 20           sub    $0x20,%rsp</div><div class="line">  401067: 48 89 fb              mov    %rdi,%rbx</div><div class="line">  40106a: 64 48 8b 04 25 28 00  mov    %fs:0x28,%rax</div><div class="line">  401071: 00 00 </div><div class="line">  401073: 48 89 44 24 18        mov    %rax,0x18(%rsp)</div><div class="line">  401078: 31 c0                 xor    %eax,%eax</div><div class="line">  40107a: e8 9c 02 00 00        callq  40131b &lt;string_length&gt;</div><div class="line">  40107f: 83 f8 06              cmp    $0x6,%eax</div><div class="line">  401082: 74 4e                 je     4010d2 &lt;phase_5+0x70&gt;</div><div class="line">  401084: e8 b1 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  401089: eb 47                 jmp    4010d2 &lt;phase_5+0x70&gt;</div><div class="line">  40108b: 0f b6 0c 03           movzbl (%rbx,%rax,1),%ecx</div><div class="line">  40108f: 88 0c 24              mov    %cl,(%rsp)</div><div class="line">  401092: 48 8b 14 24           mov    (%rsp),%rdx</div><div class="line">  401096: 83 e2 0f              and    $0xf,%edx</div><div class="line">  401099: 0f b6 92 b0 24 40 00  movzbl 0x4024b0(%rdx),%edx</div><div class="line">  4010a0: 88 54 04 10           mov    %dl,0x10(%rsp,%rax,1)</div><div class="line">  4010a4: 48 83 c0 01           add    $0x1,%rax</div><div class="line">  4010a8: 48 83 f8 06           cmp    $0x6,%rax</div><div class="line">  4010ac: 75 dd                 jne    40108b &lt;phase_5+0x29&gt;</div><div class="line">  4010ae: c6 44 24 16 00        movb   $0x0,0x16(%rsp)</div><div class="line">  4010b3: be 5e 24 40 00        mov    $0x40245e,%esi</div><div class="line">  4010b8: 48 8d 7c 24 10        lea    0x10(%rsp),%rdi</div><div class="line">  4010bd: e8 76 02 00 00        callq  401338 &lt;strings_not_equal&gt;</div><div class="line">  4010c2: 85 c0                 test   %eax,%eax</div><div class="line">  4010c4: 74 13                 je     4010d9 &lt;phase_5+0x77&gt;</div><div class="line">  4010c6: e8 6f 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  4010cb: 0f 1f 44 00 00        nopl   0x0(%rax,%rax,1)</div><div class="line">  4010d0: eb 07                 jmp    4010d9 &lt;phase_5+0x77&gt;</div><div class="line">  4010d2: b8 00 00 00 00        mov    $0x0,%eax</div><div class="line">  4010d7: eb b2                 jmp    40108b &lt;phase_5+0x29&gt;</div><div class="line">  4010d9: 48 8b 44 24 18        mov    0x18(%rsp),%rax</div><div class="line">  4010de: 64 48 33 04 25 28 00  xor    %fs:0x28,%rax</div><div class="line">  4010e5: 00 00 </div><div class="line">  4010e7: 74 05                 je     4010ee &lt;phase_5+0x8c&gt;</div><div class="line">  4010e9: e8 42 fa ff ff        callq  400b30 &lt;__stack_chk_fail@plt&gt;</div><div class="line">  4010ee: 48 83 c4 20           add    $0x20,%rsp</div><div class="line">  4010f2: 5b                    pop    %rbx</div><div class="line">  4010f3: c3                    retq</div></pre></td></tr></table></figure>
<p>根据<code>x86-64</code>寄存器使用规范，<code>%rdi</code>寄存器存储的是第一个参数的值，由于输入的是字符串，因此<code>%rdi</code>存储的应该是输入字符串的起始地址。<code>0x401067</code>处的指令<code>mov %rdi,%rbx</code>将字符串起始地址保存在<code>%rbx</code>中，即<code>%rbx</code>为基址寄存器。指令<code>xor %eax,%eax</code>的作用是将<code>%eax</code>清零，接着调用<code>string_length</code>函数获取输入字符串的长度，并将长度值（返回值）存储于<code>%eax</code>。指令<code>cmp $0x6,%eax</code>将<code>string_length</code>的返回值与常数<code>6</code>作比较，若不相等则会引爆炸弹，由此可以得知，<code>phase_5</code>的输入字符串长度应该等于<code>6</code>。</p>
<p>当输入字符串的长度等于<code>6</code>，<code>phase_5</code>跳转至<code>0x4010d2</code>处执行指令<code>mov $0x0,%eax</code>，接着又跳转至<code>0x40108b</code>处执行指令<code>movzbl (%rbx,%rax,1),%ecx</code>，可以发现<code>0x40108b</code>至<code>0x4010ac</code>构成了一个循环，且在循环退出后在<code>0x4010bd</code>处调动了<code>strings_not_equal</code>来比较字符串是否相等，若相等，则拆弹成功。其中，由<code>mov $0x40245e,%esi</code>指令可知，待比较的字符串存储于地址<code>0x40245e</code>处，打印以该地址作为起始地址的字符串，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 8.png" alt=""></p>
<p>待比较的字符串为<code>flyers</code>，且长度也为<code>6</code>。所以，接下来的关键任务是需要对循环操作进行分析，理解该循环操作对输入字符串做了哪些操作。提取循环操作的代码，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">40108b: 0f b6 0c 03           movzbl (%rbx,%rax,1),%ecx</div><div class="line">40108f: 88 0c 24              mov    %cl,(%rsp)</div><div class="line">401092: 48 8b 14 24           mov    (%rsp),%rdx</div><div class="line">401096: 83 e2 0f              and    $0xf,%edx</div><div class="line">401099: 0f b6 92 b0 24 40 00  movzbl 0x4024b0(%rdx),%edx</div><div class="line">4010a0: 88 54 04 10           mov    %dl,0x10(%rsp,%rax,1)</div><div class="line">4010a4: 48 83 c0 01           add    $0x1,%rax</div><div class="line">4010a8: 48 83 f8 06           cmp    $0x6,%rax</div><div class="line">4010ac: 75 dd                 jne    40108b &lt;phase_5+0x29&gt;</div></pre></td></tr></table></figure>
<p>由于<code>%rbx</code>存储的是输入字符串的起始地址，<code>%rax</code>初始化为<code>0</code>，其作用等价于下标，因此<code>movzbl (%rbx,%rax,1),%ecx</code>指令的作用是将字符串的第<code>%rax</code>个字符存储于<code>%ecx</code>，<code>movzbl</code>意味做了零扩展。接着，<code>mov  %cl,(%rsp)</code>指令取<code>%ecx</code>的低<code>8</code>位，即一个字符的大小，通过内存间接存储至<code>%rdx</code>中。<code>and  $0xf,%edx</code>指令将<code>%edx</code>的值与常数<code>0xf</code>进行位与，由指令<code>movzbl 0x4024b0(%rdx),%edx</code>可知，位与后的值将会作为偏移量，以<code>0x4024b0</code>为基址，将偏移后的值存储至<code>%edx</code>。最后，指令<code>mov %dl,0x10(%rsp,%rax,1)</code>以<code>%edx</code>低<code>8</code>位的值作为新的字符，对原有字符进行替换。</p>
<p>综上，<code>phase_5</code>遍历输入字符串的每个字符，将字符的低<code>4</code>位作为偏移量，以<code>0x4024b0</code>为起始地址，将新地址对应的字符替换原有字符，最终得到<code>flyers</code>字符串。打印<code>0x4024b0</code>处的内容，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 9.png" alt=""></p>
<p>例如，如果要得到字符<code>f</code>，那么偏移量应为<code>9</code>，二进制表示为<code>1001</code>，通过查找<code>ASCII</code>表，可知字符<code>i</code>的<code>ASCII</code>编码为<code>01101001</code>，满足要求。剩余<code>5</code>个字符采用同样的策略可以依次求得，最终，<code>phase_5</code>的输入字符串为<code>ionefg</code>。</p>
<h2 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase 6"></a>Phase 6</h2><p><code>phase_6</code>对应的代码非常长，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line">00000000004010f4 &lt;phase_6&gt;:</div><div class="line">  4010f4: 41 56                 push   %r14</div><div class="line">  4010f6: 41 55                 push   %r13</div><div class="line">  4010f8: 41 54                 push   %r12</div><div class="line">  4010fa: 55                    push   %rbp</div><div class="line">  4010fb: 53                    push   %rbx</div><div class="line">  4010fc: 48 83 ec 50           sub    $0x50,%rsp</div><div class="line">  401100: 49 89 e5              mov    %rsp,%r13</div><div class="line">  401103: 48 89 e6              mov    %rsp,%rsi</div><div class="line">  401106: e8 51 03 00 00        callq  40145c &lt;read_six_numbers&gt;</div><div class="line">  40110b: 49 89 e6              mov    %rsp,%r14               # %r14存储数组起始地址</div><div class="line">  40110e: 41 bc 00 00 00 00     mov    $0x0,%r12d              # 将%r12d初始化为0</div><div class="line">  </div><div class="line">  #################### Section 1:确认数组中所有的元素小于等于6且不存在重复值 ###################</div><div class="line">  401114: 4c 89 ed              mov    %r13,%rbp               # %r13和%rbp存储数组某个元素的地址，并不是第1个元素，意识到这点需要结合0x40114d处的指令</div><div class="line">  401117: 41 8b 45 00           mov    0x0(%r13),%eax          # %eax存储第%r13个数</div><div class="line">  40111b: 83 e8 01              sub    $0x1,%eax               # 将%eax的值减1</div><div class="line">  40111e: 83 f8 05              cmp    $0x5,%eax               # 将%eax的值与常数5做比较</div><div class="line">  401121: 76 05                 jbe    401128 &lt;phase_6+0x34&gt;</div><div class="line">  401123: e8 12 03 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  401128: 41 83 c4 01           add    $0x1,%r12d              # 如果%eax的值小于等于5，%r12d加1</div><div class="line">  40112c: 41 83 fc 06           cmp    $0x6,%r12d              # 将%r12d与常数6做比较</div><div class="line">  401130: 74 21                 je     401153 &lt;phase_6+0x5f&gt;</div><div class="line">  401132: 44 89 e3              mov    %r12d,%ebx              # %ebx起了数组下标的作用</div><div class="line">  </div><div class="line">  # 用于判断数组6个数是否存在重复值，若存在，引爆炸弹</div><div class="line">  401135: 48 63 c3              movslq %ebx,%rax               # 将数组下标存储至%rax</div><div class="line">  401138: 8b 04 84              mov    (%rsp,%rax,4),%eax      # 将下一个数存储至%eax</div><div class="line">  40113b: 39 45 00              cmp    %eax,0x0(%rbp)          # 将第1个数与%eax的值(当前数)做比较</div><div class="line">  40113e: 75 05                 jne    401145 &lt;phase_6+0x51&gt;   # 若相等，引爆炸弹   </div><div class="line">  401140: e8 f5 02 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  401145: 83 c3 01              add    $0x1,%ebx               # 数组下标加1            </div><div class="line">  401148: 83 fb 05              cmp    $0x5,%ebx               # 判断数组下标是否越界(&lt;=5)</div><div class="line">  40114b: 7e e8                 jle    401135 &lt;phase_6+0x41&gt;</div><div class="line">  </div><div class="line">  40114d: 49 83 c5 04           add    $0x4,%r13               # %r13存储数组下一个数的地址</div><div class="line">  401151: eb c1                 jmp    401114 &lt;phase_6+0x20&gt;</div><div class="line">  ####################################### Section 1 end ######################################</div><div class="line">  </div><div class="line">  ################ Section 2：用7减去数组的每个元素，并将相减后的元素替换原有元素 #################</div><div class="line">  401153: 48 8d 74 24 18        lea    0x18(%rsp),%rsi         # 0x18(%rsp)是数组的边界地址：0x18 = 24         </div><div class="line">  401158: 4c 89 f0              mov    %r14,%rax               # 将数组起始地址存储于%rax</div><div class="line">  40115b: b9 07 00 00 00        mov    $0x7,%ecx</div><div class="line">  </div><div class="line">  401160: 89 ca                 mov    %ecx,%edx               # %edx = 7</div><div class="line">  401162: 2b 10                 sub    (%rax),%edx             # %edx = 7 - 数组元素</div><div class="line">  401164: 89 10                 mov    %edx,(%rax)             # 用相减后的元素(%edx)替换原有元素</div><div class="line">  401166: 48 83 c0 04           add    $0x4,%rax               # %rax存储数组下一个元素的地址</div><div class="line">  40116a: 48 39 f0              cmp    %rsi,%rax               # 判断是否越界</div><div class="line">  40116d: 75 f1                 jne    401160 &lt;phase_6+0x6c&gt;</div><div class="line">  ####################################### Section 2 end ######################################</div><div class="line">  </div><div class="line">  ########################## Section 3：根据输入数组重排结构体数组 ##############################</div><div class="line">  40116f: be 00 00 00 00        mov    $0x0,%esi               # 将%esi初始化为0，作为数组下标</div><div class="line">  401174: eb 21                 jmp    401197 &lt;phase_6+0xa3&gt;</div><div class="line">  </div><div class="line">  401176: 48 8b 52 08           mov    0x8(%rdx),%rdx          # 0x8(%rdx)为下一个元素的地址</div><div class="line">  40117a: 83 c0 01              add    $0x1,%eax               </div><div class="line">  40117d: 39 c8                 cmp    %ecx,%eax               # %ecx存储了数组当前值(第%esi个元素)</div><div class="line">  40117f: 75 f5                 jne    401176 &lt;phase_6+0x82&gt;</div><div class="line">  </div><div class="line">  401181: eb 05                 jmp    401188 &lt;phase_6+0x94&gt;</div><div class="line">  401183: ba d0 32 60 00        mov    $0x6032d0,%edx          # %edx存储结构体数组第1个元素的地址</div><div class="line">  401188: 48 89 54 74 20        mov    %rdx,0x20(%rsp,%rsi,2)  # %rsi的初始值为0；该指令的作用是将结构体数组的第%ecx个元素的地址存储在内存的某个位置(以%rsp + 0x20为基地址，%rsi为偏移量)</div><div class="line">  40118d: 48 83 c6 04           add    $0x4,%rsi               # 增加偏移量</div><div class="line">  401191: 48 83 fe 18           cmp    $0x18,%rsi</div><div class="line">  401195: 74 14                 je     4011ab &lt;phase_6+0xb7&gt;</div><div class="line">  401197: 8b 0c 34              mov    (%rsp,%rsi,1),%ecx      # %ecx存储数组第%esi个元素</div><div class="line">  40119a: 83 f9 01              cmp    $0x1,%ecx               # 将数组第%esi个元素与常数1做比较</div><div class="line">  40119d: 7e e4                 jle    401183 &lt;phase_6+0x8f&gt;   # 实际上不会小于1，如果数组的第1个元素等于1，那么跳转至0x401183处</div><div class="line">  40119f: b8 01 00 00 00        mov    $0x1,%eax</div><div class="line">  4011a4: ba d0 32 60 00        mov    $0x6032d0,%edx          # %edx存储结构体数组第1个元素的地址</div><div class="line">  4011a9: eb cb                 jmp    401176 &lt;phase_6+0x82&gt;</div><div class="line">  ####################################### Section 3 end ######################################</div><div class="line">  </div><div class="line">  ######################### Section 4：修改结构体数组元素的next域值 #############################</div><div class="line">  4011ab: 48 8b 5c 24 20        mov    0x20(%rsp),%rbx         # %rbx存储地址数组的第1个元素的值</div><div class="line">  4011b0: 48 8d 44 24 28        lea    0x28(%rsp),%rax         # %rax存储地址数组的第2个元素的地址</div><div class="line">  4011b5: 48 8d 74 24 50        lea    0x50(%rsp),%rsi</div><div class="line">  4011ba: 48 89 d9              mov    %rbx,%rcx               # %rcx存储地址数组的第1个元素的值</div><div class="line">  </div><div class="line">  # 下面用i和i+1来表示元素位置</div><div class="line">  4011bd: 48 8b 10              mov    (%rax),%rdx             # %rdx存储地址数组的第i+1个元素的值</div><div class="line">  4011c0: 48 89 51 08           mov    %rdx,0x8(%rcx)          # 把第i+1和元素的值存储于第i个结构体元素的next域中，next域的地址为0x8(%rcx)的值</div><div class="line">  4011c4: 48 83 c0 08           add    $0x8,%rax</div><div class="line">  4011c8: 48 39 f0              cmp    %rsi,%rax</div><div class="line">  4011cb: 74 05                 je     4011d2 &lt;phase_6+0xde&gt;</div><div class="line">  4011cd: 48 89 d1              mov    %rdx,%rcx</div><div class="line">  4011d0: eb eb                 jmp    4011bd &lt;phase_6+0xc9&gt;</div><div class="line">  ####################################### Section 4 end ######################################</div><div class="line">  </div><div class="line">  ######################### Section 5：判断结构体数组是否是递减序列 #############################</div><div class="line">  4011d2: 48 c7 42 08 00 00 00  movq   $0x0,0x8(%rdx)</div><div class="line">  4011d9: 00 </div><div class="line">  4011da: bd 05 00 00 00        mov    $0x5,%ebp</div><div class="line">  4011df: 48 8b 43 08           mov    0x8(%rbx),%rax</div><div class="line">  4011e3: 8b 00                 mov    (%rax),%eax</div><div class="line">  4011e5: 39 03                 cmp    %eax,(%rbx)</div><div class="line">  4011e7: 7d 05                 jge    4011ee &lt;phase_6+0xfa&gt;</div><div class="line">  4011e9: e8 4c 02 00 00        callq  40143a &lt;explode_bomb&gt;</div><div class="line">  4011ee: 48 8b 5b 08           mov    0x8(%rbx),%rbx</div><div class="line">  4011f2: 83 ed 01              sub    $0x1,%ebp</div><div class="line">  4011f5: 75 e8                 jne    4011df &lt;phase_6+0xeb&gt;</div><div class="line">  ####################################### Section 5 end ######################################</div><div class="line">  </div><div class="line">  4011f7: 48 83 c4 50           add    $0x50,%rsp</div><div class="line">  4011fb: 5b                    pop    %rbx</div><div class="line">  4011fc: 5d                    pop    %rbp</div><div class="line">  4011fd: 41 5c                 pop    %r12</div><div class="line">  4011ff: 41 5d                 pop    %r13</div><div class="line">  401201: 41 5e                 pop    %r14</div><div class="line">  401203: c3                    retq</div></pre></td></tr></table></figure>
<p>分析清楚<code>phase_6</code>非常需要耐心，我将<code>phase_6</code>划分为<code>5</code>个<code>Section</code>，每个<code>Section</code>完成特定的功能，详细的注释直接附到了相关代码。前两个<code>Section</code>不难理解：<code>Section 1</code>确保输入数组的值的范围在<code>1 ~ 6</code>且不存在重复值；<code>Section 2</code>用<code>7</code>减去输入数组的每个元素，相当于求补。<code>Section 3</code>中出现了一个常数地址，使用<code>gdb</code>将该地址存储的内容打印出来，如下图所示。</p>
<p><img src="/img/2017-04-26-Image 11.png" alt=""></p>
<p>可以意识到这其实是一个链表数据结构，链表的节点由<code>3</code>部分组成：<code>value 1</code>、<code>value 2</code>和一个地址值(<code>next</code>域，指向下一个节点)。<code>Section 3</code>根据我们输入的数组，按照数组元素的值将对应结构体数组中的元素的首地址存储到内存的某个位置(<code>mov %rdx,0x20(%rsp,%rsi,2)</code>)。例如，假设输入数组为<code>[3, 4, 5, 6, 1, 2]</code>，那么<code>Section 3</code>首先会将结构体数组的第<code>3</code>个元素的地址存储到<code>0x20(%rsp,%rsi,2)</code>处，接着将结构体数组的第<code>4</code>个元素……依次类推。</p>
<p><code>Section 4</code>根据<code>Section 3</code>构建的地址数组，修改结构体数组的<code>next</code>域的值，实现单链表的排序操作。<code>Section 5</code>进行验证，要求单链表递减排序，若满足要求，那么拆弹成功。</p>
<p>综上，根据已有的结构体数组以及<code>phase_6</code>的操作，若要实现单链表的递减排序，应将第<code>3</code>个节点放在第<code>1</code>位，将第<code>4</code>个节点放在第<code>2</code>位……最终得到序列：<code>[3, 4, 5, 6, 1, 2]</code>。不要忘记<code>Section 2</code>中的求补操作，所以<code>phase_6</code>的输入序列应该为<code>[4, 3, 2, 1, 6, 5]</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，<code>Bomb Lab</code>包含了<code>6</code>个<code>phase</code>全部拆弹成功。将输入序列存储在文件，然后将文件作为<code>bomb</code>二进制文件的参数，运行结果如下图所示。</p>
<p><img src="/img/2017-04-26-Image 10.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Bomb Lab&lt;/code&gt;是&lt;code&gt;CS:APP&lt;/code&gt;一书中第二个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/bomblab.pdf&quot;&gt;实验&lt;/a&gt;，实验中的&lt;code&gt;bomb&lt;/code&gt;实际上是一个程序的二进制文件，该程序由一系列&lt;code&gt;phase&lt;/code&gt;组成，每个&lt;code&gt;phase&lt;/code&gt;需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印&lt;code&gt;BOOM!!!&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://tinylcy.me/tags/CSAPP/"/>
    
      <category term="Assembly" scheme="http://tinylcy.me/tags/Assembly/"/>
    
  </entry>
  
  <entry>
    <title>理解Golang中的defer</title>
    <link href="http://tinylcy.me/2017/04/04/%E7%90%86%E8%A7%A3Golang%E4%B8%AD%E7%9A%84defer/"/>
    <id>http://tinylcy.me/2017/04/04/理解Golang中的defer/</id>
    <published>2017-04-04T13:01:21.000Z</published>
    <updated>2017-04-25T04:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>关键字<code>defer</code>用于实现延迟调用，根据<code>Golang</code>官方的定义：<em>A defer statement defers the execution of a function until the surrounding function returns.</em> 。但是，当返回值与<code>defer</code>相互关联时，如果没有正确理解<code>defer</code>与<code>return</code>真正的执行顺序，那么容易出现一些不可描述的现象。</p>
<p>我们先运行如下代码，根据运行结果来理解<code>defer</code>，在查看运行结果之前，不妨先想想<code>main</code>函数的输出是什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(funcA())</div><div class="line">	fmt.Println(funcB())</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcA</span><span class="params">()</span> <span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer2:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer1:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> i</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcB</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer2:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer1:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> i</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">defer1: <span class="number">1</span></div><div class="line">defer2: <span class="number">2</span></div><div class="line"><span class="number">0</span></div><div class="line">defer1: <span class="number">1</span></div><div class="line">defer2: <span class="number">2</span></div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure>
<p>根据运行结果，我们可以看到，<code>defer</code>语句的执行顺序以及打印出来的变量<code>i</code>的值是意料之内的，区别在于函数的返回值，而<code>funcA</code>和<code>funcB</code>这两个函数唯一的区别则是函数的返回值有没有被命名，因此导致两个函数返回值不同的原因也应该和返回值是否命名有关。</p>
<p>在计算机科学中，我相信很多原理性的东西都是可以相互解释的。在本篇文章中，我决定用<code>Java</code>中的<code>try-catch-finally</code>来解释<code>defer</code>的运行机制。首先，先看看如下<code>Java</code>代码片段，并考虑返回值有哪几种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        x = <span class="number">1</span>;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        x = <span class="number">2</span>;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        x = <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们对<code>Java</code>熟悉，那么应该知道，无论在<code>try</code>块中是否出现异常，<code>finally</code>块中的语句是一定要执行的，但是函数的返回值只可能是<code>1</code>或者<code>2</code>，绝对不会是<code>3</code>。我们通过查看这段<code>Java</code>代码对应的字节码指令来理解这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</div><div class="line">  flags: ACC_PUBLIC</div><div class="line">  Code:</div><div class="line">    stack=<span class="number">1</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></div><div class="line">       <span class="number">0</span>: iconst_1</div><div class="line">       <span class="number">1</span>: istore_1</div><div class="line">       <span class="number">2</span>: iload_1</div><div class="line">       <span class="number">3</span>: istore_2</div><div class="line">       <span class="number">4</span>: iconst_3</div><div class="line">       <span class="number">5</span>: istore_1</div><div class="line">       <span class="number">6</span>: iload_2</div><div class="line">       <span class="number">7</span>: ireturn</div></pre></td></tr></table></figure>
<p>这段字节码对应于<code>try-finally</code>这条执行轨迹：<code>iconst_1</code>将常量<code>1</code>压入操作数栈；<code>istore_1</code>将栈顶元素弹出并存储于局部变量表<code>Slot1</code>处；<code>iload_1</code>将局部变量表<code>Slot1</code>处的元素压入操作数栈；<code>istore_2</code>将操作数栈顶元素弹出并存储于局部变量表<code>Slot2</code>处；<code>iconst_3</code>将常量<code>3</code>压入操作数栈；<code>istore_1</code>将操作数栈顶元素弹出并存储于局部变量表<code>Slot1</code>处；<code>iload_2</code>将局部变量表<code>Slot2</code>处的元素压入操作数栈；<code>ireturn</code>返回栈顶元素。</p>
<p>第<code>0</code>条指令和第<code>1</code>条指令实现了<code>x = 1</code>，并且<code>x</code>的值存储于局部变量表的<code>Slot1</code>处；第<code>2</code>条指令和第<code>3</code>条指令将<code>x</code>的值拷贝了一份，并存储在局部变量表的<code>Slot2</code>处。第<code>4</code>条指令和第<code>5</code>条指令实现了<code>x = 3</code>；第<code>6</code>条指令和第<code>7</code>条指令将存储于局部变量表<code>Slot2</code>处的<code>x</code>的拷贝值返回，由于<code>Slot2</code>中的值是执行<code>finally</code>块中语句之前<code>x</code>的值，因此返回值等于<code>2</code>。</p>
<p>基于以上解释，我们再来重新理解<code>defer</code>。对于函数<code>funcA</code>，当执行至<code>return</code>时，变量<code>i</code>的值等于<code>0</code>，与<code>Java</code>类似，<code>Golang</code>会将返回值的拷贝值（即变量<code>i</code>的值）存储于内存中的某个位置<code>pos</code>（对应于局部变量表的<code>Slot2</code>处），然后执行<code>defer</code>语句，当<code>defer</code>语句执行完后，尽管变量<code>i</code>的值已增加至<code>2</code>，但是返回值依赖于地址<code>pos</code>处的值，因此<code>funcA</code>返回<code>0</code>；对于函数<code>funcB</code>，由于<code>funcB</code>已经命名了函数的返回值为变量<code>i</code>，这意味着函数的返回值的地址即为变量<code>i</code>的地址。当执行至<code>return</code>时，尽管变量<code>i</code>的值为<code>0</code>，但是紧接着的<code>defer</code>语句使得变量<code>i</code>的值增加至<code>2</code>，由于<code>funcA</code>的返回值的地址为变量<code>i</code>的地址，因此<code>funcB</code>最后的返回值为<code>2</code>。</p>
<p>为了验证我们的解释，运行如下代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(*(funcC()))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcC</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer2:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		i++</div><div class="line">		fmt.Println(<span class="string">"defer1:"</span>, i)</div><div class="line">	&#125;()</div><div class="line">	<span class="keyword">return</span> &amp;i</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管函数<code>funcC</code>的返回值并没有提前声明，但是<code>funcC</code>的返回值仍为<code>2</code>，这是因为<code>funcC</code>的返回值是变量<code>i</code>的内存地址，当执行到<code>return</code>语句时，变量<code>i</code>的内存地址值的拷贝会被存储于内存的某个位置，而该位置的值即是最后的返回值，由于变量<code>i</code>的地址在整个过程并未被修改，因此通过地址值的拷贝值我们依旧可以观察到<code>defer</code>语句对变量<code>i</code>的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关键字&lt;code&gt;defer&lt;/code&gt;用于实现延迟调用，根据&lt;code&gt;Golang&lt;/code&gt;官方的定义：&lt;em&gt;A defer statement defers the execution of a function until the surrounding f
    
    </summary>
    
    
      <category term="Golang" scheme="http://tinylcy.me/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>谈谈ThreadLocal</title>
    <link href="http://tinylcy.me/2017/02/24/%E8%B0%88%E8%B0%88ThreadLocal/"/>
    <id>http://tinylcy.me/2017/02/24/谈谈ThreadLocal/</id>
    <published>2017-02-24T14:21:03.000Z</published>
    <updated>2017-04-25T04:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a> 一书在介绍<code>ThreadLocal</code>类时（第<code>3</code>章），书中有这么两段话，在我初次阅读时不知道如何去理解。</p>
<blockquote>
<p>ThreadLocal对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。</p>
<p>当某个频繁执行的操作需要一个临时变量，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。例如，在Java 5.0之前，Integer.toString()方法使用ThreadLocal对象来保存一个12字节大小的缓冲区，用于对结果进行格式化，而不是使用共享的静态缓冲区（这需要锁机制）或者在每次调用时都分配一个新的缓冲区。</p>
</blockquote>
<p>如果我们要在某种程度上理解这两句话，首先我们需要知道什么是<code>ThreadLocal</code>？更重要的是为什么要提出<code>ThreadLocal</code>这个概念？</p>
<p>我们知道，线程并不独立拥有用户空间，用户空间是归进程所有，为同一进程中的所有线程所共享的。所以，用户空间中的任何一个区域，只要有一个线程可以访问，那么同一进程中的所有其它的线程就都能访问。在这个意义上，整个用户空间都是（由同一进程中的）所有线程共享的，不存在只归一个线程使用的变量或数据结构。可是，一般而言，程序对变量或数据结构的访问都是按变量名访问的，经过编译/连接之后就是按地址访问，要是不知道一个变量的地址，实际上就无法正常和正确地加以访问。在这个意义上，则只归一个线程使用的变量或数据结构又是可能的。</p>
<p>注意<code>ThreadLocal</code>只是对全局量和静态变量才有意义。局部量存在于具体线程的堆栈上，而每个线程都有自己的堆栈，所以局部量本来就是“局部”于具体线程的。至于通过动态分配的缓冲区，则取决于保存着缓冲区指针的变量。如果缓冲区指针是全局量，那么同一进程中的所有线程都能访问这个缓冲区；而若是局部量，则别的线程自然就不得其门而入。</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在介绍<code>ThreadLocal</code>之前，我们先通过一段代码来理解<code>synchronized</code>是如何实现在同一时刻只允许单个线程访问同步代码块的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;   </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将<code>SynchronizedTest</code>编译之后，<code>SynchronizedTest</code>中的两个同步方法的字节码（只截取需要的部分 ）如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public synchronized void func1();</div><div class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</div><div class="line">  Code:</div><div class="line">    stack=0, locals=1, args_size=1</div><div class="line">       0: return</div><div class="line">    LineNumberTable:</div><div class="line">      line 10: 0</div><div class="line"></div><div class="line">public void func2();</div><div class="line">  flags: ACC_PUBLIC</div><div class="line">  Code:</div><div class="line">    stack=2, locals=3, args_size=1</div><div class="line">       0: aload_0</div><div class="line">       1: dup</div><div class="line">       2: astore_1</div><div class="line">       3: monitorenter</div><div class="line">       4: aload_1</div><div class="line">       5: monitorexit</div><div class="line">       6: goto          14</div><div class="line">       9: astore_2</div><div class="line">      10: aload_1</div><div class="line">      11: monitorexit</div><div class="line">      12: aload_2</div><div class="line">      13: athrow</div><div class="line">      14: return</div></pre></td></tr></table></figure>
<p><code>synchronized</code>关键字经过编译之后，会在同步代码块的前后分别形成<code>monitorenter</code>和<code>monitorexit</code>这两个字节码指令，例如<code>func2</code>方法对应的第<code>3</code>条和第<code>5</code>条字节码，这两个字节码都需要一个<code>reference</code>类型的参数来指明要锁定和解锁的对象。那这里提到的锁和对象之间的关系是什么？关于这个问题，可以参考我的另一篇文章 <a href="http://tinylcy.me/2016/11/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/">Java对象内存布局</a>，在对象的<code>Mark Word</code>部分，存储着锁标志位，线程通过检查对象头的锁标志位，获知对象的锁状态，然后决定是获取锁还是进入阻塞状态。<code>synchronized</code>正是通过这个机制实现对共享资源的串行访问。</p>
<h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p>关于<code>ThreadLocal</code>的概念，直接<code>从ThreadLocal</code>源码注释入手。</p>
<blockquote>
<p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p>
</blockquote>
<p>根据注释，我们认识到<code>ThreadLocal</code>可以为线程提供一个线程局部的值，既然该值是一个线程的局部变量，自然不存在线程同步的问题。但是注释又说到：<em>ThreadLocal instances are typically private static fields in classes</em>，这句话如何理解？如果一个变量是<code>static</code>的变量，那么它就是进程级别的全局变量，那不是意味着<code>ThreadLocal</code>是一个线程共享的变量吗？为了解决这个问题，我们需要阅读<code>ThreadLocal</code>的源码。</p>
<p>首先是<code>ThreadLocal</code>的<code>set</code>方法，<code>set</code>方法的作用是为当前线程设置一个<code>ThreadLocal</code>的值<code>value</code>，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>set</code>方法首先调用<code>getMap</code>方法从当前线程获取类型为<code>ThreadLocalMap</code>的对象<code>map</code>，如果<code>map</code>还没有创建，就通过<code>createMap</code>方法创建一个。然后<code>set</code>方法以当前的<code>ThreadLocal</code>对象为键，<code>value</code>为值，存储到当前线程的<code>ThreadLocalMap</code>对象中。<code>Thread</code>类中<code>ThreadLocalMap</code>变量的声明如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></div><div class="line"> * by the ThreadLocal class. */</div><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<p><code>ThreadLocal</code>的<code>get</code>方法用于获取与当前线程关联的<code>ThreadLocal</code>值，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get</code>方法首先通过<code>getMap</code>方法获取当前线程的<code>ThreadLocalMap</code>对象，然后以<code>ThreadLocal</code>对象为键获取与该<code>ThreadLocal</code>对象关联的值。</p>
<p>从这两个方法我们知道，<code>ThreadLocal</code>对象的确是线程共享的，但是当线程向<code>ThreadLocal</code>设置值时，实际上是给当前线程维护的<code>ThreadLocalMap</code>设置了值。因此线程设置的值为线程私有，但是<code>ThreadLocal</code>对象为线程共享。</p>
<h2 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计"></a>为什么这么设计</h2><p>如果我们要设置线程本地的变量，我们只需要在方法内声明局部变量即可，为什么要通过<code>ThreadLocal</code>来设置？对于<code>ThreadLocal</code>的设计理念，我们通过<code>Linux/Unix</code>的<code>C</code>程序库<code>libc</code>的全局变量<code>errno</code>来理解。当系统调用从内核空间返回用户空间时，如果系统调用出错，那么便设置<code>errno</code>的值为一个负值，这样就不需要每次在函数内部定义局部变量。但是当多线程的概念和技术被提出后，这套机制就不再适用了，可以使用局部变量，但是不太可能去更改已有的代码了，比较好的解决方案是让每个线程都有自己的<code>errno</code>。实际上，现在的<code>C</code>库函数不是把出错代码写入全局量<code>errno</code>，而是通过一个函数<code>__errno_location()</code>获取一个地址，再把出错代码写入该地址，其意图就是让不同的线程使用不同的出错代码存储地点，而<code>errno</code>，现在一般已经变成了一个宏定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> errno (*__errno_location())</span></div></pre></td></tr></table></figure>
<p>考虑另一个场景：我们现在需要设置一个线程局部变量，于是我们在方法内设置了一个局部变量，当我们需要把这个局部变量从一个方法传递到另一个方法，只需要将这个变量作为参数传递即可。假设<code>funcA</code>需要访问该变量，<code>funcZ</code>也需要访问该变量，但是<code>funcA</code>需要通过调用<code>funcB</code>，<code>funcC...funcY</code>才能调用<code>funcZ</code>，于是该变量需要被声明在所有的方法的签名中。为了避免这个麻烦，我们可以把这个变量设置为进程级别的全局变量，但是此时就需要我们控制线程同步了。于是，<code>ThreadLocal</code>就可以发挥作用了。</p>
<p>我们可以认为<code>ThreadLocal</code>存储了一个线程的上下文信息，线程通过访问<code>ThreadLocal</code>这个进程级别的变量实现了线程级别的访问。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a></li>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></li>
<li><a href="http://www.longene.org/techdoc/0328131001224576926.html" target="_blank" rel="external">漫谈兼容内核</a></li>
<li><a href="http://github.thinkingbar.com/threadlocal/" target="_blank" rel="external">理解 ThreadLocal</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/10484692/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java并发编程实战&lt;/a&gt; 一书在介绍&lt;code&gt;ThreadLocal&lt;/code&gt;类时（第&lt;code&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个Java Class解析器</title>
    <link href="http://tinylcy.me/2017/02/12/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAJava-Class%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <id>http://tinylcy.me/2017/02/12/如何实现一个Java-Class解析器/</id>
    <published>2017-02-12T15:26:08.000Z</published>
    <updated>2017-05-04T14:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个私人项目，名字叫做<code>ClassAnalyzer</code>，<code>ClassAnalyzer</code>的目的是能让我们对<code>Java Class</code>文件的设计与结构能够有一个深入的理解。主体框架与基本功能已经完成，还有一些细节功能日后再增加。实际上<code>JDK</code>已经提供了命令行工具<code>javap</code>来反编译<code>Class</code>文件，但本篇文章将阐明我实现解析器的思路。</p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>作为类或者接口信息的载体，每个<code>Class</code>文件都完整的定义了一个类。为了使<code>Java</code>程序可以“编写一次，处处运行”，<a href="http://files.cnblogs.com/files/zhuYears/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%84%E8%8C%83%EF%BC%88JavaSE7%EF%BC%89.pdf" target="_blank" rel="external">Java虚拟机规范</a>对<code>Class</code>文件进行了严格的规定。构成<code>Class</code>文件的基本数据单位是字节，这些字节之间不存在任何分隔符，这使得整个<code>Class</code>文件中存储的内容几乎全部是程序运行的必要数据，单个字节无法表示的数据由多个连续的字节来表示。</p>
<p>根据<code>Java</code>虚拟机规范，<code>Class</code>文件采用一种类似于<code>C</code>语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。<code>Java</code>虚拟机规范定义了<code>u1</code>、<code>u2</code>、<code>u4</code>和<code>u8</code>来分别表示<code>1</code>个字节、<code>2</code>个字节、<code>4</code>个字节和<code>8</code>个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者是字符串。表是由多个无符号数或者其它表作为数据项构成的复合数据类型，表用于描述有层次关系的复合结构的数据，因此整个<code>Class</code>文件本质上就是一张表。在<code>ClassAnalyzer</code>中，<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>分别对应<code>u1</code>、<code>u2</code>、<code>u4</code>和<code>u8</code>数据类型，<code>Class</code>文件被描述为如下<code>Java</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassFile</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> U4 magic;                            <span class="comment">// magic</span></div><div class="line">    <span class="keyword">public</span> U2 minorVersion;                     <span class="comment">// minor_version</span></div><div class="line">    <span class="keyword">public</span> U2 majorVersion;                     <span class="comment">// major_version</span></div><div class="line">    <span class="keyword">public</span> U2 constantPoolCount;                <span class="comment">// constant_pool_count</span></div><div class="line">    <span class="keyword">public</span> ConstantPoolInfo[] cpInfo;           <span class="comment">// cp_info</span></div><div class="line">    <span class="keyword">public</span> U2 accessFlags;                      <span class="comment">// access_flags</span></div><div class="line">    <span class="keyword">public</span> U2 thisClass;                        <span class="comment">// this_class</span></div><div class="line">    <span class="keyword">public</span> U2 superClass;                       <span class="comment">// super_class</span></div><div class="line">    <span class="keyword">public</span> U2 interfacesCount;                  <span class="comment">// interfaces_count</span></div><div class="line">    <span class="keyword">public</span> U2[] interfaces;                     <span class="comment">// interfaces</span></div><div class="line">    <span class="keyword">public</span> U2 fieldsCount;                      <span class="comment">// fields_count</span></div><div class="line">    <span class="keyword">public</span> FieldInfo[] fields;                  <span class="comment">// fields</span></div><div class="line">    <span class="keyword">public</span> U2 methodsCount;                     <span class="comment">// methods_count</span></div><div class="line">    <span class="keyword">public</span> MethodInfo[] methods;                <span class="comment">// methods</span></div><div class="line">    <span class="keyword">public</span> U2 attributesCount;                  <span class="comment">// attributes_count</span></div><div class="line">    <span class="keyword">public</span> BasicAttributeInfo[] attributes;     <span class="comment">// attributes</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何解析"><a href="#如何解析" class="headerlink" title="如何解析"></a>如何解析</h2><p>组成<code>Class</code>文件的各个数据项中，例如魔数、<code>Class</code>文件的版本、访问标志、类索引和父类索引等数据项，它们在每个<code>Class</code>文件中都占用固定数量的字节，在解析时只需要读取相应数量的字节。除此之外，需要灵活处理的主要包括<code>4</code>部分：常量池、字段表集合、方法表集合和属性表集合。字段和方法都可以具备自己的属性，<code>Class</code>本身也有相应的属性，因此，在解析字段表集合和方法表集合的同时也包含了属性表集合的解析。</p>
<p>常量池占据了<code>Class</code>文件很大一部分的数据，用于存储所有的常量信息，包括数字和字符串常量、类名、接口名、字段名和方法名等。<code>Java</code>虚拟机规范定义了多种常量类型，每一种常量类型都有自己的结构。常量池本身是一个表，在解析时有几点需要注意。</p>
<ul>
<li><p>每个常量类型都通过一个<code>u1</code>类型的<code>tag</code>来标识。</p>
</li>
<li><p>表头给出的常量池大小（<code>constantPoolCount</code>）比实际大<code>1</code>，例如，如果<code>constantPoolCount</code>等于<code>47</code>，那么常量池中有<code>46</code>项常量。</p>
</li>
<li>常量池的索引范围从<code>1</code>开始，例如，如果<code>constantPoolCount</code>等于<code>47</code>，那么常量池的索引范围为<code>1 ~ 46</code>。设计者将第<code>0</code>项空出来的目的是用于表达“不引用任何一个常量池项目”。</li>
<li>如果一个<code>CONSTANT_Long_info</code>或<code>CONSTANT_Double_info</code>结构的项在常量池中的索引为<code>n</code>，则常量池中下一个有效的项的索引为<code>n+2</code>，此时常量池中索引为<code>n+1</code>的项有效但必须被认为不可用。</li>
<li><code>CONSTANT_Utf8_info</code>型常量的结构中包含一个<code>u1</code>类型的<code>tag</code>、一个<code>u2</code>类型的<code>length</code>和由<code>length</code>个<code>u1</code>类型组成的<code>bytes</code>，这<code>length</code>字节的连续数据是一个使用<code>MUTF-8</code>（<code>Modified UTF-8）</code>编码的字符串。<code>MUTF-8</code>与<code>UTF-8</code>并不兼容，主要区别有两点：一是<code>null</code>字符会被编码成<code>2</code>字节（<code>0xC0</code>和<code>0x80</code>）；二是补充字符是按照<code>UTF-16</code>拆分为代理对分别编码的，相关细节可以看<a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">这里（变种UTF-8）</a>。</li>
</ul>
<p>属性表用于描述某些场景专有的信息，<code>Class</code>文件、字段表和方法表都有相应的属性表集合。<code>Java</code>虚拟机规范定义了多种属性，<code>ClassAnalyzer</code>目前实现了对常用属性的解析。与常量类型的数据项不同，属性并没有一个<code>tag</code>来标识属性的类型，但是每个属性都包含有一个<code>u2</code>类型的<code>attribute_name_index</code>，<code>attribute_name_index</code>指向常量池中的一个<code>CONSTANT_Utf8_info</code>类型的常量，该常量包含着属性的名称。在解析属性时，<code>ClassAnalyzer</code>正是通过<code>attribute_name_index</code>指向的常量对应的属性名称来得知属性的类型。</p>
<p>字段表用于描述类或者接口中声明的变量，字段包括类级变量以及实例级变量。字段表的结构包含一个<code>u2</code>类型的<code>access_flags</code>、一个<code>u2</code>类型的<code>name_index</code>、一个<code>u2</code>类型的<code>descriptor_index</code>、一个<code>u2</code>类型的<code>attributes_count</code>和<code>attributes_count</code>个<code>attribute_info</code>类型的<code>attributes</code>。我们已经介绍了属性表的解析，<code>attributes</code>的解析方式与属性表的解析方式一致。</p>
<p><code>Class</code>的文件方法表采用了和字段表相同的存储格式，只是<code>access_flags</code>对应的含义有所不同。方法表包含着一个重要的属性：<code>Code</code>属性。<code>Code</code>属性存储了<code>Java</code>代码编译成的字节码指令，在<code>ClassAnalyzer</code>中，<code>Code</code>对应的<code>Java</code>类如下所示（仅列出了类属性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> <span class="keyword">extends</span> <span class="title">BasicAttributeInfo</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> maxStack;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> maxLocals;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> codeLength;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] code;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> exceptionTableLength;</div><div class="line">    <span class="keyword">private</span> ExceptionInfo[] exceptionTable;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">short</span> attributesCount;</div><div class="line">    <span class="keyword">private</span> BasicAttributeInfo[] attributes;</div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionInfo</span> </span>&#123;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> startPc;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> endPc;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> handlerPc;</div><div class="line">        <span class="keyword">public</span> <span class="keyword">short</span> catchType;</div><div class="line">      	...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>Code</code>属性中，<code>codeLength</code>和<code>code</code>分别用于存储字节码长度和字节码指令，每条指令即一个字节（<code>u1</code>类型）。在虚拟机执行时，通过读取<code>code</code>中的一个个字节码，并将字节码翻译成相应的指令。另外，虽然<code>codeLength</code>是一个<code>u4</code>类型的值，但是实际上一个方法不允许超过<code>65535</code>条字节码指令。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><code>ClassAnalyzer</code>的源码已放在了<a href="https://github.com/tinylcy/ClassAnalyzer" target="_blank" rel="external">GitHub</a>上。在<code>ClassAnalyzer</code>的<a href="https://github.com/tinylcy/ClassAnalyzer/blob/master/README.md" target="_blank" rel="external">README</a>中，我以一个类的<code>Class</code>文件为例，对该<code>Class</code>文件的每个字节进行了分析，希望对大家的理解有所帮助。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个私人项目，名字叫做&lt;code&gt;ClassAnalyzer&lt;/code&gt;，&lt;code&gt;ClassAnalyzer&lt;/code&gt;的目的是能让我们对&lt;code&gt;Java Class&lt;/code&gt;文件的设计与结构能够有一个深入的理解。主体框架与基本功能已经完成，还有一些
    
    </summary>
    
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
      <category term="JVM" scheme="http://tinylcy.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP: Shell Lab</title>
    <link href="http://tinylcy.me/2017/01/10/CSAPP-Shell-Lab/"/>
    <id>http://tinylcy.me/2017/01/10/CSAPP-Shell-Lab/</id>
    <published>2017-01-10T08:13:11.000Z</published>
    <updated>2017-04-25T04:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf" target="_blank" rel="external">实验</a>通过实现一个支持作业控制的<code>Unix Shell</code>，让我们对进程控制和信号控制更加熟悉。课程<code>Lab</code>已经帮助我们搭建起了<code>Shell</code>的整体框架，并实现了与本次实验不太相关的代码，核心部分需要我们自己完成。</p>
<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p><code>Shell</code>从标准输入（<code>stdin</code>）读取用户输入的命令，然后解析命令，<code>Shell</code>支持两种类型的命令：如果用户输入的是的内置命令（如<code>quit</code>、<code>jobs</code>等），那么直接执行该命令；如果用户输入的是某个可执行文件的路径，那么通过<code>fork</code>一个子进程，在子进程中加载并执行命令。<code>Shell</code>把每次用户输入的命令抽象为一个<code>job</code>，一个<code>job</code>可以包含多个进程（例如管道）。每个<code>job</code>有两种运行方式，如果用户输入的命令以’<code>&amp;</code>‘结尾，那么<code>job</code>将会在后台（<code>background</code>）运行，否则，<code>job</code>运行在前台（<code>foreground</code>）。在任意时刻，只允许存在<code>0</code>或<code>1</code>个前台<code>job</code>，但是可以有<code>0</code>或多个后台<code>job</code>运行。最后，为了支持用户能够向<code>Shell</code>发送信号，我们还需要实现<code>3</code>个信号处理程序，分别处理信号<code>SIGCHLD</code>、<code>SIGINT</code>和<code>SIGTSTP</code>。</p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><ul>
<li>默认的，一个子进程和它的父进程同属于一个进程组，而<code>Unix</code>系统提供的大量向进程发送信号的机制，都是基于进程组这个概念的。当我们输入<code>Ctrl + C</code>，内核会发送一个<code>SIGINT</code>信号到前台进程组的每个进程，类似的，输入<code>Ctrl + Z</code>会导致内核发送一个<code>SIGTSTP</code>信号给前台进程组中的每个进程。这儿的“前台进程组”指的是<code>Shell</code>进程所属的进程组。实验中，我们并不期望信号直接作用于<code>Shell</code>进程本身（否则<code>Shell</code>收到<code>SIGINT</code>信号就终止了），而是需要让<code>Shell</code>将信号转发给<code>Shell</code>前台作业中的子进程及其所属进程组中的所有进程。所以，我们不能让子进程和<code>Shell</code>进程同属一个进程组。具体做法是通过使用<code>setpgid</code>函数来改变子进程的进程组，当调用<code>setpgid(0, 0)</code>时，内核会创建一个新的进程组，其进程组<code>ID</code>是调用者进程的<code>PID</code>，并且会把调用者进程加入到这个进程组中。</li>
<li>当<code>Shell</code>收到信号时，具体的工作需要信号处理函数来完成。例如收到<code>SIGINT</code>信号，那么信号处理函数会把该信号发往前台<code>job</code>中的进程及其所属进程组中的所有进程。实验中，我们是通过<code>kill(pid_t pid, int sig)</code>来发送信号，注意到我们并不仅仅是向<code>PID = pid</code>的进程发送信号，<code>kill</code>函数帮助我们实现了这一点：如果<code>pid</code>小于<code>0</code>，<code>kill</code>发送信号<code>sig</code>给进程组<code>|pid|</code>（<code>pid</code>的绝对值）中的每个进程。我们可以意识到，上一点需要注意的地方正是为这一点做铺垫的。</li>
<li>父进程（<code>Shell</code>）<code>fork</code>了一个子进程后，父进程需要将这个进程作为一个<code>job</code>添加到<code>job</code>队列中去（<code>addjob</code>），当子进程终止时，内核会发送一个<code>SIGCHLD</code>信号给父进程，然后在相应的信号处理程序中，把终止的子进程对应的<code>job</code>从<code>job</code>队列中删除（<code>deletejob</code>）。考虑一种情况：当父进程<code>fork</code>了一个子进程之后，子进程先于父进程获得调度，并且在父进程执行<code>addjob</code>前，子进程就已经终止了，并发送了<code>SIGCHLD</code>信号给父进程。此时，在信号处理程序中<code>deletejob</code>不会做任何操作，因为此时父进程还没有把<code>job</code>加入到<code>job</code>队列中。出现这个问题的根本原因是在<code>addjob</code>之前调用了<code>deletejob</code>。解决这个问题的方法是：在父进程<code>fork</code>子进程之前，将<code>SIGCHLD</code>信号阻塞，当完成<code>addjob</code>之后，才解除对<code>SIGCHLD</code>信号的阻塞，这样就能保证在子进程被添加到<code>job</code>队列之后再回收该子进程。注意，子进程继承了它们父进程的被阻塞信号集合，所以我们必须在调用<code>execve</code>之前，解除子进程中阻塞的<code>SIGCHLD</code>信号。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><code>Shell Lab</code>的代码在<a href="https://github.com/tinylcy/cmu-15213/tree/master/Shell%20Lab/shlab-handout" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/shlab.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;实验&lt;/a&gt;通过实现一个支持作业控制的&lt;code&gt;Unix Shell&lt;/code&gt;，让我们对进程控制和信号控制更
    
    </summary>
    
    
      <category term="CSAPP" scheme="http://tinylcy.me/tags/CSAPP/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce论文阅读</title>
    <link href="http://tinylcy.me/2017/01/07/MapReduce%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://tinylcy.me/2017/01/07/MapReduce论文阅读/</id>
    <published>2017-01-07T13:03:08.000Z</published>
    <updated>2017-05-12T05:11:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>大四时曾经粗略的阅读过这篇<a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">论文</a>，并且已经写过不少的<code>MapReduce</code>程序，所以介绍性的内容不再赘述。再次阅读这篇论文的原因是为了更系统的学习分布式的相关知识，我开始跟进<a href="http://nil.csail.mit.edu/6.824/2015/index.html" target="_blank" rel="external">MIT 6.824: Distributed Systems</a>，而完成这门课程的第一个<code>lab</code>的前提便是阅读这篇论文。</p>
<p>这篇笔记重点分析了<code>MapReduce</code>的<strong>执行流程</strong>以及<strong>容错机制</strong>，因为是个人理解，若有分析不妥之处欢迎发送邮件至<code>tinylcy (at) gmail.com</code>讨论交流。</p>
<h2 id="Execution-Overview"><a href="#Execution-Overview" class="headerlink" title="Execution Overview"></a>Execution Overview</h2><p>根据不同的环境，<code>MapReduce</code>的实现方式有多种，比如基于共享内存、基于<code>NUMA</code>多处理器环境等等。而<code>Google</code>内部实现的<code>MapReduce</code>基于如下环境。</p>
<ul>
<li>双核<code>x86</code>处理器，<code>Linux</code>操作系统，每台机器有<code>2～4GB</code>的内存。</li>
<li>使用商用的网络设备，例如<code>100M</code>／<code>1G</code>带宽网卡。</li>
<li>集群是由成百上千台上述配置的设备组成的，因此集群中节点出现故障应该视为常态。</li>
<li>存储设备采用的是廉价的<code>IDE</code>硬盘。在这种不可靠的硬件上，<code>Google</code>实现了一个分布式文件系统<code>GFS</code>，通过备份和冗余来保证可靠性和可用性。</li>
<li>用户将作业（<code>job</code>）提交到调度系统，每个作业由多个任务（<code>task</code>）组成，调度系统负责将任务分配到集群空闲的节点上。</li>
</ul>
<p>在<code>Map</code>阶段，输入数据会被自动划分为<code>M</code>个分片，这些分片可以在不同的节点上被并行处理。在<code>Reduce</code>阶段，根据一定的划分规则（例如<code>hash(key) mod R</code>），中间数据会被划分为<code>R</code>个分片，这<code>R</code>个分片也可以被多个节点同时处理。<code>Reduce</code>阶段的分片个数<code>R</code>和分片规则可以由用户指定。<code>MapReduce</code>的执行流程如下图所示。</p>
<p><img src="/img/2017-01-07-Image 1.png" alt="Alt text"></p>
<p>整个执行流程可以划分为如下几个阶段，上图中的数字也标识了这几个阶段。</p>
<ul>
<li>用户程序将输入数据切分为<code>M</code>个分片（分片的大小一般为<code>16～64MB</code>，用户可以设置分片大小），并把用户程序拷贝到集群中的多个节点。因为数据要比程序大得多，所以“拷贝程序”要比“拷贝数据”高效的多。</li>
<li>在拷贝程序到节点的过程中，有一个节点比较特殊：<code>master</code>节点。其余的节点都为<code>worker</code>节点，<code>worker</code>节点负责执行具体的任务，这些任务通过<code>master</code>节点来分配。任务又分为<code>map task</code>和<code>reduce task</code>。</li>
<li>被分配到<code>map task</code>的<code>worker（map worker）</code>会读取相应的输入分片，并将输入分片中的数据解析为一系列的<code>key/value pairs</code>，然后将这些<code>key/value pairs</code>输入到用户定义的<code>map function</code>，<code>map function</code>输出的<code>key/value pairs</code>会被缓存到内存中，而不是直接写入磁盘。</li>
<li>由<code>map function</code>输出的，缓存在内存中的<code>key/value pairs</code>会被划分为<code>R</code>个分区，并定期写入到<strong>本地</strong>磁盘中。写入磁盘的位置会被推送给<code>master</code>节点，<code>master</code>节点会将磁盘的位置信息转发给下一阶段执行<code>reduce</code>任务的节点（<code>reduce worker</code>）。</li>
<li><code>reduce worker</code>在接收到磁盘的位置信息后开始读取相应的磁盘中的数据，当所有的数据读取完毕后，<code>reduce worker</code>会在内存中按照<code>key</code>将所有的<code>key/value pairs</code>进行一次排序。论文认为这次排序是必要的原因是不同的<code>key</code>往往会映射到同一个<code>reduce worker</code>。</li>
<li><code>reducer worker</code>遍历已排好序的<code>key/value pairs</code>，每遇到一个不同的<code>key</code>，便将该<code>key</code>和对应的一系列<code>value</code>传递给用户定义的<code>reduce function</code>，这个过程同时解释了为什么在上一阶段<code>reduce worker</code>要对数据进行排序（论文<code>Section 4.2</code>提到了按照key排序的两个优势，一是支持高效随机按<code>key</code>的查找，二是已经排好序的数据可以方便用户的操作）。<code>reduce function</code>将输出数据<code>append</code>到最终的输出文件中。</li>
<li>当所有的<code>map task</code>和<code>reduce task</code>都完成了，<code>master</code>唤醒用户程序并返回。</li>
</ul>
<p>在执行完整个流程后，会有<code>R</code>个输出文件，每个<code>reduce worker</code>对应一个。这<code>R</code>个输出文件一般不需要合并，因为它们往往是下一个<code>MapReduce</code>处理逻辑的输入数据。</p>
<h2 id="Master-Data-Structures"><a href="#Master-Data-Structures" class="headerlink" title="Master Data Structures"></a>Master Data Structures</h2><ul>
<li><code>master</code>会记录每个<code>map task</code>和<code>reduce task</code>的状态，包括<code>idle</code>、<code>in-progress</code>和<code>completed</code>。同时，<code>master</code>还会记录<code>non-idle task</code>对应的<code>worker</code>的信息。</li>
<li>对于每个<code>map task</code>，<code>master</code>会记录下<code>map function</code>输出的<code>R</code>个分片的位置信息和大小。这些信息会被推送到处于<code>in-progress</code>状态的<code>reduce worker</code>上。</li>
</ul>
<h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>由于运行在规模庞大并且廉价的硬件上，因此容错性变得非常重要。</p>
<h3 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h3><p><code>master</code>会定期<code>ping</code> <code>worker</code>，如果<code>worker</code>没有响应并且超过了一定的次数，那么<code>master</code>就认为<code>worker</code>已经<code>failed</code>了。因此，所有在该<code>worker</code>上完成的<code>task</code>的状态将会被重置为初始的<code>idle</code>状态，并且这些<code>task</code>需要被重新分配到其它的<code>worker</code>上去。类似的，该<code>worker</code>上处于<code>in-progress</code>状态的<code>task</code>也会被重置为最初的<code>idle</code>状态，并被重新分配到其它<code>worker</code>上去。</p>
<p>对于已完成的<code>map task</code>，也需要重新被执行。因为<code>map task</code>的输出是在<code>worker</code>的本地磁盘上，因为<code>worker</code>已经失联了，所以<code>map task</code>的输出数据自然也获取不到。对于已完成的<code>reduce task</code>，不再需要重新执行。因为<code>reduce task</code>的输出是在全局的文件系统（<code>GFS</code>）上。</p>
<p>如果一个<code>map task</code>一开始运行在<code>worker A</code>上，接着由于<code>worker A</code> <code>failed</code>导致该<code>map task</code>迁移到<code>worker B</code>上。那么读取该<code>map task</code>输出数据并且处于正在执行的<code>reduce worker</code>会收到重新执行<code>reduce task</code>的通知，任何还未开始读取数据的<code>reduce task</code>也会收到通知。<code>reduce worker</code>接下来会从<code>worker B</code>上读取数据。</p>
<h3 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h3><p>可以通过定期建立检查点的方式来保存<code>master</code>的状态。但是，<code>Google</code>当时的做法是考虑到只有一个<code>master</code>，所以<code>master</code>出现故障的概率很小，如果出现故障了，重新开始整个<code>MapReduce</code>计算。</p>
<h2 id="Locality"><a href="#Locality" class="headerlink" title="Locality"></a>Locality</h2><p>网络带宽在计算环境中属于一种非常稀缺的资源，利用输入数据的特性可以减小网络带宽。</p>
<ul>
<li>输入数据由<code>GFS</code>来管理，<code>GFS</code>把数据存储在集群节点的本地磁盘上，<code>GFS</code>将文件分割为<code>64MB</code>大小的块，并且针对每个块会做冗余（一般冗余<code>2</code>份）。<code>master</code>利用输入数据的位置信息，将<code>map task</code>分配给输入数据所在的节点。</li>
<li>如果在计算过程中出现了失败的情况，那么<code>master</code>会把任务调度给离输入数据较近的节点。</li>
</ul>
<h2 id="Task-Granularity"><a href="#Task-Granularity" class="headerlink" title="Task Granularity"></a>Task Granularity</h2><p>从上文我们可以得知，<code>map</code>阶段被划分成<code>M</code>个<code>task</code>，<code>reduce</code>阶段被划分成<code>R</code>个<code>task</code>，<code>M</code>和<code>R</code>一般会比集群中节点的个数大得多。每个节点运行多个<code>task</code>有利于动态的负载均衡，加速<code>worker</code>从失败中恢复。</p>
<p>在具体的实现中，<code>M</code>和<code>R</code>的大小是有实际限制的，因为<code>master</code>至少要做<code>O(M＋R)</code>次的调度决策，并且需要保持<code>O(M*R)</code>个状态。</p>
<p>通常情况下，<code>R</code>的大小是由用户指定的，而对<code>M</code>的选择要保证每个<code>task</code>的输入数据大小，即一个输入分片在<code>16MB～64MB</code>之间，这样可以最大化的利用数据本地性。</p>
<h2 id="Backup-Tasks"><a href="#Backup-Tasks" class="headerlink" title="Backup Tasks"></a>Backup Tasks</h2><p>导致整个<code>MapReduce</code>计算过程被延迟的原因之一是过多的时间花费在最后几个<code>map task</code>或<code>reduce task</code>上。导致这个问题的原因由很多，可能是因为<code>task</code>所在的节点硬盘的读写速度非常慢，同时<code>master</code>又有可能把新的<code>task</code>分配给了该节点，所以引入了更加激烈的<code>CPU</code>竞争、内存竞争。</p>
<p>一种通用的解决方案是在整个<code>MapReduce</code>计算快要结束时，<code>master</code>对当前处于<code>in-progress</code>状态的<code>task</code>进行备份，无论是原来的<code>task</code>执行完毕还是备份的<code>task</code>执行完毕，那么就认为该<code>task</code>完成了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce: Simplified Data Processing on Large Clusters</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大四时曾经粗略的阅读过这篇&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf&quot; target=&quot;_blank&quot;
    
    </summary>
    
    
      <category term="DistributedSystems" scheme="http://tinylcy.me/tags/DistributedSystems/"/>
    
  </entry>
  
  <entry>
    <title>Bigtable论文阅读</title>
    <link href="http://tinylcy.me/2017/01/04/Bigtable%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://tinylcy.me/2017/01/04/Bigtable论文阅读/</id>
    <published>2017-01-04T11:53:17.000Z</published>
    <updated>2017-05-12T05:11:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我对Bigtable论文进行第一轮阅读所做的笔记。对于理解欠妥的地方，欢迎发送邮件至<code>tinylcy (at) gmail.com</code>讨论。</p>
<a id="more"></a>
<h2 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h2><blockquote>
<p>A Bigtable is a sparse, distributed, persistent multi-dimensional sorted map. The map is indexed by a row key, column key, and a timestamp; each value in the map is an uninterpreted arrays of bytes.</p>
</blockquote>
<p>Bigtable是稀疏的、分布式的、持久化的、多维度的、顺序的map，我们可以将Bigtable的数据模型抽象为一系列的键值对，满足的映射关系为：<code>(row:string, column:string, time:int64) -&gt; string</code>。</p>
<p><img src="/img/2017-01-04-Image 1.png" alt=""></p>
<blockquote>
<p>A slice of an example table that stores Web pages. The row name is a reversed URL. The contents column family contains the page contents, and the anchor column family contains the text of any anchors that reference the page. CNN’s home page is referenced by both the Sports Illustrated and the MY-look home pages, so the row contains columns named anchor:cnnsi.com and anchor:my.look.ca. Each anchor cell has one version; the contents column has three versions, at timestamps t3 , t5 , and t6.</p>
</blockquote>
<h3 id="Rows"><a href="#Rows" class="headerlink" title="Rows"></a>Rows</h3><blockquote>
<ul>
<li>The row keys in a table are arbitrary strings.</li>
<li>Bigtable maintains data in lexicographic order by row key.</li>
<li>The row range for a table is dynamically partitioned. Each row range is called a tablet, which is the unit of distribution and load balancing.</li>
</ul>
</blockquote>
<ul>
<li>Bigtable内部的行键（row key）会按照字典序排序，因为系统庞大且为分布式，所以排序这个特性会带来很大的好处，行的空间邻近性可以确保当我们在扫描表时，我们感兴趣的记录会大概率的汇聚到一起。</li>
<li>Tablet是Bigtable分配和负载均衡的单元，Bigtable的表根据行键自动划分为tablet。最初表都只有一个tablet，但随着表的不断增大，原始的tablet自动分割为多个tablet。</li>
</ul>
<h3 id="Column-Families"><a href="#Column-Families" class="headerlink" title="Column Families"></a>Column Families</h3><blockquote>
<ul>
<li>Column keys are grouped into sets called column families, which form the basic unit of access control.</li>
<li>All data stored in a column family is usually of the same type.</li>
<li>A column family must be created before data can be stored under any column key in that family; after a family has been created, any column key within the family can be used.</li>
<li>Column families rarely change during operation. In contrast, a table may have an unbounded number of columns.</li>
</ul>
</blockquote>
<ul>
<li>Bigtable把所有的列划分为若干个列族（column family），每个列族一般存储相同类型的数据。关于这点，我联想到在大部分的NoSQL数据库中，始终贯穿的一个理念就是<strong>面向聚合</strong>，NoSQL往往是应用在集群环境中，而在集群环境下的跨表JOIN实现起来会比单机关系型数据库复杂的多，所以在设计表时，我们就把相同类型的数据尽可能汇聚在一起，即每个列族一般存储相同类型的数据。</li>
<li>一行的列族很少变化（改变的开也会比较大），但是列族里的列是允许随意增减的。列键（column key）是通过family:qualifier来定位的。</li>
</ul>
<h3 id="Timestamps"><a href="#Timestamps" class="headerlink" title="Timestamps"></a>Timestamps</h3><blockquote>
<ul>
<li>Each cell in a Bigtable can contain multiple versions of the same data; these versions are indexed by timestamp.</li>
<li>Different versions of a cell are stored in decreasing timestamp order, so that the most recent version can be read first.</li>
</ul>
</blockquote>
<ul>
<li>对于具有相同行键（row key）和列键（column key）的数据（cell），Bigtable会存储这个数据的多个版本，这些版本通过时间戳来区分，用户可以版本的数量。</li>
<li>数据按照时间戳降序排序，这样可以保证取到的数据是最新的。同时，过期的数据也会被回收。</li>
</ul>
<p>我们现在再回顾论文一开始便提到的：A Bigtable is a … map，传统的map由一系列键值对组成，在Bigtable中，对应的键是由多个数据复合而成的，即row key，column key和timestamp。</p>
<h2 id="Building-Blocks"><a href="#Building-Blocks" class="headerlink" title="Building Blocks"></a>Building Blocks</h2><p>Bigtable的实现依托于Google的几个基础组件：Google File System，Google SSTable 和 Chubby。</p>
<blockquote>
<ul>
<li>Bigtable uses the distributed Google File System(GFS)  to store log and data files.</li>
<li>The Google SSTable file format is used internally to store Bigtable data. An SSTable provides a persistent, ordered immutable map from keys to values.</li>
<li>Bigtable relies on a highly-available and persistent distributed lock service called Chubby. Bigtable uses Chubby for a variety of tasks.<ul>
<li>to ensure that there is at most one active master at any time;</li>
<li>to store bootstrap location of Bigtable data;</li>
<li>to discover tablet servers and finalize tablet server deaths;</li>
<li>to store access control lists;</li>
</ul>
</li>
</ul>
</blockquote>
<p>Chubby是一个高可靠用于分布式的锁服务，其目的是解决分布式一致性的问题，通过Paxos算法实现。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Bigtable的系统结构由三个部分组成，包括客户端中用于通信的Library、一个主节点（master server）和一系列从节点（tablet servers）。整个架构可以从下图清晰的体现出来。</p>
<p><img src="/img/2017-01-04-Image 2.jpg" alt=""></p>
<blockquote>
<ul>
<li>The master is responsible for assigning tablets to tablet servers, detecting the addition and expiration of tablet servers, balancing tablet-server load, and garbage collection of files in GFS.</li>
<li>Each tablet server manages a set of tablets and handles read and write requests to the tablets that it has load, and also splits tablets that have grown too large.</li>
</ul>
</blockquote>
<p>需要注意的是，客户端在读写数据时直接和tablet server通信，不需要经过master server，而且在Bigtable中，客户端获取tablet位置信息也不依赖于master server。因此在大多数情况下，客户端都不会和master server通信，这就大大降低了由单个master server造成的单点故障的可能性。关于这点我们从上图也可以得知。</p>
<h3 id="Tablet-Location"><a href="#Tablet-Location" class="headerlink" title="Tablet Location"></a>Tablet Location</h3><p>前面已经提到，客户端在获取tablet位置信息时并不需要经过master server，那么tablet的位置信息时如何定位的？首先，需要了解tablet的位置信息是如何存储的。Bigtable通过类似B+树的结构来存储tablet的位置信息，如下图所示。</p>
<p><img src="/img/2017-01-04-Image 3.png" alt=""></p>
<blockquote>
<ul>
<li>The first level is a file stored in Chubby that contains the location of the root tablet. The root tablet contains the location of all tablets in a special METADATA table.</li>
<li>Each METADATA tablet contains the location of a set of user tables.</li>
</ul>
</blockquote>
<p>Root tablet存储了一系列METADATA tablet的位置信息，而user tablet的位置信息存储在这些METADATA tablets中。论文中提到root tablet是不允许被分片的，这么做的目的是保证整个tablet location hierarchy不超过3层。这意味着Bigtable的数据存储还是有上限的，于是论文计算了3层架构能够存储的tablet的数量。</p>
<blockquote>
<p>Each METADATA row stores approximately 1KB of data in memory. With a modest limit of 128 MB METADATA tablets, our three-level location scheme is sufficient to address 2^34 tablets (or 2^61 bytes in 128 MB tablets).</p>
</blockquote>
<p>客户端会缓存tablet的位置信息，客户端在获取tablet的位置信息时，会涉及到两种情况。</p>
<ul>
<li>如果客户端没有缓存目标tablet的位置信息，那么就会沿着root tablet定位到最终的tablet，整个过程需要3个network round-trips。</li>
<li>如果客户端缓存了目标tablet的位置信息，但是到了目标tablet后发现原来缓存的tablet位置信息过时了，那么会重新从root tablet开始定位tablet，整个过程需要6个network round-trips。</li>
</ul>
<h3 id="Tablet-Assignment"><a href="#Tablet-Assignment" class="headerlink" title="Tablet Assignment"></a>Tablet Assignment</h3><p>当tablet server启动时，它会在Chubby的某个特定目录下创建并获取一个锁文件（互斥锁），这个锁文件的名称是唯一表示该tablet server的。master server通过监控这个目录获取当前存活着的tablet server的信息。</p>
<ul>
<li>如果tablet server失去了锁（比如网络问题），那么tablet server也就不再为对应的tablet服务了。</li>
<li>如果锁文件存在，那么tablet server会主动获取锁。</li>
<li>如果所文件不存在了，那么tablet server就永远不会再服务对应的tablet了，所以tablet server就会自己kill掉自己。</li>
<li>当tablet server要终止时，它会自己释放占有的锁，master server就会把该tablet server上的tablet分配给其它的tablet server。</li>
</ul>
<p>那么maser server是如何获知tablet server不再服务了呢？master server会定期轮询每个tablet server的锁状态。如果tablet server报告自己失去了已经失去了锁，或者master server不能获取tablet server的状态，那么master server就会尝试去获取tablet server对应的锁文件。如果master server获取到了所文件，并且Chubby是处于正常工作的状态的，此时master server就确认tablet server已经无法再提供服务了，master server删除相应的锁文件并把tablet server对应的tablet分配给新的tablet server。</p>
<p>如果master server与Chubby之间出现了网络问题，那么master server会自己kill掉自己。但是这并不会影响tablet与tablet server之间的分配关系。</p>
<p>master server的启动需要经历一下几个阶段。</p>
<ul>
<li>master server需要从Chubby获取锁，这样可以确保在同一时刻只有一个master server在工作。</li>
<li>master server扫描Chubby下特定的目录（即tablet server创建锁文件的目录），获取存活着的tablet server的信息。</li>
<li>master server与存活着的tablet server通信，获取已被分配到tablet server的tablet信息。</li>
<li>master server扫描METADATA tablet，获取所有的tablet信息，然后把未分配的tablet分配给tablet server。</li>
</ul>
<p>在论文Section 5.2中有一段话还有待理解，如下。</p>
<blockquote>
<p>One complication is that the scan of the METADATA table cannot happen until the METADATA tablets have been assigned. Therefore, before starting this scan (step 4), the master adds the roottablet to the set of unassigned tablets if an assignment for the root tablet was not discovered during step 3. This addition ensures that the root tablet will be assigned. Because the root tablet contains the names of all METADATA tablets, the master knows about all of them after it has scanned the root tablet.</p>
</blockquote>
<p>当出现如下几种情况时，tablet的分配情况会发生变化。</p>
<ul>
<li>tablet的创建和删除。</li>
<li>已有的两个tablet合并为一个较大的tablet。</li>
<li>已有的一个tablet分割为两个较小的tablet。</li>
</ul>
<p>对于前两种情况，master server可以马上调整（因为它们是发生在master server上的），但是对于tablet分割，由于它是发生在tablet server上的，因此需要tablet server通知master server。论文关于这一点的描述如下。</p>
<blockquote>
<p>The tablet server commits the split by recording information for the new tablet in the METADATA table. When the split has committed, it notifies the master.</p>
</blockquote>
<h3 id="Tablet-Serving"><a href="#Tablet-Serving" class="headerlink" title="Tablet Serving"></a>Tablet Serving</h3><p>tablet的持久化是通过存储为GFS文件的形式实现的，下图描述了tablet更新操作的实现。</p>
<p><img src="/img/2017-01-04-Image 4.png" alt=""></p>
<p>当发生更新时，首先将更新操作写到tablet log日志文件中去，然后把待更新的内容先写到memtable中，memtable是内存中一个排序的缓冲，保存了最近的一次更新操作的内容。更早的更新内容会被持久化到SSTable文件中。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf" target="_blank" rel="external">Bigtable: A Distributed Storage System for Structured Data</a></li>
<li><a href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable" target="_blank" rel="external">Understanding HBase and BigTable</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我对Bigtable论文进行第一轮阅读所做的笔记。对于理解欠妥的地方，欢迎发送邮件至&lt;code&gt;tinylcy (at) gmail.com&lt;/code&gt;讨论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DistributedSystems" scheme="http://tinylcy.me/tags/DistributedSystems/"/>
    
  </entry>
  
  <entry>
    <title>2016年度总结及2017年度计划</title>
    <link href="http://tinylcy.me/2017/01/01/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E5%8F%8A2017%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    <id>http://tinylcy.me/2017/01/01/2016年度总结及2017年度计划/</id>
    <published>2016-12-31T18:24:14.000Z</published>
    <updated>2017-04-25T04:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>从<code>2016</code>年<code>12</code>月开始持续使用<a href="https://pomotodo.com/" target="_blank" rel="external">Pomotodo</a>起，我逐渐意识到给自己定下量化计划是一件能够提升学习效率的事情。<code>2017</code>年的核心目标依然是提高自己，但是会采用具体的量化的指标来代替模糊性描述。其实这就类似于我们在<code>git commit</code>时候，如果以<code>git commit -m &quot;fix some bugs&quot;</code>的形式<code>commit</code>，那么在后期这些<code>descriptions</code>并不会带给我们任何帮助。</p>
<h3 id="2016总结"><a href="#2016总结" class="headerlink" title="2016总结"></a>2016总结</h3><ul>
<li><code>2016</code>年<code>3</code>月至<code>6</code>月我需要完成学校的课程，但是总体来说，课程的质量不算高，我没有在这些课程及考试上花太多的时间，但是尴尬的是我拿了一等学业奖学金（逃。</li>
<li>在课程及暑假期间我参与了一个网站外包项目。对我而言，这个项目最大的意义在于让我了解除了开发以外的工作，包括文档的编写、与人的沟通。在大型软件的开发过程中，最大的问题可能不是技术问题，而是<code>people problem</code>。</li>
<li><code>2016</code>年读了不少书，有些书读完了，有些书拣一部分读。经典技术书籍主要包括《<code>C</code>程序设计语言》（<code>100%</code>）、《<code>C Primer Plus</code>》（<code>60%</code>）、《<code>Linux/UNIX</code>系统编程手册》（<code>60%</code>）、《算法》（<code>50%</code>）、《深入理解<code>Java</code>虚拟机》（<code>50%</code>）、《图解<code>HTTP</code>》（<code>90%</code>）、《深入理解计算机系统》（<code>40%</code>）、《大型网站技术架构》（<code>100%</code>）、《深入分析<code>Java Web</code>》（<code>70%</code>）。其它书籍包括《白夜行》、《解忧杂货店》、《人类简史》、《活着》、《平凡的世界》等。</li>
<li><code>2016</code>年最大的惊喜发生在最后一天。我的学生生涯第一篇一作<code>SCI</code>被录用。从学术和技术的角度上说，我个人认为我的论文存在诸多不足之处，但是这篇论文对我而言象征意义重大。感谢我的导师。</li>
<li><code>2016</code>年我开始花时间运营自己的<a href="http://tinylcy.me/">博客</a>，我把我的博客迁移到了<code>Github</code>，并购买了域名，开始注重技术文章的质量以及文章的脉络。</li>
<li><code>2016</code>年我的个人小项目<a href="https://github.com/tinylcy/RecommendationEngine" target="_blank" rel="external">RecommendationEngine</a>在<code>Github</code>上收集到了一丢丢的<code>stars</code>和<code>forks</code>。为了更好的学习网络编程，我开始编写一个轻量级的<code>Web</code> 服务器<a href="https://github.com/tinylcy/tinyhttpd" target="_blank" rel="external">tinyhttpd</a>，目前<code>tinyhttpd</code>的主体框架和基本功能已完成。</li>
<li><code>2016</code>年<code>12</code>月开始，我开始跟随视频学习《深入理解计算机系统》，课程全英文且无字幕，在边听边理解了两节课后，除了感叹授课老师深厚的功底之外，我的英语听力也有所提升，至少目前听课不会感到不适了。</li>
<li>入手<code>MacBook Pro</code>。</li>
<li><code>2016</code>年最不满意的一点是我的身体保持的很不好，严重缺少身体机能上的锻炼。</li>
</ul>
<h3 id="2017计划"><a href="#2017计划" class="headerlink" title="2017计划"></a>2017计划</h3><ul>
<li>身体是本钱，每周要强制性体育锻炼，每周的跑步次数大于等于<code>3</code>次。</li>
<li>继续完善自己的知识架构，努力把计算机系统的基础知识形成闭环，完成《深入理解计算机系统》第一轮的全面阅读。</li>
<li><code>2017</code>年有两件对我而言可能是非常重要的事情，一是实习，二是校招。从二月份开始要针对性的进行准备。</li>
<li>开始准备研究生阶段的第二篇论文，同时作为研究生的毕业设计。</li>
<li>继续读书，将<code>2016</code>年未读完的部分读完，并继续阅读计算机科学领域的经典书籍。</li>
<li>争取能够阅读一个开源项目的源码（部分也行）。</li>
<li>锻炼自己的自律能力和观察能力，学会从不同角度看待问题。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从&lt;code&gt;2016&lt;/code&gt;年&lt;code&gt;12&lt;/code&gt;月开始持续使用&lt;a href=&quot;https://pomotodo.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pomotodo&lt;/a&gt;起，我逐渐意识到给自己定下量化计划是一件能
    
    </summary>
    
    
      <category term="Life" scheme="http://tinylcy.me/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC容器初始化 — Resource定位源码分析</title>
    <link href="http://tinylcy.me/2016/12/07/Spring-IoC%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E2%80%94Resource%E5%AE%9A%E4%BD%8D%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/12/07/Spring-IoC容器初始化—Resource定位源码分析/</id>
    <published>2016-12-07T07:53:56.000Z</published>
    <updated>2017-04-25T04:48:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>Spring IoC</code>容器的设计中，有两个主要的容器系列。一个是实现了<code>BeanFactory</code>接口的简单容器系列，这系列容器只实现了容器基本的功能；另一个是<code>ApplicationContext</code>应用上下文，它在简单容器的基础上增加了许多面向框架的特性，同时对应用环境做了许多适配。</p>
<h2 id="IoC容器的初始化过程"><a href="#IoC容器的初始化过程" class="headerlink" title="IoC容器的初始化过程"></a>IoC容器的初始化过程</h2><p><code>Spring IoC</code>容器的初始化过程分为三个阶段：<code>Resource</code>定位、<code>BeanDefinition</code>的载入和向<code>IoC</code>容器注册<code>BeanDefinition</code>。<code>Spring</code>把这三个阶段分离，并使用不同的模块来完成，这样可以让用户更加灵活的对这三个阶段进行扩展。</p>
<ul>
<li><code>Resource</code>定位指的是<code>BeanDefinition</code>的资源定位，它由<code>ResourceLoader</code>通过统一的<code>Resource</code>接口来完成，<code>Resource</code>对各种形式的<code>BeanDefinition</code>的使用都提供了统一的接口。</li>
<li><code>BeanDefinition</code>的载入是把用户定义好的<code>Bean</code>表示成<code>IoC</code>容器内部的数据结构，而这个容器内部的数据结构就是<code>BeanDefinition</code>，<code>BeanDefinition</code>实际上就是<code>POJO</code>对象在<code>IoC</code>容器中的抽象。通过<code>BeanDefinition</code>，<code>IoC</code>容器可以方便的对<code>POJO</code>对象进行管理。</li>
<li>向<code>IoC</code>容器注册<code>BeanDefinition</code>是通过调用<code>BeanDefinitionRegistry</code>接口的实现来完成的，这个注册过程是把载入的<code>BeanDefinition</code>向<code>IoC</code>容器进行注册。实际上，在<code>IoC</code>容器内部维护着一个<code>HashMap</code>，而这个注册过程其实就将<code>BeanDefinition</code>添加至这个<code>HashMap</code>。</li>
</ul>
<p>我们可以自己定义<code>Resource</code>、<code>BeanFactory</code>和<code>BeanDefinitionReader</code>来初始化一个容器。如下代码片段使用了<code>DefaultListableBeanFactory</code>作为实际使用的<code>IoC</code>容器。同时，创建<code>IoC</code>配置文件（<code>dispatcher-servlet.xml</code>）的抽象资源，这个抽象资源包含了<code>BeanDefinition</code>的定义信息。最后，还需要创建一个载入<code>BeanDefinition</code>的读取器，此处使用<code>XmlBeanDefinitionReader</code>，通过一个回调配置给<code>BeanFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"dispatcher-servlet.xml"</span>);</div><div class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</div><div class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</div><div class="line">reader.loadBeanDefinitions(res);</div></pre></td></tr></table></figure>
<p>我们也可以通过<code>ApplicationContext</code>创建一个<code>IoC</code>容器。在<code>Spring</code>中，系统已经提供许多定义好的容器实现，而不需要自己组装。如下代码片段以<code>FileSystemXmlApplicationContext</code>为例创建了一个<code>IoC</code>容器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FileSystemXmlApplicationContext context = </div><div class="line">        <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:dispatcher-servlet.xml"</span>);</div></pre></td></tr></table></figure>
<p>无论使用哪种方式初始化<code>IoC</code>容器，都会经历上述三个阶段。本篇文章将结合<code>Spring 4.0.2</code>源码，并以<code>FileSystemXmlApplicationContext</code>为例对<code>IoC</code>容器初始化的第一阶段，也就是<code>Resource</code>定位阶段进行分析。</p>
<h2 id="BeanDefinition的Resource定位"><a href="#BeanDefinition的Resource定位" class="headerlink" title="BeanDefinition的Resource定位"></a>BeanDefinition的Resource定位</h2><p>下图展示了<code>FileSystemXmlApplicationContext</code>的继承体系，<code>FileSystemXmlApplicationContext</code>继承自<code>AbstractApplicationContext</code>，而<code>AbstractApplicationContext</code>又继承自<code>DefaultResourceLoader</code>，<code>DefaultResourceLoader</code>实现了<code>ResourceLoader</code>接口。因此<code>FileSystemXmlApplicationContext</code>具备读取定义了<code>BeanDefinition</code>的<code>Resource</code>的能力。</p>
<p><img src="/img/2016-12-07-Image 1.png" alt="Alt text"></p>
<p>我们的分析入口是<code>new FileSystemXmlApplicationContext(&quot;classpath:dispatcher-servlet.xml&quot;);</code>，这句代码调用了<code>FileSystemXmlApplicationContext</code>的构造方法。<code>FileSystemXmlApplicationContext</code>的构造方法源码如下（只提取与本次分析关联的代码）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> String[]&#123;configLocation&#125;, <span class="keyword">true</span>, (ApplicationContext)<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, 	</span></span></div><div class="line">                                       ApplicationContext parent) <span class="keyword">throws</span> BeansException &#123;</div><div class="line">    <span class="keyword">super</span>(parent);</div><div class="line">    <span class="keyword">this</span>.setConfigLocations(configLocations);</div><div class="line">    <span class="keyword">if</span>(refresh) &#123;</div><div class="line">        <span class="keyword">this</span>.refresh();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建<code>FileSystemXmlApplicationContext</code>时，我们仅传入了包含<code>BeanDefinition</code>的配置文件路径（<code>classpath:dispatcher-servlet.xml</code>），由此调用<code>FileSystemXmlApplicationContext(String configLocation)</code>构造方法。接着，<code>FileSystemXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)</code>构造方法被间接调用，在该构造方法内部，<code>refresh</code>方法完成了整个<code>IoC</code>容器的初始化。因此，<code>refresh</code>方法是我们分析的下一个入口。</p>
<p><code>refresh</code>方法的具体实现定义在<code>FileSystemXmlApplicationContext</code>的父类<code>AbstractApplicationContext</code>中，对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">    Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">        <span class="keyword">this</span>.prepareRefresh();</div><div class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</div><div class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</div><div class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</div><div class="line">            <span class="keyword">this</span>.initMessageSource();</div><div class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</div><div class="line">            <span class="keyword">this</span>.onRefresh();</div><div class="line">            <span class="keyword">this</span>.registerListeners();</div><div class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</div><div class="line">            <span class="keyword">this</span>.finishRefresh();</div><div class="line">        &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</div><div class="line">            <span class="keyword">this</span>.destroyBeans();</div><div class="line">            <span class="keyword">this</span>.cancelRefresh(var5);</div><div class="line">            <span class="keyword">throw</span> var5;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>refresh</code>方法中，通过<code>obtainFreshBeanFactory</code>方法，<code>ConfigurableListableBeanFactory</code>类型的<code>BeanFactory</code>被创建。我们接着进入<code>obtainFreshBeanFactory</code>方法，<code>obtainFreshBeanFactory</code>方法也定义在<code>AbstractApplicationContext</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.refreshBeanFactory();</div><div class="line">    ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.getBeanFactory();</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Bean factory for "</span> + <span class="keyword">this</span>.getDisplayName() + <span class="string">": "</span> + beanFactory);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> beanFactory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException</span>;</div></pre></td></tr></table></figure>
<p>我们重点关注<code>refreshBeanFactory</code>方法的实现。在<code>AbstractApplicationContext</code>中，<code>refreshBeanFactory</code>方法仅仅是个声明，具体的实现委托给了子类完成。此处，<code>refreshBeanFactory</code>方法的具体实现定义在了<code>AbstractRefreshableApplicationContext</code>，<code>AbstractRefreshableApplicationContext</code>正是继承自<code>AbstractApplicationContext</code>，这点我们可以从上文的继承体系图可以得知。<code>refreshBeanFactory</code>方法在<code>AbstractRefreshableApplicationContext</code>中的定义如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</div><div class="line">        <span class="keyword">this</span>.destroyBeans();</div><div class="line">        <span class="keyword">this</span>.closeBeanFactory();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        DefaultListableBeanFactory ex = <span class="keyword">this</span>.createBeanFactory();</div><div class="line">        ex.setSerializationId(<span class="keyword">this</span>.getId());</div><div class="line">        <span class="keyword">this</span>.customizeBeanFactory(ex);</div><div class="line">        <span class="keyword">this</span>.loadBeanDefinitions(ex);</div><div class="line">        Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">            <span class="keyword">this</span>.beanFactory = ex;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException var5) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory var1)</span> <span class="keyword">throws</span> BeansException, IOException</span>;</div></pre></td></tr></table></figure>
<p><code>refreshBeanFactory</code>方法首先会判断是否已经建立的<code>BeanFactory</code>，如果已经建立，那么需要销毁并关闭该<code>BeanFactory</code>。接着，<code>refreshBeanFactory</code>方法通过<code>createBeanFactory</code>方法创建了一个<code>IoC</code>容器供<code>ApplicationContext</code>使用，且这个<code>IoC</code>容器的实际类型为<code>DefaultListableBeanFactory</code>。同时，<code>refreshBeanFactory</code>方法将这个<code>IoC</code>容器作为参数，调用<code>loadBeanDefinitions</code>载入了<code>BeanDefinition</code>（本文暂不分析载入过程的具体操作）。</p>
<p><code>loadBeanDefinitions</code>方法也仅仅在<code>AbstractRefreshableApplicationContext</code>中声明，具体的实现定义在<code>AbstractXmlApplicationContext</code>中，从继承体系图我们可以得知<code>AbstractXmlApplicationContext</code>正是<code>AbstractRefreshableApplicationContext</code>的子类。<code>loadBeanDefinitions</code>方法对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</div><div class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</div><div class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</div><div class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</div><div class="line">    <span class="keyword">this</span>.initBeanDefinitionReader(beanDefinitionReader);</div><div class="line">    <span class="keyword">this</span>.loadBeanDefinitions(beanDefinitionReader);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</div><div class="line">    Resource[] configResources = <span class="keyword">this</span>.getConfigResources();</div><div class="line">    <span class="keyword">if</span>(configResources != <span class="keyword">null</span>) &#123;</div><div class="line">        reader.loadBeanDefinitions(configResources);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    String[] configLocations = <span class="keyword">this</span>.getConfigLocations();</div><div class="line">    <span class="keyword">if</span>(configLocations != <span class="keyword">null</span>) &#123;</div><div class="line">        reader.loadBeanDefinitions(configLocations);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>loadBeanDefinitions(DefaultListableBeanFactory beanFactory)</code>中，定义了<code>BeanDefinition</code>的读入器<code>beanDefinitionReader</code>。<code>Spring</code>把定位、读入和注册的过程解耦，这正是体现之处之一。接着<code>beanDefinitionReader</code>作为参数，调用<code>loadBeanDefinitions(XmlBeanDefinitionReader reader)</code>方法，如果<code>configResources</code>为空，那么<code>reader</code>就会根据<code>configLocations</code>调用<code>reader</code>的<code>loadBeanDefinitions</code>去加载相应的<code>Resource</code>。在<code>AbstractBeanDefinitionReader</code>和<code>XmlBeanDefinitionReader</code>中个自定义了不同的<code>loadBeanDefinitions</code>方法，与我们本次分析相关的代码定义在<code>AbstractBeanDefinitionReader</code>中，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    String[] var3 = locations;</div><div class="line">    <span class="keyword">int</span> var4 = locations.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</div><div class="line">        String location = var3[var5];</div><div class="line">        counter += <span class="keyword">this</span>.loadBeanDefinitions(location);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBeanDefinitions(location, (Set)<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">    ResourceLoader resourceLoader = <span class="keyword">this</span>.getResourceLoader();</div><div class="line">    <span class="keyword">if</span>(resourceLoader == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Cannot import bean definitions from location ["</span> + location + <span class="string">"]: no ResourceLoader available"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">int</span> loadCount;</div><div class="line">        <span class="keyword">if</span>(!(resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver)) &#123;</div><div class="line">            Resource var11 = resourceLoader.getResource(location);</div><div class="line">            loadCount = <span class="keyword">this</span>.loadBeanDefinitions((Resource)var11);</div><div class="line">            <span class="keyword">if</span>(actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">                actualResources.add(var11);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> loadCount;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Resource[] resource =</div><div class="line">                    ((ResourcePatternResolver)resourceLoader).getResources(location);</div><div class="line">                loadCount = <span class="keyword">this</span>.loadBeanDefinitions(resource);</div><div class="line">                <span class="keyword">if</span>(actualResources != <span class="keyword">null</span>) &#123;</div><div class="line">                    Resource[] var6 = resource;</div><div class="line">                    <span class="keyword">int</span> var7 = resource.length;</div><div class="line"></div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> var8 = <span class="number">0</span>; var8 &lt; var7; ++var8) &#123;</div><div class="line">                        Resource resource1 = var6[var8];</div><div class="line">                        actualResources.add(resource1);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span> + location + <span class="string">"]"</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> loadCount;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException var10) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>, var10);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources)</code>方法中，我们可以看到，<code>Resource</code>的定位工作交给了<code>ResourceLoader</code>来完成。对于取得<code>Resource</code>的具体过程，我们可以看看<code>DefaultResourceLoader</code>是怎样完成的，对应源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</div><div class="line">    Assert.notNull(location, <span class="string">"Location must not be null"</span>);</div><div class="line">    <span class="keyword">if</span>(location.startsWith(<span class="string">"classpath:"</span>)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(<span class="string">"classpath:"</span>.length()),</div><div class="line">                                     <span class="keyword">this</span>.getClassLoader());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            URL ex = <span class="keyword">new</span> URL(location);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UrlResource(ex);</div><div class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException var3) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getResourceByPath(location);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们传入的<code>location</code>为<code>classpath:dispatcher-servlet.xml</code>，因此<code>getResource</code>方法会生成一个<code>ClassPathResource</code>并返回，如果我们传入的是一个文件路径，那么会调用<code>getResourceByPath</code>方法，<code>getResourceByPath</code>方法定义在<code>FileSystemXmlApplicationContext</code>中，对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">"/"</span>)) &#123;</div><div class="line">        path = path.substring(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此，我们完成了<code>IoC</code>容器在初始化过程中的<code>Resource</code>定位过程的流程分析，这为接下来进行<code>BeanDefinition</code>数据的载入和解析创造了条件。</p>
<p>后续我会对<code>BeanDefinition</code>的载入和解析过程结合源码进行分析，欢迎关注。若本文存在分析不妥之处，建议发送邮件至<code>tinylcy (at) gmail.com</code>交流，直接在页面评论亦可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;Spring IoC&lt;/code&gt;容器的设计中，有两个主要的容器系列。一个是实现了&lt;code&gt;BeanFactory&lt;/code&gt;接口的简单容器系列，这系列容器只实现了容器基本的功能；另一个是&lt;code&gt;ApplicationContext&lt;/code&gt;应用上
    
    </summary>
    
    
      <category term="Spring" scheme="http://tinylcy.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="http://tinylcy.me/2016/12/04/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/12/04/HashMap源码分析/</id>
    <published>2016-12-04T03:46:58.000Z</published>
    <updated>2017-04-25T04:47:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h2><p>本文针对<code>HashMap</code>的源码分析基于<code>JDK 7</code>，<code>JDK 8</code>在<code>HashMap</code>的实现上有着较大幅度的改进和优化，这部分优化我将另起一篇来阐述。另外，本文仅分析<code>HashMap</code>众多方法中最常用的方法，其余方法有需要时再研究 :smile:。</p>
<p><code>HashMap</code>的继承关系如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p><code>HashMap</code>继承自<code>AbstractMap</code>，同时实现了<code>Map</code>、<code>Cloneable</code>和<code>Serializable</code>接口。因此，<code>HashMap</code>可以被克隆，并支持序列化。另外，<code>HashMap</code>是一个非线程安全的，因此适合运用在单线程环境下。如果是在多线程环境，可以通过<code>Collections</code>的静态方法<code>synchronizedMap</code>获得线程安全的<code>HashMap</code>，如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</div></pre></td></tr></table></figure>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>针对每个键值对，<code>HashMap</code>使用内部类<code>Entry</code>来存储，<code>Entry</code>核心代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K, V&gt; next;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">  </div><div class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">        value = v;</div><div class="line">        next = n;</div><div class="line">        key = k;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从整体上看，<code>HashMap</code>底层的存储结构是基于数组和链表实现的。对于每一个要存入<code>HashMap</code>的键值对（<code>Key-Value Pair</code>），通过计算<code>Key</code>的<code>hash</code>值来决定存入哪个数组单元（<code>bucket</code>），为了处理<code>hash</code>冲突，每个数组单元实际上是一条<code>Entry</code>单链表的头结点，其后引申出一条单链表。<code>HashMap</code>的存储结构如下图所示。</p>
<p><img src="/img/2016-12-04-Image 1.png" alt="Alt text"></p>
<h2 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h2><p><code>HashMap</code>定义了几个关键属性，对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"><span class="keyword">transient</span> Entry[] table;</div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<ul>
<li><code>DEFAULT_INITIAL_CAPACITY</code>代表<code>HashMap</code>槽（<code>bucket</code>）的默认容量，且该容量必须为<code>2</code>的幂，具体原因会在下文解释。</li>
<li><code>MAXIMUM_CAPACITY代表HashMap</code>槽（<code>bucket</code>）的最大容量，如果传入的容量大于<code>1 &lt;&lt; 30</code>，那么实际容量会被<code>MAXIMUM_CAPACITY</code>替换。</li>
<li><code>DEFAULT_LOAD_FACTOR</code>是默认的加载因子，用于计算<code>HashMap</code>扩容的<code>threshold</code>，当<code>HashMap</code>的实际元素容量达到总容量的<code>threshold</code>时，对<code>HashMap</code>进行扩容。</li>
<li><code>table</code>是存储<code>Entry</code>的数组，每个<code>Entry</code>是一条单链表的头结点。</li>
<li><code>size</code>代表<code>HashMap</code>键值对的数量。</li>
<li><code>threshold</code>是<code>HashMap</code>决定是否执行执行扩容操作的阈值，<code>threshold  = capacity * load factor</code>。</li>
<li><code>loadFactor</code>表示<code>HashMap</code>实际加载因子，通过构造方法传入。若未指定，<code>loadFactor</code>等于<code>DEFAULT_LOAD_FACTOR</code>。</li>
</ul>
<p>需要进一步解释的是<code>loadFactor</code>属性，<code>loadFactor</code>描述了<code>HashMap</code>发生扩容时的填充程度。如果<code>loadFactor</code>设置过大，意味着在<code>HashMap</code>扩容前发生<code>hash</code>冲突的机会越大，因此单链表的长度也就会越长，那么在执行查找操作时，会由于单链表长度过长导致查找的效率降低。如果<code>loadFactor</code>设置过小，那么<code>HashMap</code>的空间利用率会降低，导致<code>HashMap</code>在很多空间都没有被利用的情况下便开始扩容。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>HashMap</code>定义了四个构造方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    init();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</div><div class="line">    table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">    init(); <span class="comment">// 在源码中，init方法体不执行任何操作。</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</div><div class="line">                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</div><div class="line">    putAllForCreate(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用<code>HashMap</code>默认构造方法时，<code>HashMap</code>对象的属性均会被设置为默认值，包括设置加载因子（<code>DEFAULT_LOAD_FACTOR</code>）、扩容阈值（<code>threshold</code>）和<code>table</code>的初始大小。</p>
<p>如果在创建<code>HashMap</code>对象时指定了<code>bucket</code>容量<code>initialCapacity</code>，通过源码我们可以看出在初始化对象时不一定会直接使用<code>initialCapacity</code>，而是选取满足小于等于<code>initialCapacity</code>前提条件下最大的且是<code>2</code>的幂的一个值作为实际<code>bucket</code>的大小。</p>
<p>如果向构造方法传递的参数是一个<code>Map</code>对象<code>m</code>，那么<code>putAllForCreate</code>方法会重新散列<code>m</code>中的每个元素，将它们存入相应的<code>bucket</code>中。<code>putAllForCreate</code>方法及其调用的相关方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</div><div class="line">        putForCreate(e.getKey(), e.getValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>putAllForCreate</code>方法遍历每一个键值对<code>e</code>，通过<code>putForCreat</code>方法将<code>e</code>散列到对应的<code>bucket</code>中。<code>putForCreate</code>方法调用<code>indexFor</code>来确定键值对散列的<code>bucket</code>的位置。<code>indexFor</code>通过<code>h &amp; (length-1)</code>返回<code>bucket</code>的位置，接着遍历对应的单链表来决定是更新操作还是插入操作。</p>
<p>我们需要关注的地方是<code>indexFor</code>为什么通过计算<code>h &amp; (length-1)</code>来获得<code>bucket</code>的位置，而不是通过计算<code>h % length</code>？</p>
<p>实际上，在<code>HashMap</code>中，<code>h &amp; (length-1) == h % length</code>，但是需要一个前提：<code>length</code>必须满足是<code>2</code>的幂。这也正是在解释<code>DEFAULT_INITIAL_CAPACITY</code>和<code>HashMap</code>构造方法时强调的<code>HashMap</code>的<code>bucket</code>容量必须是<code>2</code>的幂。当<code>length</code>是<code>2</code>的幂，那么<code>length</code>的二进制数可以表示为<code>1000...000</code>，因此<code>length - 1</code>的二进制数为<code>0111...111</code>，当<code>h</code>与<code>length - 1</code>位与时，除了<code>h</code>的最高位的被修改为<code>0</code>，其余位均保持不变，这也正是实现了<code>h % length</code>的效果。只是相比于<code>h % length</code>，<code>h &amp; (length-1)</code>的效率会更高。</p>
<p><code>HashMap</code>的<code>bucket</code>容量必须为<code>2</code>的幂的另一个重要原因是一旦满足此条件，那么<code>length</code>即为偶数，<code>length - 1</code>便为奇数，所以<code>length - 1</code>的最后一位必为<code>1</code>。因此，<code>h &amp; (length - 1)</code>得到的值既可能是奇数，也可能是偶数，这确保了散列的均匀性。如果<code>length - 1</code>是偶数，那么<code>h &amp; (length - 1)</code>得到的值必为偶数，那么<code>HashMap</code>的空间便浪费了一半。</p>
<h2 id="存取方法"><a href="#存取方法" class="headerlink" title="存取方法"></a>存取方法</h2><p>我们分析<code>HashMap</code>使用频率最高的两个方法<code>get</code>方法和<code>put</code>方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从<code>HashMap</code>获取<code>get</code>元素时，先计算<code>Key</code>的<code>hash</code>值，定位到数组中对应的<code>bucket</code>，然后开始遍历<code>Entry</code>单链表，直到找到需要的元素，否则返回<code>null</code>。</p>
<p>当我们向<code>HashMap</code>中<code>put</code>新的键值对时，<code>HashMap</code>首先检查<code>Key</code>是否等于<code>null</code>，若为<code>null</code>，则执行<code>putForNullKey</code>方法，<code>putForNullKey</code>方法对应的源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>); <span class="comment">// 不做任何操作</span></div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    modCount++;</div><div class="line">    addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果<code>Key</code>等于<code>null</code>，那么就将该键值对添加到<code>table[0]</code>的位置，同时，遍历<code>table[0]</code>处的单链表并将链表中所有节点的值都覆盖为新传递进来的键值对的值。因此，该位置永远只有一个值。</p>
<p>如果<code>Key</code>不等于<code>null</code>，那么通过<code>indexFor</code>定位到<code>bucket</code>，然后遍历单链表，如果存在<code>Key</code>相等的键值对，就用新值覆盖旧值，并返回旧值。如果在单链表中没有找到对应的<code>Key</code>，那么调用<code>addEntry</code>方法创建新的<code>Entry</code>节点至单链表（作为头节点）。<code>addEntry</code>及关联方法源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    <span class="keyword">if</span> (size++ &gt;= threshold)</div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    transfer(newTable);</div><div class="line">    table = newTable;</div><div class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line">    Entry[] src = table;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</div><div class="line">        Entry&lt;K,V&gt; e = src[j];</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            src[j] = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">                e.next = newTable[i];</div><div class="line">                newTable[i] = e;</div><div class="line">                e = next;</div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>addEntry</code>把新增键值对插入单链表后，会判断是否需要扩容，即判断当前<code>HashMap</code>的元素的个数是否大于<code>threshold</code>。若需要扩容，那么调用<code>resize</code>方法进行<code>2</code>倍扩容。<code>resize</code>方法会在内部调用<code>transfer</code>方法，<code>transfer</code>方法遍历旧数组及单链表，并将每个键值对重新散列，可以意识到，这整个<code>rehash</code>的开销相当大。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>关于线程安全，我们想要知道的是<code>HashMap</code>在什么情况下会发生线程不安全的情况？实际上，在上文分析<code>put</code>方法时，当<code>HashMap</code>的容量超过了<code>threshold</code>时，便执行<code>resize</code>操作，<code>resize</code>就存在线程不安全的问题。</p>
<p>关于<code>resize</code>哪儿不安全，我推荐左耳朵耗子写的 <a href="http://coolshell.cn/articles/9606.html/" target="_blank" rel="external">疫苗：Java HashMap的死循环</a>，这篇文章图文并茂的解释了在<code>rehash</code>过程中出现线程不安全问题的根源。</p>
<h2 id="HashMap-VS-HashTable"><a href="#HashMap-VS-HashTable" class="headerlink" title="HashMap VS HashTable"></a>HashMap VS HashTable</h2><p><code>HashTable</code>和<code>HashMap</code>底层采用相同的存储结构，在很多方法的实现上二者的思路基本一致。最主要的区别主要有两点。</p>
<ul>
<li><code>HashTable</code>实现了所谓的线程安全，在<code>HashTable</code>很多方法上都加上了<code>synchronized</code>。</li>
<li>在<code>HashMap</code>的分析中，我们发现当我们新增键值对时，<code>HashMap</code>是允许<code>Key</code>和<code>Value</code>均为<code>null</code>。但是<code>HashTable</code>不允许<code>Key</code>或<code>Value</code>为<code>null</code>，关于这一点我们可以通过查看<code>HashTable</code>源码得知。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure the value is not null</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// 若value为空则抛出NullPointerException。</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode(); <span class="comment">// 若key为空则抛出NullPointerException。</span></div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            <span class="keyword">return</span> old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap简介&quot;&gt;&lt;a href=&quot;#HashMap简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap简介&quot;&gt;&lt;/a&gt;HashMap简介&lt;/h2&gt;&lt;p&gt;本文针对&lt;code&gt;HashMap&lt;/code&gt;的源码分析基于&lt;code&gt;JDK 7
    
    </summary>
    
    
      <category term="JDK" scheme="http://tinylcy.me/tags/JDK/"/>
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vector源码分析</title>
    <link href="http://tinylcy.me/2016/12/02/Vector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://tinylcy.me/2016/12/02/Vector源码分析/</id>
    <published>2016-12-02T13:00:08.000Z</published>
    <updated>2017-04-25T04:49:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vector简介"><a href="#Vector简介" class="headerlink" title="Vector简介"></a>Vector简介</h2><p><code>Vector</code>在<code>JDK 1.0</code>被引入，基于数组实现，并且是一个动态数组，其容量可以自动增长。在很多方法的实现上，<code>Vector</code>加入了同步语句，因此一般来说<code>Vector</code>是线程安全的，可以在多线程环境中运用。</p>
<p>本文对<code>Vector</code>源码的分析基于<code>JDK 1.8.0_111</code>，并仅对常用的方法进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p><code>Vector</code>类继承自<code>AbstractList</code>，<code>AbstractList</code>是一个抽象类，实现了<code>List</code>接口，<code>AbstractList</code>提供了实现一个<code>List</code>的基本骨架，包括<code>add</code>，<code>remove</code>，<code>get</code>，<code>set</code>，<code>indexOf</code>等方法。<code>Vector</code>实现了<code>RandomAccess</code>接口，因此可以随机访问。实现了<code>Cloneable</code>接口，允许克隆。实现了<code>Serializable</code>接口，可以被序列化。</p>
<h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><p><code>Vector</code>内包含<code>3</code>个实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Object[] elementData;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</div></pre></td></tr></table></figure>
<ul>
<li><code>elementData</code>是一个数组，用于存储<code>Vector</code>容器的元素，该数组有一个对应的属性<code>capacity</code>，<code>capacity</code>描述了<code>elementData</code>当前的长度。</li>
<li><code>elementCount</code>描述了<code>elementData</code>内有效元素的个数。</li>
<li><code>capacityIncrement</code>刻画了当要存储的元素的个数大于<code>elementData</code>的<code>capacity</code>时，<code>elementData</code>需要扩容的空间大小，即容器增长系数。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><code>Vector</code>定义了<code>4</code>个构造方法。</p>
<ul>
<li><p><code>Vector(int initialCapacity, int capacityIncrement);</code></p>
</li>
<li><p><code>Vector(int initialCapacity);</code></p>
</li>
<li><p><code>Vector();</code></p>
</li>
<li><p><code>Vector(Collection&lt;? extends E&gt; c);</code></p>
</li>
</ul>
<p>当我们直接<code>new</code>一个<code>Vector</code>时，即调用<code>Vector</code>的默认构造方法，实际上，<code>Vector</code>的默认构造方法调用<code>this(10)</code>，即调用<code>Vector(int initialCapacity)</code>，并将<code>initialCapacity</code>设置为<code>10</code>，接着<code>Vector(int initialCapacity)</code>再调用<code>this(initialCapacity, 0)</code>，并将<code>capacityIncrement</code>设置为<code>0</code>。从以上我们可以得知，对于一个默认构造的<code>Vector</code>对象，它的默认存储空间可以存储<code>10</code>个元素，且容器增长系统等于<code>0</code>。</p>
<h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><p><code>Vector</code>定义了<code>3</code>个重要的私有方法<code>ensureCapacityHelper(int minCapacity)</code>、<code>void grow(int minCapacity)</code>和<code>int hugeCapacity(int minCapacity)</code>，这<code>3</code>个方法用于实现<code>Vector</code>的自动扩容，<code>Vector</code>中很多涉及到影响<code>Vector</code>元素变化的操作都会直接或者间接的调用这<code>3</code>个方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</div><div class="line">                                     capacityIncrement : oldCapacity);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</div><div class="line">    elementData[elementCount++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以关注<code>Vector</code>的<code>add(E e)</code>方法，在往<code>Vector</code>内新增元素前，需要确保存储<code>Vector</code>元素的数组<code>elementData</code>有充足的空间，这一步通过<code>ensureCapacityHelper</code>来实现，<code>ensureCapacityHelper</code>接收<code>elementCount + 1</code>作为参数，确保<code>Vector</code>至少有一个空闲的空间存储新增的元素。当<code>Vector</code>不具备多余的空间时（<code>minCapacity - elementData.length &gt; 0</code>），<code>ensureCapacityHelper</code>就会调用<code>grow</code>方法扩充<code>elementData</code>数组。在扩充数组时，如果<code>capacityIncrement</code>不大于<code>0</code>，那么<code>Vector</code>就会开辟出<code>2</code>倍于原<code>elementData</code>数组长度的空间，并通过<code>Arrays.copyOf</code>将原<code>elementData</code>中的元素拷贝到新地址空间。另外，<code>Vector</code>容量的扩充也是有限制的，从<code>hugeCapacity</code>方法可以看出，<code>Vector</code>的容量最大扩充至<code>Integer.MAX_VALUE</code>。</p>
<p> <code>Vector</code>中定义了大量的用于操作容器的方法，其中绝大多数设计到改变容器大小的方法都是在底层做两件事，一是开辟新的存储空间（如果有必要），二是进行数组的拷贝。这些方法理解起来并不难，此处不再赘述。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>在很多面试环节中，经常被问到的问题是<em><code>ArrayList</code>和<code>Vector</code>的区别是什么？</em>关于这个问题，最频繁的回答可能是<em><code>Vector</code>是线程安全的，而<code>ArrayList</code>是非线程安全的</em>。这样回答的原因是在<code>Vector</code>的方法中，几乎所有的操作容器的方法上都加了<code>synchronized</code>，这意味着访问这些方法前都需要获得对象的锁。因此，这些方法不会被多个线程同时访问，从而实现线程安全。</p>
<p><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="external">Java并发编程实战</a>一书中提到：如果只是将每个方法都作为同步方法（比如<code>Vector</code>，简单的在方法前加上<code>synchronized</code>），那么并不足以确保复合操作是原子的，以<code>Vector</code>为例，观察如下代码片段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!vector.contains(element)) &#123;</div><div class="line">    vector.add(element);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个经典的<code>put-if-else</code>问题，虽然通过<code>synchronized</code>已确保<code>contains</code>方法和<code>add</code>方法都是原子的，但是如果把多个操作合并为一个复合操作，仍旧需要额外的加锁机制。否则，多线程环境下，在<code>contains</code>方法和<code>add</code>方法的执行间隙期间完全有可能经历一个线程获取<code>contains</code>上的锁，执行完<code>contains</code>方法后释放锁，然后锁又被另一线程获取，并执行了<code>add</code>方法，然后释放锁，锁又被原来执行<code>contains</code>方法的线程获取，然后执行<code>add</code>方法，此时，该线程可能已经基于一个错误的假设在执行<code>add</code>方法了（<code>Vector</code>内可能已经存在该线程即将要<code>add</code>的元素了）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Vector简介&quot;&gt;&lt;a href=&quot;#Vector简介&quot; class=&quot;headerlink&quot; title=&quot;Vector简介&quot;&gt;&lt;/a&gt;Vector简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;在&lt;code&gt;JDK 1.0&lt;/code&gt;被引入，基于
    
    </summary>
    
    
      <category term="JDK" scheme="http://tinylcy.me/tags/JDK/"/>
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java对象内存布局</title>
    <link href="http://tinylcy.me/2016/11/30/Java%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://tinylcy.me/2016/11/30/Java对象内存布局/</id>
    <published>2016-11-30T10:58:18.000Z</published>
    <updated>2017-04-25T04:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>JVM</code>将内存划分为程序计数器（<code>Program Counter Register</code>）、虚拟机栈（<code>VM Stack</code>）、本地方法栈（<code>Native Method Stack</code>）、堆（<code>Heap</code>）以及方法区（<code>Method Area</code>）。作为开发者，我们最关注的是虚拟机栈以及堆这两块区域。虚拟机栈所需要的内存空间在编译期间即可明确，而堆内存所需要的空间需要在运行时才可确定。堆内存用于存放我们在程序中创建的对象，一旦没有足够的空间用于存放这些对象，即会抛出<code>OutOfMemoryError</code>异常。在这种情况下，我们可以调整堆内存的大小，或者对程序进行优化。当我们采用后一种方式时，我们需要了解一个对象是如何占据堆内存空间的，或者说是了解一个对象是由哪些部分组成的。</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在<code>HotSpot</code>虚拟机中，对象在内存中的布局划分为<code>3</code>个区域：对象头（<code>Header</code>），实例数据（<code>Instance Data</code>）以及对齐填充（<code>Padding</code>）。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><code>HotSpot</code>虚拟机对象的对象头一般包含两部分信息，第一部分用于存储对象自身的运行时数据，例如<code>HashCode</code>、<code>GC</code>分代年龄等信息。在<code>32</code>位和<code>64</code>位的<code>JVM</code>中，这部分数据分别为<code>32bit</code>和<code>64bit</code>，官方称这部分数据为<code>Mark Word</code>。</p>
<p>另一部分用于存储对象的类型指针，该指针指向它的类元数据，<code>JVM</code>通过这个指针确定对象是哪个类的实例。在<code>32</code>位<code>JVM</code>中，指针的长度为<code>32bit</code>，在未开启压缩指针的<code>64</code>位<code>JVM</code>中，该指针的长度为<code>64bit</code>，如果开启压缩指针，那么为<code>32bit</code>。</p>
<p>之前提到对象头一般包含两部分信息，这是因为如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度，并且这部分数据也随着<code>JVM</code>位数的不同而不同：<code>32</code>位的<code>JVM</code>上，该区域的长度为<code>32bit</code>，在<code>64</code>位未开启压缩指针的<code>JVM</code>中，这部分数据的长度为<code>64bit</code>，否则为<code>32bit</code>。</p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储有效信息的区域，存储了代码中定义的各种字段的内容，包括从父类继承下来的字段和子类中定义的字段。</p>
<p>实例数据紧随对象头，为了提高存储空间的利用率，这部分数据的存储顺序会受到虚拟机分配策略参数和字段在<code>Java</code>源码中定义顺序的影响。<code>HotSpot</code>虚拟机默认的分配策略如下所示。</p>
<ul>
<li><code>doubles &amp; longs</code></li>
<li><code>ints &amp; floats</code></li>
<li><code>shorts &amp; chars</code></li>
<li><code>booleans &amp; bytes</code></li>
<li><code>references</code></li>
</ul>
<p>可以看出，相同宽度的字段总是被分配到一起，并且在满足这个条件的前提下，在父类中定义的字段会出现在子类字段之前。</p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充这部分不是必须存在的，这部分仅仅是起着占位符的作用。由于<code>HotSpot</code>虚拟机的自动内存管理系统要求对象的起始地址必须是<code>8</code>字节的整数倍，因此当对象实例部分数据没有对齐时，就需要对剩余的部分进行填充。</p>
<h2 id="度量工具"><a href="#度量工具" class="headerlink" title="度量工具"></a>度量工具</h2><p>从<code>JDK 5</code>开始， <code>Java</code>提供了<code>Instrumentation API</code>，通过<code>getObjectSize</code>方法来获取对象的大小，但是<code>getObjectSize</code>方法存在如下两个缺陷，不能准确的计算对象的大小。</p>
<ul>
<li>不能直接调用<code>getObjectSize</code>方法，而是需要通过<code>-javaagent</code>参数指定一个特定的<code>jar</code>文件（包含<code>Instrumentation</code>代理）来启动<code>Instrumentation</code>的代理程序。</li>
<li>如果一个对象中包含别的对象的引用，那么<code>getObjectSize</code>方法仅仅计算引用的大小，而不包括引用所指向的对象的大小。</li>
</ul>
<p>由于上述两个缺陷，我们不能直接调用<code>getObjectSize</code>方法来计算对象的大小，但是利用<code>Java</code>的反射机制，我们可以完整的计算一个对象的大小。我们解析对象的每一个<code>Field</code>（使用<code>getDeclaredFields</code>），并遵从如下规则。</p>
<ul>
<li>当<code>Field</code>是基本数据类型时，我们不再计算该<code>Field</code>的大小，因为该<code>Field</code>的大小已经被包含在<code>getObjectSize</code>方法的返回值中。</li>
<li>当<code>Field</code>是静态数据或者是常量池中包含的数据，那么我们忽略这些数据，因为这些数据并不是属于对象的。</li>
<li>我们需要保存我们已经计算过的对象的引用，防止重复计算。 </li>
<li>如果对象所属的类存在父类，还需要计算父类中成员变量的大小。</li>
</ul>
<p><a href="https://github.com/tinylcy/jvm-obj-size" target="_blank" rel="external">jvm-obj-size</a> 是以上思想的具体实现，<a href="https://github.com/tinylcy/jvm-obj-size" target="_blank" rel="external">jvm-obj-size</a> 实现了基本的获取对象本身的大小（<code>sizeOf</code>，仅包含引用本身），以及获取对象真正的大小（<code>fullSizeOf</code>，包含引用所指向的对象）的方法，具体用法以及测试代码详见<code>README</code>文件。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机</a></li>
<li><a href="http://www.jroller.com/maxim/entry/again_about_determining_size_of" target="_blank" rel="external">Again about determining size of Java object</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/" target="_blank" rel="external">Java SE 6 新特性: Instrumentation 新功能</a></li>
<li><a href="http://blog.csdn.net/u013256816/article/details/51008443" target="_blank" rel="external">Java对象大小内幕浅析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;JVM&lt;/code&gt;将内存划分为程序计数器（&lt;code&gt;Program Counter Register&lt;/code&gt;）、虚拟机栈（&lt;code&gt;VM Stack&lt;/code&gt;）、本地方法栈（&lt;code&gt;Native Method Stack&lt;/code&gt;）、堆（
    
    </summary>
    
    
      <category term="JVM" scheme="http://tinylcy.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Linux C 线程池实现</title>
    <link href="http://tinylcy.me/2016/11/17/Linux-C-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tinylcy.me/2016/11/17/Linux-C-线程池实现/</id>
    <published>2016-11-17T09:15:35.000Z</published>
    <updated>2017-04-25T04:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>学习网络编程时，自己动手实现一个<code>Web Server</code>是一个很有意思的经历。大多数<code>Web Server</code>都有一个特点：在单位时间内需要处理大量的请求，并且处理这些请求的时间往往还很短。《深入理解计算机系统》 (<code>CSAPP</code>) 在讲解网络编程时实现了一个经典的<code>Web Server</code>，这个<code>Web Server</code>不仅满足了静态请求，同时还满足了动态请求 (<code>CGI</code>)。虽然这个<code>Web Server</code>能够正常使用，但是仍存在一个明显的缺陷：它是一个迭代式的<code>Web Server</code>，这意味着在一个请求处理完毕前，不能同时处理另一个请求，而我们之前提到<code>Web Server</code>的一个重要特点就是在单位时间内可能会有大量的请求，所以如果投入工业界，这种情况自然是无法容忍的。</p>
<h2 id="多进程-Web-Server-模型"><a href="#多进程-Web-Server-模型" class="headerlink" title="多进程 Web Server 模型"></a>多进程 Web Server 模型</h2><p>解决上面提到的<code>Web Server</code>只能一个接着一个处理请求的第一个方案是：当<code>accept</code>到一个请求时，<code>fork</code>一个子进程去处理这个请求，而主进程仍然在监听是否有新的连接请求。多进程模型在表面上看似乎解决了问题，但是我们都知道<code>fork</code>一个进程的开销是非常大的，基于以下几个事实。</p>
<ul>
<li><p>从概念上说，可以将<code>fork</code>认作对父进程程序段、数据段、堆段以及栈段创建拷贝。但是如果真的只是简单的将父进程虚拟内存页拷贝到子进程，那就太浪费了。现代<code>UNIX</code>(<code>Linux</code>) 在实现<code>fork</code>时往往会采用两种技术来避免这种浪费。一是内核将每一进程的代码段标记为只读，从而使得父进程和子进程都无法修改代码段。这样，父进程和子进程可以共共享同一代码段。二是对于父进程数据段、堆段和栈段中的各页，内核采用写时复制(<code>copy-on-write</code>) 的方式，这么做的原因之一是：<code>fork</code>之后常常伴随着<code>exec</code>，这会用新程序替换进程的代码段，并重新初始化其数据段、堆段和栈段。但是无论如何，仍存在复制页表的操作，这也是为什么在<code>UNIX</code>(<code>Linux</code>) 下创建进程要比创建线程开销大的原因。</p>
</li>
<li><p>并发量一大，此时系统内便会有存在大量的进程，这会导致<code>CPU</code>花费大量的时间在进程调度上，并且进程上下文的切换开销也很大。</p>
</li>
</ul>
<p>因此，相比于多进程模型，多线程是一个更优的模型：创建线程要快于创建进程，线程间的上下文切换消耗的时间一般也比进程要短。</p>
<h2 id="多线程-Web-Server-模型"><a href="#多线程-Web-Server-模型" class="headerlink" title="多线程 Web Server 模型"></a>多线程 Web Server 模型</h2><p> 换用多线程<code>Web Server</code>模型：每<code>accept</code>一个请求，创建一个线程，将请求交由该线程处理。换用多线程模型可以解决由<code>fork</code>带来的开销问题，但是调度问题依然还是存在的。因此，一个显而易见的解决办法是使用线程池，将线程的数量固定下来。基本的实现思路如下。</p>
<ul>
<li><p>将每个请求封装为一个<code>Job</code>，每个<code>Job</code>包含线程要执行的方法、传递给线程的参数以及用于描述该<code>Job</code>处于<code>Job</code>队列的位置的参数。</p>
</li>
<li><p>线程池维护着一个<code>Job</code>队列，每个线程从<code>Job</code>队列中取下一个<code>Job</code>执行。因为该<code>Job</code>队列是一个共享资源，因此需要控制线程的同步。</p>
</li>
<li><p>初始化线程池时，马上创建一定数量的线程。此时，这些线程都是阻塞状态的，因为<code>Job</code>队列为空。</p>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://github.com/tinylcy/tinyhttpd" target="_blank" rel="external">tinyhttpd</a>是我为了更有效的学习网络编程而实现的一个轻量级的<code>Web Server</code>，目前仍有部分问题需要解决以及优化。按照上面的思路，我实现了一个简单的线程池，并将其引入到<a href="https://github.com/tinylcy/tinyhttpd" target="_blank" rel="external">tinyhttpd</a>中。具体的代码实现请参考<a href="https://github.com/tinylcy/tinyhttpd/blob/master/threadpool.h" target="_blank" rel="external">threadpool.h</a>和<a href="https://github.com/tinylcy/tinyhttpd/blob/master/threadpool.c" target="_blank" rel="external">threadpool.c</a>。</p>
<h2 id="剩余问题"><a href="#剩余问题" class="headerlink" title="剩余问题"></a>剩余问题</h2><p>当固定了线程池的线程数量后，仍然存在一个严重的问题：实际情况下，很多连接都是长连接，这意味着一个线程在处理一个请求时，<code>read</code>到的数据将会是是不连续的。当线程处理完一批数据后，如果继续<code>read</code>，而下一批数据还未到来时，由于默认情况下<code>file descriptor</code>是<code>blocking</code>的，因此该线程就会进入阻塞状态。所以，如果线程池中所有的线程都处于阻塞状态，此时如果有新的请求到来，那么是无法处理的。</p>
<p>解决方案是将<code>file descriptor</code>设置为<code>non-blocking</code>，利用事件驱动(<code>Event-driven</code>)来处理连接。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://book.douban.com/subject/25809330/" target="_blank" rel="external">Linux/UNIX系统编程手册</a></p>
</li>
<li><p><a href="https://book.douban.com/subject/5333562/" target="_blank" rel="external">深入理解计算机系统</a></p>
</li>
<li><p><a href="https://github.com/zyearn/zaver" target="_blank" rel="external">zaver</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习网络编程时，自己动手实现一个&lt;code&gt;Web Server&lt;/code&gt;是一个很有意思的经历。大多数&lt;code&gt;Web Server&lt;/code&gt;都有一个特点：在单位时间内需要处理大量的请求，并且处理这些请求的时间往往还很短。《深入理解计算机系统》 (&lt;code&gt;CS
    
    </summary>
    
    
      <category term="Unix/Linux" scheme="http://tinylcy.me/tags/Unix-Linux/"/>
    
      <category term="C" scheme="http://tinylcy.me/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型总结</title>
    <link href="http://tinylcy.me/2016/10/03/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://tinylcy.me/2016/10/03/Java泛型总结/</id>
    <published>2016-10-03T13:51:39.000Z</published>
    <updated>2017-04-25T04:47:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code>泛型是<code>JDK5</code>引入的一个新特性，允许在定义类和接口的时候使用类型参数（<code>type parameter</code>）。声明的类型参数在使用的时候使用具体的类型来替换。泛型最主要的应用是在<code>JDK5</code>中的新集合类框架中。对于泛型概念的引入，开发社区的观点是褒贬不一。从好的方面上说，泛型的引入可以解决之前的集合类框架在使用过程中通常会出现的运行时刻类型错误，因为编译器可以在编译时刻就发现很多明显的错误。从不好的方面说，为了保证与旧版本的兼容性，<code>Java</code>泛型的实现上还存在着不够优雅的地方。</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>正确理解泛型概念的首要前提是理解类型擦除（<code>type erasure</code>）。<code>Java</code>中的泛型基本上都是在编译器这个层次来实现的。在生成的<code>Java</code>字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。比如在代码中定义的<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译之后都会变成<code>List</code>。<code>JVM</code>看到的只是<code>List</code>，而由泛型附加的类型信息对<code>JVM</code>来说是不可见的。<code>Java</code>编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。</p>
<p>通过如下代码片段感受类型擦除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; a1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">ArrayList&lt;Integer&gt; a2 =<span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">Class c1 =a1.getClass();</div><div class="line">Class c2 = a2.getClass();</div><div class="line"></div><div class="line">System.out.println(c1.equals(c2));    <span class="comment">//Output: true</span></div></pre></td></tr></table></figure>
<p>此时，程序输出<code>true</code>，这就是类型擦除造成的。因为不管是<code>ArrayList&lt;String&gt;</code>还是<code>ArrayList&lt;Integer&gt;</code>，都会在编译期被编译器擦除成<code>ArrayList</code>。编译器这么做的原因归根结底还是为了兼容<code>JDK5</code>前未使用泛型的代码，因此不得不让编译器擦除有关类型信息的部分，这样生成的代码其实就是类型无关的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">System.out.println(Arrays.toString(list.getClass().getTypeParameters()));    <span class="comment">//[E]</span></div><div class="line">System.out.println(Arrays.toString(map.getClass().getTypeParameters()));    <span class="comment">//[K, V]</span></div></pre></td></tr></table></figure>
<p>我们期望的是返回泛型参数的类型，结果返回的仅仅是参数的占位符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] makeArray()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T[<span class="number">10</span>];    <span class="comment">//编译期报错：不能创建泛型类型的数组</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为<code>T</code>仅仅是个占位符，并不具有真实的类型信息。为了解决这个问题，可以利用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] makeArray(Class&lt;T&gt; clazz) &#123;</div><div class="line">    <span class="keyword">return</span> (T[]) Array.newInstance(clazz, <span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很多泛型的奇怪特性都与类型擦除的存在有关，包括：</p>
<ul>
<li><p>泛型类并没有自己独有的<code>Class</code>类对象。比如并不存在<code>List&lt;String&gt;.class</code>或是<code>List&lt;Integer&gt;.class</code>，而只有<code>List.class</code>。</p>
</li>
<li><p>静态变量是被泛型类的所有实例所共享的。对于声明为<code>MyClass&lt;T&gt;</code>的类，访问其中的静态变量的方法仍然是<code>MyClass.myStaticVar</code>。不管是通过<code>new MyClass&lt;String&gt;</code>还是<code>new MyClass&lt;Integer&gt;</code>创建的对象，都是共享一个静态变量。</p>
</li>
<li><p>泛型的类型参数不能用在<code>Java</code>异常处理的<code>catch</code>语句中。因为异常处理是由<code>JVM</code>在运行时刻来进行的。由于类型信息被擦除，<code>JVM</code>是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的。对于<code>JVM</code>来说，它们都是<code>MyException</code>类型的，也就无法执行与异常对应的<code>catch</code>语句。</p>
</li>
</ul>
<p>当执行类型擦除时，首先是找到用来替换类型参数的具体类。这个具体类一般是<code>Object</code>。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。同时去掉出现的类型声明，即去掉<code>&lt;&gt;</code>的内容。比如<code>T get()</code>方法声明就变成了<code>Object get()</code>；<code>List&lt;String&gt;</code>就变成了<code>List</code>。接下来就可能需要生成一些桥接方法（<code>bridge method</code>），这是由于擦除了类型之后的类可能缺少某些必须的方法。比如考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当类型信息被擦除之后，上述类的声明变成了<code>class MyString implements Comparable</code>。但是这样类<code>MyString</code>就会有编译错误，因为没有实现接口<code>Comparable</code>声明的<code>compareTo(Object)</code>方法。这个时候就由编译器来动态生成这个方法。</p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>了解类型擦除机制之后，就会明白编译器承担了全部的类型检查工作。编译器禁止某些泛型的使用方式，正是为了确保类型的安全性。以<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>为例来具体分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inspect</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(Object obj : list) &#123;</div><div class="line">		System.out.println(obj);</div><div class="line">	&#125;</div><div class="line">	list.add(<span class="number">1</span>);    <span class="comment">//这个操作在当前方法的上下文是合法的</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</div><div class="line">	List&lt;String&gt; strs = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">	inspect(strs);    <span class="comment">//编译错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码中，<code>inspect</code>方法接受<code>List&lt;Object&gt;</code>作为参数，当在<code>test</code>方法中试图传入<code>List&lt;String&gt;</code>的时候，会出现编译错误。假设这样的做法是允许的，那么在<code>inspect</code>方法中就可以通过<code>list.add(1)</code>来向集合中添加一个数字。这样在<code>test</code>方法看来，其声明为<code>List&lt;String&gt;</code>的集合中被添加了一个<code>Integer</code>类型的对象，这显然是违反类型安全原则的，在某个时候肯定会抛出<code>ClassCastException</code>。因此，编译器禁止这样的行为。</p>
<h2 id="通配符与上下界"><a href="#通配符与上下界" class="headerlink" title="通配符与上下界"></a>通配符与上下界</h2><p>在使用泛型类的时候，既可以指定一个具体的类型，如<code>List&lt;String&gt;</code>就声明了具体的类型是<code>String</code>；也可以用通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就声明了<code>List</code>中包含的元素类型是未知的。通配符所代表的其实是一组类型，但具体的类型是未知的。<code>List&lt;?&gt;</code>所声明的就是所有的类型都是可以的。但是<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。<code>List&lt;Object&gt;</code>实际上确定了<code>List</code>中包含的是<code>Object</code>及其子类，在使用的时候可以通过<code>Object</code>来进行引用。而<code>List&lt;?&gt;</code>则表示其中所包含的元素类型是不确定。其中可能包含的是<code>String</code>，也可能是<code>Integer</code>。如果它包含了<code>String</code>的话，往里面添加<code>Integer</code>类型的元素就是错误的。正因为类型未知，就不能通过<code>new ArrayList&lt;?&gt;()</code>的方法来创建一个新的<code>ArrayList</code>对象。因为编译器无法知道具体的类型是什么。但是对于<code>List&lt;?&gt;</code>中的元素总是可以用<code>Object</code>来引用的，因为虽然类型未知，但肯定是<code>Object</code>及其子类。考虑下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wildcard</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</div><div class="line">	list.add(<span class="number">1</span>);    <span class="comment">//编译错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，试图对一个带通配符的泛型类进行操作的时候，总是会出现编译错误。其原因在于通配符所表示的类型是未知的。</p>
<p>因为对于<code>List&lt;?&gt;</code>中的元素只能用<code>Object</code>来引用，在有些情况下不是很方便。在这些情况下，可以使用上下界来限制未知类型的范围。如<code>List&lt;? extends Number&gt;</code>说明<code>List</code>中包含的是<code>Number</code>及其子类。而<code>List&lt;? super Number&gt;</code>则说明<code>List</code>中包含的是<code>Number</code>及其父类。当引入了上界时候，在使用类型的时候就可以使用上界类中定义的方法。比如访问<code>List&lt;? extends Number&gt;</code>的时候，就可以使用<code>Number</code>类的<code>intValue</code>等方法。</p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>在<code>Java</code>中，比较常见的是通过继承机制而产生的类型体系结构。比如<code>String</code>继承自<code>Object</code>。根据<a href="https://zh.wikipedia.org/wiki/里氏替换原则" target="_blank" rel="external">Liskov替换原则</a>，子类是可以替换父类的。当需要<code>Object</code>类的引用的时候，如果传入一个<code>String</code>对象是没有任何问题的。但是反过来的话，即用父类的引用替换子类引用时，就需要进行强制类型转换。编译器并不能保证运行时刻的这种转换一定是合法的。这种自动的子类替换父类的转换机制，对于数组也是适用的。<code>String[]</code>可以替换<code>Object[]</code>。但是泛型的引入，对于这个类型系统产生了一定的影响。例如<code>List&lt;String&gt;</code>是不能替换<code>List&lt;Object&gt;</code>的。</p>
<p>引入泛型之后的类型系统增加了两个维度：一个是类型参数自身的继承体系结构，另外一个是泛型类或接口自身的继承体系结构。第一个指的是对于<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>这样的情况，类型参数<code>String</code>继承自<code>Object</code>。而第二种指的是<code>List</code>接口继承自<code>Collection</code>接口。对于这个类型系统，有如下的一些规则：</p>
<ul>
<li><p>相同类型参数的泛型类的关系取决于泛型类自身的继承体系结构。即<code>List&lt;String&gt;</code>是<code>Collection&lt;String&gt;</code>的子类型，<code>List&lt;String&gt;</code>可以替换<code>Collection&lt;String&gt;</code>。这种情况也适用于带有上下界的类型声明。</p>
</li>
<li><p>当泛型类的类型声明中使用了通配符的时候，其子类可以在两个维度上分别展开。如对<code>Collection&lt;? extends Number&gt;</code>来说，其子类型可以在<code>Collection</code>这个维度上展开，即<code>List&lt;? extends Number&gt;</code>和<code>Set&lt;? extends Number&gt;</code>等；也可以在<code>Number</code>这个维度展开，即<code>Collection&lt;Double&gt;</code>和<code>Collection&lt;Integer&gt;</code>等。如此循环下去，<code>ArrayList&lt;Long&gt;</code>和<code>HashSet&lt;Double&gt;</code>等也都算是<code>Collection&lt;? extends Number&gt;</code>的子类型。</p>
</li>
<li><p>如果泛型类中包含多个类型参数，则对每个类型参数分别应用上面的规则。</p>
</li>
</ul>
<p>因此，对于上面错误的代码，只需要将<code>List&lt;Object&gt;</code>修正为<code>List&lt;?&gt;</code>即可。<code>List&lt;String&gt;</code>是<code>List&lt;?&gt;</code>的子类型。</p>
<h2 id="开发自己的泛型类"><a href="#开发自己的泛型类" class="headerlink" title="开发自己的泛型类"></a>开发自己的泛型类</h2><p>泛型类与一般的<code>Java</code>类基本相同，只是在类和接口定义上多出来了用<code>&lt;&gt;</code>声明的类型参数。一个类可以有多个类型参数，比如<code>MyClass&lt;X, Y, Z&gt;</code>。每个类型参数在声明的时候可以指定上下界。所声明的类型参数在<code>Java</code>类中可以像一般的类型一样作为方法的参数和返回值，或是作为域和局部变量的类型。由于类型擦除机制，类型参数并不能用来创建对象或是作为静态变量的类型。考虑下面的泛型类中的正确和错误的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span>&lt;<span class="title">X</span> <span class="keyword">extends</span> <span class="title">Number</span>, <span class="title">Y</span>, <span class="title">Z</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> X x;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Y y;    <span class="comment">//编译错误，不能用在静态变量中</span></div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> X <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> x;    <span class="comment">//正确用法</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</div><div class="line">		Z z = <span class="keyword">new</span> Z();    <span class="comment">//编译错误，不能查创建对象</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设允许类型参数声明为静态属性，那么如下代码将会非常混乱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T os;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(T os)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.os = os;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOS</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> os;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</div><div class="line">        Computer&lt;Linux&gt; c1 = <span class="keyword">new</span> Computer&lt;&gt;();</div><div class="line">        Computer&lt;MacOS&gt; c2 = <span class="keyword">new</span> Computer&lt;&gt;();</div><div class="line">        Computer&lt;Windows&gt; c3 = <span class="keyword">new</span> Computer&lt;&gt;();</div><div class="line"></div><div class="line">        System.out.println(c1.getOS());</div><div class="line">        System.out.println(c2.getOS());</div><div class="line">        System.out.println(c3.getOS());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为<code>os</code>为<code>Computer</code>类的静态属性，所以<code>c1</code>，<code>c2</code>，<code>c3</code>这<code>3</code>个<code>Computer</code>实例共享这个属性，那么此时<code>os</code>的类型是什么？因此，不允许声明静态的类型参数属性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用<code>Java</code>泛型的时候可以遵循一些基本的原则，从而避免一些常见的问题。</p>
<ul>
<li><p>在代码中避免泛型类和原始类型的混用。比如<code>List&lt;String&gt;</code>和<code>List</code>不应该共同使用。这样会产生一些编译器警告和潜在的运行时异常。</p>
</li>
<li><p>在使用带通配符的泛型类的时候，需要明确通配符所代表的一组类型的概念。由于具体的类型是未知的，很多操作是不允许的。</p>
</li>
<li><p>泛型类最好不要同数组一块儿使用。只能创建<code>new List&lt;?&gt;[10]</code>这样的数组，无法创建<code>new List&lt;String&gt;[10]</code>这样的。这限制了数组的使用能力，而且会带来很多费解的问题。</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.infoq.com/cn/articles/cf-java-generics" target="_blank" rel="external">InfoQ</a></li>
<li><a href="http://findingsea.github.io/2015/10/09/java-generic-type-erasure/" target="_blank" rel="external">Java泛型：类型擦除</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt;泛型是&lt;code&gt;JDK5&lt;/code&gt;引入的一个新特性，允许在定义类和接口的时候使用类型参数（&lt;code&gt;type parameter&lt;/code&gt;）。声明的类型参数在使用的时候使用具体的类型来替换。泛型最主要的应用是在&lt;code&gt;JDK
    
    </summary>
    
    
      <category term="Java" scheme="http://tinylcy.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>I/O重定向和管道</title>
    <link href="http://tinylcy.me/2016/08/19/IO%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E7%AE%A1%E9%81%93/"/>
    <id>http://tinylcy.me/2016/08/19/IO重定向和管道/</id>
    <published>2016-08-18T16:01:24.000Z</published>
    <updated>2017-04-25T04:47:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准I-O与重定向的若干概念"><a href="#标准I-O与重定向的若干概念" class="headerlink" title="标准I/O与重定向的若干概念"></a>标准I/O与重定向的若干概念</h2><h3 id="3个标准文件描述符"><a href="#3个标准文件描述符" class="headerlink" title="3个标准文件描述符"></a>3个标准文件描述符</h3><p>所有的<code>Unix</code>工具都使用文件描述符<code>0</code>、<code>1</code>和<code>2</code>。如下图所示，标准输入文件的描述符是<code>0</code>，标准输出的文件描述符是<code>1</code>，标准错误输出的文件描述符则是<code>2</code>。<code>Unix</code>假设文件描述符<code>0</code>、<code>1</code>和<code>2</code>都已经被打开，可以分别进行读、写和写的操作。</p>
<p><img src="/img/2016-08-18-Image 1.png" alt="Alt text"></p>
<h3 id="重定向I-O的是shell而不是程序"><a href="#重定向I-O的是shell而不是程序" class="headerlink" title="重定向I/O的是shell而不是程序"></a>重定向I/O的是shell而不是程序</h3><p>通过使用输出重定向标志，命令<code>cmd&gt;filename</code>告诉<code>shell</code>将文件描述符1定位到文件。于是<code>shell</code>就将文件描述符与指定的文件连接起来。程序持续不断地将数据写到文件描述符<code>1</code>中，根本没有意识到数据的目的地已经改变了。<code>listargs.c</code>展示了程序甚至没有看到命令行中的重定向符号。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span>* av[])</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"Number of args: %d, Args are: \n"</span>, ac);</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ac; i++) &#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"args[%d] %s\n"</span>, i, av[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This message is sent to stderr.\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序<code>listargs</code>将命令行参数打印到标准输出。注意<code>listargs</code>并没有打印出重定向符号和文件名。</p>
<p><img src="/img/2016-08-18-Image 2.png" alt="Alt text"></p>
<p>如上图所示验证了关于<code>shell</code>输出重定向的一些重要概念。</p>
<ul>
<li><code>shell</code>并不将重定向标记和文件名传递给程序。</li>
<li>重定向可以出现在命令行中的任何地方，并且在重定向标识符周围并不需要空格来区分。例如上图命令<code>./listargs testing &gt;xyz one two 2&gt;oops</code>也可以写成<code>./listargs &gt;xyz testing one two 2&gt;oops</code>，如下图所示。</li>
</ul>
<p><img src="/img/2016-08-18-Image 3.png" alt="Alt text"></p>
<h3 id="最低可用文件描述符原则"><a href="#最低可用文件描述符原则" class="headerlink" title="最低可用文件描述符原则"></a>最低可用文件描述符原则</h3><p>文件描述符是一个数组的索引号。每个进程都有其打开的一组文件，这些打开的文件被保持在一个数组中。文件描述符即为某文件在此数组中的索引。并且，当打开文件时，为此文件安排的文件描述符总是此数组中最低可用位置的索引。</p>
<h2 id="将stdin重定向到文件"><a href="#将stdin重定向到文件" class="headerlink" title="将stdin重定向到文件"></a>将stdin重定向到文件</h2><p>考虑如何将标准输入重定向以至可以从文件中读取数据。更加精确的说，进程并不是从文件读数据，而是从文件描述符读取数据。如果将文件描述符<code>0</code>重定向到一个文件，那么此文件就成为标准输入的源。</p>
<h3 id="方法1：close-then-open"><a href="#方法1：close-then-open" class="headerlink" title="方法1：close-then-open"></a>方法1：close-then-open</h3><p>第一种放方法是<code>close-then-open</code>策略，具体步骤如下：</p>
<ul>
<li>开始时，系统中采用的是典型的设置，即三种标准流是被连接到终端设备上的。输入的数据流经过文件描述符<code>0</code>而输出的流经过文件描述符<code>1</code>和<code>2</code>。</li>
<li>接下来，调用<code>close(0)</code>，将标准输入与终端设备的连接切断。</li>
<li>最后，使用<code>open(filename, O_RDONLY)</code>打开一个想连接到<code>stdin</code>上的文件。当前的最低可用文件描述符是<code>0</code>，因此所打开的文件将被连接到标准输入上。任何从标准输入读取数据的函数都将从此文件中读取数据。</li>
</ul>
<h3 id="方法2：open-close-dup-close"><a href="#方法2：open-close-dup-close" class="headerlink" title="方法2：open-close-dup-close"></a>方法2：open-close-dup-close</h3><p><code>Unix</code>系统调用<code>dup</code>建立指向已经存在的文件描述符的第二个连接，这种方法需要<code>4</code>个步骤。</p>
<ul>
<li><code>open(file)</code>，打开<code>stdin</code>将要重定向的文件。这个调用返回一个文件描述符<code>fd</code>，这个描述符并不是<code>0</code>，因为<code>0</code>在当前已经被打开了。</li>
<li><code>close(0)</code>，将文件描述符<code>0</code>关闭，现在文件描述符<code>0</code>已经空闲了。</li>
<li><code>dup(fd)</code>，系统调用<code>dup(fd)</code>将文件描述符<code>fd</code>做了一个复制。此处复制使用最低可用的文件描述符号。因此获得的文件描述符是<code>0</code>。这样，就将磁盘文件与文件描述符<code>0</code>连接在一起了。</li>
<li><code>close(fd)</code>，使用<code>close(fd)</code>来关闭原始连接，只留下文件描述符<code>0</code>的连接。</li>
</ul>
<p><code>dup</code>在学习管道的时候非常重要，一个简单一点的方案是将<code>close(0)和dup(fd)</code>结合在一起作为一个单独的系统调用<code>dup2</code>。</p>
<h2 id="重定向I-O：who-gt-userlist"><a href="#重定向I-O：who-gt-userlist" class="headerlink" title="重定向I/O：who&gt;userlist"></a>重定向I/O：who&gt;userlist</h2><p>当输入<code>who&gt;userlist</code>时，<code>shell</code>运行<code>who</code>程序，并将<code>who</code>的标准输出重定向到名为<code>userlist</code>的文件上。<code>shell</code>实现该重定向的关键之处在于<code>fork</code>和<code>exec</code>之间的时间间隙。在<code>fork</code>执行完后，子进程仍然在运行父进程也就是<code>shell</code>程序，并准备执行<code>exec</code>。<code>exec</code>将替换进程中运行的程序，但是它不会改变进程的属性和进程中所有的连接。也就是说，在运行<code>exec</code>之后，进程的用户<code>ID</code>不会改变，其优先级也不会改变，并且其文件描述符也和运行<code>exec</code>之前一样。因此，利用这个原则来实现重定向标准输出。</p>
<p>此时<code>who</code>就是子进程要执行的命令，当执行<code>fork</code>前，父进程的文件描述符<code>1</code>指向终端。当执行<code>fork</code>之后，子进程的文件描述符也喜欢指向终端，此时，子进程尝试执行<code>close(1)</code>，<code>close(1)</code>之后，文件描述符<code>1</code>成为最低未用文件描述符，子进程现在再执行<code>creat(userlist, mode)</code>打开文件<code>userlist</code>，文件描述符<code>1</code>被连接到文件<code>userlist</code>。因此，子进程的标准输出被重定向到文件<code>userlist</code>，子进程然后调用<code>exec</code>执行<code>who</code>。</p>
<p>子进程执行了<code>who</code>程序，于是子进程中的代码和数据都被<code>who</code>程序的代码和数据所替换了，然而文件描述符被保留下来。因为打开的文件并非是程序的代码也不是数据，它们属于进程的属性，因此<code>exec</code>调用并不改变它们。</p>
<h2 id="管道编程"><a href="#管道编程" class="headerlink" title="管道编程"></a>管道编程</h2><p>管道是内核中一个单向的数据通道，管道有一个读取端和一个写入端，可以用来连接一个进程的输出和另一个进程的输入。</p>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>使用系统调用<code>result = pipe(int array[2])</code>来创建管道，并将其两端连接到两个文件描述符。如下图所示，<code>array[0]</code>为读取数据端的文件描述符，而<code>array[1]</code>则为写数据端的文件描述符。类似与<code>open</code>调用，<code>pipe</code>调用也使用最低可用文件描述符。</p>
<p><img src="/img/2016-08-18-Image 4.png" alt="Alt text"></p>
<p>程序<code>pipedemo.c</code>展示了如何创建管道并使用管道向自己发送数据。核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> len, i, apipe[<span class="number">2</span>];</div><div class="line"><span class="keyword">char</span> buf[BUFSIZ];</div><div class="line"></div><div class="line"><span class="keyword">if</span>(pipe(apipe) == <span class="number">-1</span>) &#123;</div><div class="line">	perror(<span class="string">"could not make pipe."</span>);</div><div class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">printf</span>(<span class="string">"Got a pipe! It is file descriptors: &#123;%d %d&#125;\n"</span>, apipe[<span class="number">0</span>], apipe[<span class="number">1</span>]);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(fgets(buf, BUFSIZ, <span class="built_in">stdin</span>)) &#123;</div><div class="line">	len = <span class="built_in">strlen</span>(buf);</div><div class="line">	<span class="keyword">if</span>(write(apipe[<span class="number">1</span>], buf, len) != len) &#123;</div><div class="line">		perror(<span class="string">"writing to pipe."</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">		buf[i] = <span class="string">'X'</span>;</div><div class="line">	&#125;</div><div class="line">	len = read(apipe[<span class="number">0</span>], buf, BUFSIZ);</div><div class="line">	<span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</div><div class="line">		perror(<span class="string">"reading from pipe."</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(write(<span class="number">1</span>, buf, len) != len) &#123;</div><div class="line">		perror(<span class="string">"writing to stdout"</span>);</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数据流从键盘到进程，从进程到管道，再从管道到进程以及从进程回到终端。</p>
<h3 id="使用fork来共享管道"><a href="#使用fork来共享管道" class="headerlink" title="使用fork来共享管道"></a>使用fork来共享管道</h3><p>当进程创建一个管道之后，该进程就有了连向管道两端的连接。当这个进程调用<code>fork</code>的时候，它的子进程也得到了这两个连向管道的连接。父进程和子进程都可以将数据写到管道的写数据端口，并从读数据端口将数据读出。但是当一个进程读，而另一个进程写的时候，管道的使用效率是最高的。程序<code>pipedemo2.c</code>说明了如何将<code>pipe</code>和<code>fork</code>结合起来，创建一对通过管道来通信的进程，核心代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</div><div class="line"><span class="keyword">int</span> len;</div><div class="line"><span class="keyword">char</span> buf[BUFSIZ];</div><div class="line"><span class="keyword">int</span> read_len;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(pipe(pipefd) == <span class="number">-1</span>) &#123;</div><div class="line">	oops(<span class="string">"cannot get a pipe"</span>, <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">switch</span>(fork()) &#123;</div><div class="line">	<span class="keyword">case</span> <span class="number">-1</span>:</div><div class="line">		oops(<span class="string">"cannot fork"</span>, <span class="number">2</span>);</div><div class="line">	<span class="comment">/*子进程*/</span></div><div class="line">	<span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">		len = <span class="built_in">strlen</span>(CHILD_MESS);</div><div class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(write(pipefd[<span class="number">1</span>], CHILD_MESS, len) != len) &#123;</div><div class="line">				oops(<span class="string">"write"</span>, <span class="number">3</span>);</div><div class="line">			&#125;</div><div class="line">			sleep(<span class="number">5</span>);</div><div class="line">		&#125;</div><div class="line">	<span class="comment">/*父进程*/</span></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		len = <span class="built_in">strlen</span>(PAR_MESS);</div><div class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(write(pipefd[<span class="number">1</span>], PAR_MESS, len) != len) &#123;</div><div class="line">				oops(<span class="string">"write"</span>, <span class="number">4</span>);</div><div class="line">			&#125; </div><div class="line">			sleep(<span class="number">1</span>);</div><div class="line">			read_len = read(pipefd[<span class="number">0</span>], buf, BUFSIZ);</div><div class="line">			<span class="keyword">if</span>(read_len &lt;= <span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">			write(<span class="number">1</span>, buf, read_len);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><ul>
<li><p>从管道中读取数据</p>
<ul>
<li>当进程试图从管道读取数据时，进程被挂起直到数据被写进管道。</li>
<li>当所有的写进程关闭了管道的写数据端时，试图从管道中读取数据的调用会返回<code>0</code>，这意味这文件的结束。</li>
</ul>
</li>
<li><p>向管道中写数据</p>
<ul>
<li>写入数据阻塞直到管道有空间去容纳新的数据。</li>
<li>如果所有的读进程都已关闭了管道的读数据端，那么对管道的写入调用将会执行失败。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Unix</code>默认从文件描述符<code>0</code>读取数据，写数据到文件描述符<code>1</code>，将错误信息输出到文件描述符<code>2</code>。</li>
<li>创建文件描述符的系统调用总是使用最低可用文件描述符号。</li>
<li>重定向标准输入、标准输出和错误输出意味着改变文件描述符<code>0</code>、<code>1</code>和<code>2</code>的连接。</li>
<li>管道是内核中的一个数据队列，其每一端连接一个文件描述符。程序通过<code>pipe</code>系统调用来创建管道。</li>
<li>当父进程调用<code>fork</code>的时候，管道的两端都被复制到子进程中。</li>
<li>只有有共同父进程的进程之间才可以用管道连接。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>相关代码见<a href="https://github.com/tinylcy/LeetCode/tree/master/Linux%20Commands%20Implementation/io" target="_blank" rel="external">Github</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://book.douban.com/subject/1219329/" target="_blank" rel="external">Unix/Linux编程实践教程</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;标准I-O与重定向的若干概念&quot;&gt;&lt;a href=&quot;#标准I-O与重定向的若干概念&quot; class=&quot;headerlink&quot; title=&quot;标准I/O与重定向的若干概念&quot;&gt;&lt;/a&gt;标准I/O与重定向的若干概念&lt;/h2&gt;&lt;h3 id=&quot;3个标准文件描述符&quot;&gt;&lt;a hre
    
    </summary>
    
    
      <category term="Unix/Linux" scheme="http://tinylcy.me/tags/Unix-Linux/"/>
    
  </entry>
  
</feed>
