<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>谈谈 RocketMQ 消息存储的设计与实现 - STAR 皆空</title>
  <!-- Begin Jekyll SEO tag v2.3.0 -->
<meta property="og:title" content="谈谈 RocketMQ 消息存储的设计与实现">
<meta property="og:locale" content="en_US">
<meta name="description" content="作为一款高性能的消息中间件，RocketMQ 基于互联网的生产要求对多 Topic 场景做了诸多针对性优化。根据中间件团队提供的 压测报告，在 Producer 和 Consumer 共存的情况下，相比于 Kafka，RocketMQ 的性能指标（TPS 和 RT）随着 Topic 数量的上升表现稳定。本文从消息存储的角度谈谈 RocketMQ 高性能的原因，重点包括四个方面：消息文件存储的结构设计、消息从 Broker 接收到持久化磁盘的流程、刷盘策略和内存映射优化机制。">
<meta property="og:description" content="作为一款高性能的消息中间件，RocketMQ 基于互联网的生产要求对多 Topic 场景做了诸多针对性优化。根据中间件团队提供的 压测报告，在 Producer 和 Consumer 共存的情况下，相比于 Kafka，RocketMQ 的性能指标（TPS 和 RT）随着 Topic 数量的上升表现稳定。本文从消息存储的角度谈谈 RocketMQ 高性能的原因，重点包括四个方面：消息文件存储的结构设计、消息从 Broker 接收到持久化磁盘的流程、刷盘策略和内存映射优化机制。">
<link rel="canonical" href="https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/">
<meta property="og:url" content="https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/">
<meta property="og:site_name" content="STAR 皆空">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-07-21T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@">
<meta property="article:publisher" content="1234">
<meta property="fb:app_id" content="1234">
<script type="application/ld+json">
{"name":null,"description":"作为一款高性能的消息中间件，RocketMQ 基于互联网的生产要求对多 Topic 场景做了诸多针对性优化。根据中间件团队提供的 压测报告，在 Producer 和 Consumer 共存的情况下，相比于 Kafka，RocketMQ 的性能指标（TPS 和 RT）随着 Topic 数量的上升表现稳定。本文从消息存储的角度谈谈 RocketMQ 高性能的原因，重点包括四个方面：消息文件存储的结构设计、消息从 Broker 接收到持久化磁盘的流程、刷盘策略和内存映射优化机制。","author":null,"@type":"BlogPosting","url":"https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/","publisher":null,"image":null,"headline":"谈谈 RocketMQ 消息存储的设计与实现","dateModified":"2019-07-21T00:00:00+08:00","datePublished":"2019-07-21T00:00:00+08:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  
  <link rel="alternate" type="application/rss+xml" title="STAR 皆空" href="https://tinylcy.github.io/feed.xml">
  <link rel="stylesheet" href="/assets/css/nangka.css">

  

</head>

  <body>
    <header class="site-header">
    <div class="wrapper">
        <a href="#" class="menu-icon">
            <svg viewbox="0 0 18 15">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
                <path d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
                <path d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
            </svg>
        </a>
        <a class="site-title" href="/">STAR 皆空</a>
        <nav class="site-nav">
            <div class="trigger">
            
                
            
                
                        <a class="page-link" href="/about/">关于我</a>
                
            
                
                        <a class="page-link" href="/archive/">归档</a>
                
            
                
                        <a class="page-link" href="/darktime/">暗时间</a>
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
                
            
            </div>
        </nav>
    </div>
</header>

    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">谈谈 RocketMQ 消息存储的设计与实现</h1>
    <p class="post-meta">
       <time datetime="2019-07-21T00:00:00+08:00" itemprop="datePublished">
          Jul 21, 2019
       </time>
       
        <!-- | <span class="time">
            24
          </span>
           Minute Read -->
    </p>
  </header>
  <div class="post-content" itemprop="articleBody">
    <p>作为一款高性能的消息中间件，RocketMQ 基于互联网的生产要求对多 Topic 场景做了诸多针对性优化。根据中间件团队提供的 <a href="http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/">压测报告</a>，在 Producer 和 Consumer 共存的情况下，相比于 Kafka，RocketMQ 的性能指标（TPS 和 RT）随着 Topic 数量的上升表现稳定。本文从消息存储的角度谈谈 RocketMQ 高性能的原因，重点包括四个方面：消息文件存储的结构设计、消息从 Broker 接收到持久化磁盘的流程、刷盘策略和内存映射优化机制。</p>

<h3 id="消息文件存储结构">消息文件存储结构</h3>

<p>与 Kafka 类似，RocketMQ 选择直接操作文件系统来提升存储效率，不同的是，RocketMQ 将消息持久化过程最大化的转化为顺序写。为了进一步理解消息存储结构，本文作者在单机部署了 RocketMQ 并投递一定量的消息。RocketMQ 默认存储路径为 $HOME/store，相关文件目录结构如下。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>tree ~/store/commitlog ~/store/consumequeue ~/store/index
/Users/chenyang/store/commitlog
├── 00000000000000000000
└── 00000000001073741824
/Users/chenyang/store/consumequeue
└── TopicTest
    ├── 0
    │   ├── 00000000000000000000
    │   ├── 00000000000006000000
    │   ├── 00000000000012000000
    │   ├── 00000000000018000000
    │   └── 00000000000024000000
    ├── 1
    │   └── ...
    ├── 2
    │   └── ...
    └── 3
        └── ...
/Users/chenyang/store/index
└── 20190626213710317
</code></pre></div></div>

<p>Kafka 以 Topic 作为文件存储的基本单元，即每个 Topic 有其对应的数据文件和索引文件。当存在大量 Topic 时，消息持久化逐渐变成一种随机写磁盘的行为，此时磁盘 IO 成为影响系统吞吐量的主要因素。针对上述问题，RocketMQ 首先将消息的写入转化为顺序写，即所有 Topic 的消息均写入同一个文件（CommitLog）。同时，由于消息仍需要以 Topic 为维度进行消费，因此 RocketMQ 基于 CommitLog 为每个 Topic 异步构建多个逻辑队列（ConsumeQueue）和索引信息（Index）：ConsumeQueue 记录了消息在 CommitLog 中的位置信息；给定 Topic 和消息 Key，索引文件（Index）提供消息检索的能力，主要在问题排查和数据统计等场景应用。ConsumeQueue 和 Index 的构建依然遵循顺序写。</p>

<p>RocketMQ 利用 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a> 将文件直接映射到用户态内存地址，由此将对文件的 IO 转化为对内存的 IO。由于使用 mmap 必须明确内存映射的大小，因此 RocketMQ 约定：单个 CommitLog 文件大小等于 1 GB，每条消息及其元信息被顺序追加至文件，文件尾部可能存在空闲区域；单个 ConsumeQueue 文件大小等于 6000000 B，存储 30 W 条记录，每条记录固定 20 B；单个 Index 文件大小等于 420000040 B，包含索引头（IndexHeader）、哈希槽（HashSlot）和消息索引（MessageIndex）。同时，CommitLog 和 ConsumeQueue 以字节偏移量作为文件名，因此第二个 CommitLog 的文件名为 1024 * 1024 * 1024 = 00000000001073741824，而第二个 ConsumeQueue 的文件名为 20 * 30 W =  00000000000006000000。</p>

<p>RocketMQ 以如下图所示存储格式将消息顺序写入 CommitLog。除了记录消息本身的属性（消息长度、消息体、Topic 长度、Topic、消息属性长度和消息属性），CommitLog 同时记录了消息所在消费队列的信息（消费队列 ID 和偏移量）。由于存储条目具备不定长的特性，当 CommitLog 剩余空间无法满足消息时，CommitLog 在尾部追加一个 MAGIC CODE 等于 BLANK_MAGIC_CODE 的存储条目作为结束标记，并将消息存储至下一个 CommitLog 文件。</p>

<p><img src="/img/2019-07-21-RocketMQ%20CommitLog%20Item.jpg" alt=""></p>

<p>与 CommitLog 不同，ConsumeQueue 的存储条目采用定长存储结构，如下图所示。为了实现定长存储，ConsumeQueue 存储了消息 Tag 的 Hash Code，在进行 Broker 端消息过滤时，通过比较 Consumer 订阅 Tag 的 HashCode 和存储条目中的 Tag Hash Code 是否一致来决定是否消费消息。</p>

<p><img src="/img/2019-07-21-RocketMQ%20ConsumeQueue%20Item.jpg" alt=""></p>

<p>在已有的 CommitLog 和 ConsumeQueue 基础之上，消息中间件的消息发送和消费逻辑已经可以得到满足，RocketMQ 引入 Index 的目的是为消息建立索引方便问题排查：在给定消息 Topic 和 Key 的前提下，快速定位消息。Index 的文件存储结构如下图所示。Index 的整体设计思想类似持久化在磁盘的 HashMap，同样使用链式地址法解决哈希冲突：每个 Hash Slot 关联一个 Message Index 链表，多个 Message Index 通过 preIndexOffset 连接。</p>

<p><img src="/img/2019-07-21-RocketMQ%20Index.jpg" alt=""></p>

<p>本节讨论了 RocketMQ 消息存储相关的核心文件存储结构。无论是 CommitLog，ConsumeQueue 还是 Index，RocketMQ 均使用统一的 MappedFile 来抽象。本文将讨论 RocketMQ 是如何围绕 MappedFile 并结合内存映射来构建 CommitLog（本文对 ConsumeQueue 和 Index 的异步构建不进行讨论）。</p>

<h3 id="消息存储流程">消息存储流程</h3>

<p>在启动阶段，Broker 将消息处理器注册至核心控制器（BrokerController），Broker 根据请求的 RequestCode 将请求路由至对应的消息处理器。相比于 NameServer 将所有网络通信交由单一的消息处理器处理，Broker 定义了八种消息处理器（AdminBrokerProcessor、ClientManageProcessor、ConsumerManageProcessor、EndTransactionProcessor、ForwardRequestProcessor、PullMessageProcessor、QueryMessageProcessor 和 SendMessageProcessor）。其中，SendMessageProcessor 负责处理消息发送请求，其注册相关的核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.broker.BrokerStartup#main</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">start</span><span class="o">(</span><span class="n">createBrokerController</span><span class="o">(</span><span class="n">args</span><span class="o">));</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.broker.BrokerStartup#createBrokerController</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">BrokerController</span> <span class="nf">createBrokerController</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// Configuation initialization.</span>
        <span class="kd">final</span> <span class="n">BrokerConfig</span> <span class="n">brokerConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BrokerConfig</span><span class="o">();</span>
        <span class="kd">final</span> <span class="n">NettyServerConfig</span> <span class="n">nettyServerConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NettyServerConfig</span><span class="o">();</span>
        <span class="kd">final</span> <span class="n">NettyClientConfig</span> <span class="n">nettyClientConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NettyClientConfig</span><span class="o">();</span>
        <span class="kd">final</span> <span class="n">BrokerController</span> <span class="n">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BrokerController</span><span class="o">(</span>
            <span class="n">brokerConfig</span><span class="o">,</span>
            <span class="n">nettyServerConfig</span><span class="o">,</span>
            <span class="n">nettyClientConfig</span><span class="o">,</span>
            <span class="n">messageStoreConfig</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="kt">boolean</span> <span class="n">initResult</span> <span class="o">=</span> <span class="n">controller</span><span class="o">.</span><span class="na">initialize</span><span class="o">();</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">controller</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.broker.BrokerController#initialize</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">initialize</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">CloneNotSupportedException</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="c1">// Create several thread pool service.</span>
    <span class="k">this</span><span class="o">.</span><span class="na">registerProcessor</span><span class="o">();</span>
    <span class="c1">// Create and execute a periodic action.</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.broker.BrokerController#registerProcessor</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerProcessor</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">SendMessageProcessor</span> <span class="n">sendProcessor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SendMessageProcessor</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="n">sendProcessor</span><span class="o">.</span><span class="na">registerSendMessageHook</span><span class="o">(</span><span class="n">sendMessageHookList</span><span class="o">);</span>
    <span class="n">sendProcessor</span><span class="o">.</span><span class="na">registerConsumeMessageHook</span><span class="o">(</span><span class="n">consumeMessageHookList</span><span class="o">);</span>

    <span class="k">this</span><span class="o">.</span><span class="na">remotingServer</span><span class="o">.</span><span class="na">registerProcessor</span><span class="o">(</span><span class="n">RequestCode</span><span class="o">.</span><span class="na">SEND_MESSAGE</span><span class="o">,</span> 
                                          <span class="n">sendProcessor</span><span class="o">,</span>
                                          <span class="k">this</span><span class="o">.</span><span class="na">sendMessageExecutor</span><span class="o">);</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>SendMessageProcessor 实现了 NettyRequestProcessor 接口，其对消息的核心处理逻辑实现在 processRequest 方法中，RocketMQ 发送消息包括单个消息发送和批量消息发送，本节以单个消息发送为例进一步说明。不同 Topic 的消息最终均被顺序持久化至共享的 CommitLog，CommitLog 由固定大小的文件队列组成，文件队列被定义为 MappedFileQueue，MappedFileQueue 中每个文件被定义为 MappedFile，每个MappedFile 对应一个具体的文件用于将消息持久化至磁盘。CommitLog、MappedFileQueue 和 MappedFile 之间的依赖关系如下所示。</p>

<p><img src="/img/2019-07-21-RocketMQ%20CommitLog.jpg" alt=""></p>

<p>Broker 启动阶段 DefaultMessageStore 被初始化，DefaultMessageStore 是 RocketMQ 消息存储的抽象，提供 CommitLog 的维护、ConsumeQueue &amp; Index 的异步构建（ReputMessageService）、MappedFile 内存映射的分配（AllocateMappedFileService）、HA（HAService） 等保障。DefaultMessageStore 通过 putMessage 方法将消息存储至 CommitLog，核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.DefaultMessageStore#putMessage</span>
<span class="kd">public</span> <span class="n">PutMessageResult</span> <span class="nf">putMessage</span><span class="o">(</span><span class="n">MessageExtBrokerInner</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">shutdown</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PutMessageResult</span><span class="o">(</span><span class="n">PutMessageStatus</span><span class="o">.</span><span class="na">SERVICE_NOT_AVAILABLE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">BrokerRole</span><span class="o">.</span><span class="na">SLAVE</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">messageStoreConfig</span><span class="o">.</span><span class="na">getBrokerRole</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PutMessageResult</span><span class="o">(</span><span class="n">PutMessageStatus</span><span class="o">.</span><span class="na">SERVICE_NOT_AVAILABLE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">runningFlags</span><span class="o">.</span><span class="na">isWriteable</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PutMessageResult</span><span class="o">(</span><span class="n">PutMessageStatus</span><span class="o">.</span><span class="na">SERVICE_NOT_AVAILABLE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getTopic</span><span class="o">().</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">Byte</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PutMessageResult</span><span class="o">(</span><span class="n">PutMessageStatus</span><span class="o">.</span><span class="na">MESSAGE_ILLEGAL</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">getPropertiesString</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span> 
        <span class="o">&amp;&amp;</span> <span class="n">msg</span><span class="o">.</span><span class="na">getPropertiesString</span><span class="o">().</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">Short</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PutMessageResult</span><span class="o">(</span><span class="n">PutMessageStatus</span><span class="o">.</span><span class="na">PROPERTIES_SIZE_EXCEEDED</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">isOSPageCacheBusy</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">PutMessageResult</span><span class="o">(</span><span class="n">PutMessageStatus</span><span class="o">.</span><span class="na">OS_PAGECACHE_BUSY</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="n">PutMessageResult</span> <span class="n">result</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">commitLog</span><span class="o">.</span><span class="na">putMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>在将消息存储至 CommitLog 之前，需要校验 DefaultMessageStore 状态、当前 Broker 节点角色、DefaultMessageStore 是否允许写入、Topic 和 Properties 是否超长和 PageCache 是否繁忙。校验通过后，消息交由 CommitLog 的 putMessage 方法将消息 append 至 MappedFileQueue 中最后一个 MappedFile。putMessage 方法核心流程（暂不涉及延迟消息）包括：尝试获取最后一个 MappedFile，然后通过对 CommitLog 加锁将 append CommitLog 限定为一种串行操作；如果没有获取到 MappedFile 或者 MappedFile 已满，创建新的 MappedFile；将消息 append 至 MappedFile，如果返回结果为 END_OF_FILE，说明 MappedFile 已经没有足够的剩余空间，创建新的 MappedFile 并将消息重新 append 至新 MappedFile；释放 CommitLog 锁。上述逻辑核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.CommitLog#putMessage</span>
<span class="kd">public</span> <span class="n">PutMessageResult</span> <span class="nf">putMessage</span><span class="o">(</span><span class="kd">final</span> <span class="n">MessageExtBrokerInner</span> <span class="n">msg</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">AppendMessageResult</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="n">MappedFile</span> <span class="n">mappedFile</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileQueue</span><span class="o">.</span><span class="na">getLastMappedFile</span><span class="o">();</span>
    <span class="n">putMessageLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">//spin or ReentrantLock ,depending on store config</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">==</span> <span class="n">mappedFile</span> <span class="o">||</span> <span class="n">mappedFile</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">mappedFile</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileQueue</span><span class="o">.</span><span class="na">getLastMappedFile</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="o">...</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">mappedFile</span><span class="o">.</span><span class="na">appendMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">appendMessageCallback</span><span class="o">);</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getStatus</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">PUT_OK:</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">END_OF_FILE:</span>
                <span class="c1">// Create a new file, re-write the message</span>
                <span class="n">mappedFile</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileQueue</span><span class="o">.</span><span class="na">getLastMappedFile</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
                <span class="o">...</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">mappedFile</span><span class="o">.</span><span class="na">appendMessage</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">appendMessageCallback</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="o">...</span>
        <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">putMessageLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// 本节暂不讨论 Broker 刷盘策略以及 HA 机制</span>
    <span class="n">handleDiskFlush</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">putMessageResult</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
    <span class="n">handleHA</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">putMessageResult</span><span class="o">,</span> <span class="n">msg</span><span class="o">);</span>
    
    <span class="k">return</span> <span class="n">putMessageResult</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>进一步理解创建 MappedFile 的原理。DefaultMessageStore 初始化期间启动 AllocateMappedFileService 线程。当需要创建 MappedFile 时，首先基于 startOffset 计算 MappedFile 文件名，包括两种场景：如果此时不存在 MappedFile，意味着当前为第一次消息投递或者历史 MappedFile 已经被清理，createOffset 不能简单等于 startOffset % mappedFileSize，以避免 MappedFile 文件名无限制增长；如果此时最后一个 MappedFile 已存在且已满，createOffset 等于最后一个 MappedFile 的 fromOffset + mappedFileSize。消息处理线程基于 createOffset 构建两个连续的 AllocateRequest 并插入 AllocateMappedFileService 线程维护的 requestQueue。AllocateMappedFileService 线程读取 requestQueue 中的 AllocateRequest 异步创建对应的 MappedFile。在创建过程中，消息处理线程通过 CountDownLatch 同步等待 MappedFile 完成创建。<strong>思考一个问题</strong>，消息处理线程为什么不直接同步创建 MappedFile，而是通过创建一个 AllocateRequest 请求，由 AllocateMappedFileService 线程异步统一处理？构建 AllocateRequest 并插入 requestQueue 的核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.MappedFileQueue#getLastMappedFile</span>
<span class="kd">public</span> <span class="n">MappedFile</span> <span class="nf">getLastMappedFile</span><span class="o">(</span><span class="kd">final</span> <span class="kt">long</span> <span class="n">startOffset</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">getLastMappedFile</span><span class="o">(</span><span class="n">startOffset</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.MappedFileQueue#getLastMappedFile</span>
<span class="kd">public</span> <span class="n">MappedFile</span> <span class="nf">getLastMappedFile</span><span class="o">(</span><span class="kd">final</span> <span class="kt">long</span> <span class="n">startOffset</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">needCreate</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">createOffset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="n">MappedFile</span> <span class="n">mappedFileLast</span> <span class="o">=</span> <span class="n">getLastMappedFile</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">mappedFileLast</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">createOffset</span> <span class="o">=</span> <span class="n">startOffset</span> <span class="o">-</span> <span class="o">(</span><span class="n">startOffset</span> <span class="o">%</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileSize</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">mappedFileLast</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">mappedFileLast</span><span class="o">.</span><span class="na">isFull</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">createOffset</span> <span class="o">=</span> <span class="n">mappedFileLast</span><span class="o">.</span><span class="na">getFileFromOffset</span><span class="o">()</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileSize</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">createOffset</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">needCreate</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">nextFilePath</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">storePath</span> <span class="o">+</span> <span class="n">File</span><span class="o">.</span><span class="na">separator</span> <span class="o">+</span> 
            <span class="n">UtilAll</span><span class="o">.</span><span class="na">offset2FileName</span><span class="o">(</span><span class="n">createOffset</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">nextNextFilePath</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">storePath</span> <span class="o">+</span> <span class="n">File</span><span class="o">.</span><span class="na">separator</span>
            <span class="o">+</span> <span class="n">UtilAll</span><span class="o">.</span><span class="na">offset2FileName</span><span class="o">(</span><span class="n">createOffset</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileSize</span><span class="o">);</span>
        <span class="n">MappedFile</span> <span class="n">mappedFile</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">allocateMappedFileService</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mappedFile</span> <span class="o">=</span> 
                <span class="k">this</span><span class="o">.</span><span class="na">allocateMappedFileService</span><span class="o">.</span><span class="na">putRequestAndReturnMappedFile</span><span class="o">(</span><span class="n">nextFilePath</span><span class="o">,</span>
													<span class="n">nextNextFilePath</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedFileSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">mappedFile</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">mappedFileLast</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.AllocateMappedFileService#putRequestAndReturnMappedFile</span>
<span class="kd">public</span> <span class="n">MappedFile</span> <span class="nf">putRequestAndReturnMappedFile</span><span class="o">(</span><span class="n">String</span> <span class="n">nextFilePath</span><span class="o">,</span> <span class="n">String</span> <span class="n">nextNextFilePath</span><span class="o">,</span> <span class="kt">int</span> <span class="n">fileSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">canSubmitRequests</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">...</span>
    <span class="n">AllocateRequest</span> <span class="n">nextReq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocateRequest</span><span class="o">(</span><span class="n">nextFilePath</span><span class="o">,</span> <span class="n">fileSize</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">nextPutOK</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestTable</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">nextFilePath</span><span class="o">,</span> <span class="n">nextReq</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">nextPutOK</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="kt">boolean</span> <span class="n">offerOK</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nextReq</span><span class="o">);</span>
        <span class="o">...</span>
        <span class="n">canSubmitRequests</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="n">AllocateRequest</span> <span class="n">nextNextReq</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocateRequest</span><span class="o">(</span><span class="n">nextNextFilePath</span><span class="o">,</span> <span class="n">fileSize</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">nextNextPutOK</span> <span class="o">=</span> 
        <span class="k">this</span><span class="o">.</span><span class="na">requestTable</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">nextNextFilePath</span><span class="o">,</span> <span class="n">nextNextReq</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nextNextPutOK</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">canSubmitRequests</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">...</span>
            <span class="k">this</span><span class="o">.</span><span class="na">requestTable</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nextNextFilePath</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">offerOK</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nextNextReq</span><span class="o">);</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span>
    <span class="n">AllocateRequest</span> <span class="n">result</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nextFilePath</span><span class="o">);</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">result</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">waitOK</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getCountDownLatch</span><span class="o">().</span><span class="na">await</span><span class="o">(</span><span class="n">waitTimeOut</span><span class="o">,</span> 
                                                              <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">waitOK</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">requestTable</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nextFilePath</span><span class="o">);</span>
                <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="na">getMappedFile</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> 
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getServiceName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" service has exception. "</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>回答上面提出的问题，AllocateMappedFileService 线程循环从 requestQueue 获取 AllocateRequest，AllocateRequest 实现了 Comparable 接口，依据文件名从小到大排序。当需要创建 MappedFile 时，同时构建两个 AllocateRequest，消息处理线程通过 CountDownLatch 将 AllocateMappedFileService 线程异步创建第一个 MappedFile 文件转化为同步操作（RocketMQ 存在大量利用 CountDownLatch 将异步转化为同步的案例），而第二个 MappedFile 文件的仍然创建交由 AllocateMappedFileService 线程异步创建。当消息处理线程需要再次创建 MappedFile 时，此时可以直接获取已创建的 MappedFile。AllocateMappedFileService 线程创建 MappedFile 核心逻辑精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.AllocateMappedFileService#run</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isStopped</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">mmapOperation</span><span class="o">())</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.AllocateMappedFileService#mmapOperation</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">mmapOperation</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">AllocateRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">req</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
        <span class="n">AllocateRequest</span> <span class="n">expectedRequest</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestTable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getFilePath</span><span class="o">());</span>
        <span class="o">...</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getMappedFile</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">MappedFile</span> <span class="n">mappedFile</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">messageStore</span><span class="o">.</span><span class="na">getMessageStoreConfig</span><span class="o">().</span><span class="na">isTransientStorePoolEnable</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">mappedFile</span> <span class="o">=</span> <span class="n">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">MappedFile</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
                    <span class="n">mappedFile</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getFilePath</span><span class="o">(),</span> <span class="n">req</span><span class="o">.</span><span class="na">getFileSize</span><span class="o">(),</span> 
                                    <span class="n">messageStore</span><span class="o">.</span><span class="na">getTransientStorePool</span><span class="o">());</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="o">...</span>
                    <span class="n">mappedFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MappedFile</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getFilePath</span><span class="o">(),</span> <span class="n">req</span><span class="o">.</span><span class="na">getFileSize</span><span class="o">(),</span>
                                                <span class="n">messageStore</span><span class="o">.</span><span class="na">getTransientStorePool</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">mappedFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MappedFile</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getFilePath</span><span class="o">(),</span> <span class="n">req</span><span class="o">.</span><span class="na">getFileSize</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="o">...</span>
            <span class="n">req</span><span class="o">.</span><span class="na">setMappedFile</span><span class="o">(</span><span class="n">mappedFile</span><span class="o">);</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="n">req</span><span class="o">.</span><span class="na">getCountDownLatch</span><span class="o">().</span><span class="na">countDown</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>继续理解 MappedFile 的创建原理。如果 isTransientStorePoolEnable 为 true，MappedFile 会将TransientStorePool 申请的堆外内存（Direct Byte Buffer）空间作为 writeBuffer，写入消息时先将消息写入 writeBuffer，然后将消息提交至 fileChannel 再 flush；否则，直接创建 MappedFile 内存映射文件字节缓冲区mappedByteBuffer，将消息写入 mappedByteBuffer 再 flush。完成消息写入后，更新 wrotePosition（此时还未 flush 至磁盘）。对于 RocketMQ 写入消息时为什么采用两种不同的方式，本文不做过多分析。消息 append 至 MappedFile 核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.MappedFile#appendMessage</span>
<span class="kd">public</span> <span class="n">AppendMessageResult</span> <span class="nf">appendMessage</span><span class="o">(</span><span class="kd">final</span> <span class="n">MessageExtBrokerInner</span> <span class="n">msg</span><span class="o">,</span> 
                                         <span class="kd">final</span> <span class="n">AppendMessageCallback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">appendMessagesInner</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">cb</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.MappedFile#appendMessagesInner</span>
<span class="kd">public</span> <span class="n">AppendMessageResult</span> <span class="nf">appendMessagesInner</span><span class="o">(</span><span class="kd">final</span> <span class="n">MessageExt</span> <span class="n">messageExt</span><span class="o">,</span> 
                                               <span class="kd">final</span> <span class="n">AppendMessageCallback</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">currentPos</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">wrotePosition</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">currentPos</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">fileSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">writeBuffer</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span>
            <span class="n">writeBuffer</span><span class="o">.</span><span class="na">slice</span><span class="o">()</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedByteBuffer</span><span class="o">.</span><span class="na">slice</span><span class="o">();</span>
        <span class="n">byteBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">currentPos</span><span class="o">);</span>
        <span class="n">AppendMessageResult</span> <span class="n">result</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">messageExt</span> <span class="k">instanceof</span> <span class="n">MessageExtBrokerInner</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">doAppend</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getFileFromOffset</span><span class="o">(),</span> <span class="n">byteBuffer</span><span class="o">,</span> 
                                 <span class="k">this</span><span class="o">.</span><span class="na">fileSize</span> <span class="o">-</span> <span class="n">currentPos</span><span class="o">,</span> 
                                 <span class="o">(</span><span class="n">MessageExtBrokerInner</span><span class="o">)</span> <span class="n">messageExt</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="o">...</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">wrotePosition</span><span class="o">.</span><span class="na">addAndGet</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getWroteBytes</span><span class="o">());</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">AppendMessageResult</span><span class="o">(</span><span class="n">AppendMessageStatus</span><span class="o">.</span><span class="na">UNKNOWN_ERROR</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend</span>
<span class="kd">public</span> <span class="n">AppendMessageResult</span> <span class="nf">doAppend</span><span class="o">(</span><span class="kd">final</span> <span class="kt">long</span> <span class="n">fileFromOffset</span><span class="o">,</span> 
                                    <span class="kd">final</span> <span class="n">ByteBuffer</span> <span class="n">byteBuffer</span><span class="o">,</span> 
                                    <span class="kd">final</span> <span class="kt">int</span> <span class="n">maxBlank</span><span class="o">,</span>
    								<span class="kd">final</span> <span class="n">MessageExtBrokerInner</span> <span class="n">msgInner</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// PHY OFFSET</span>
    <span class="kt">long</span> <span class="n">wroteOffset</span> <span class="o">=</span> <span class="n">fileFromOffset</span> <span class="o">+</span> <span class="n">byteBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">();</span>
    <span class="o">...</span>
    <span class="kd">final</span> <span class="kt">int</span> <span class="n">msgLen</span> <span class="o">=</span> <span class="n">calMsgLength</span><span class="o">(</span><span class="n">bodyLength</span><span class="o">,</span> <span class="n">topicLength</span><span class="o">,</span> <span class="n">propertiesLength</span><span class="o">);</span>
    <span class="o">...</span>

    <span class="c1">// Determines whether there is sufficient free space</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">msgLen</span> <span class="o">+</span> <span class="n">END_FILE_MIN_BLANK_LENGTH</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">maxBlank</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">resetByteBuffer</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">msgStoreItemMemory</span><span class="o">,</span> <span class="n">maxBlank</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">msgStoreItemMemory</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">maxBlank</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">msgStoreItemMemory</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">CommitLog</span><span class="o">.</span><span class="na">BLANK_MAGIC_CODE</span><span class="o">);</span>
        <span class="n">byteBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">msgStoreItemMemory</span><span class="o">.</span><span class="na">array</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span> <span class="n">maxBlank</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">AppendMessageResult</span><span class="o">(...);</span>
    <span class="o">}</span>

    <span class="c1">// Initialization of storage space</span>

    <span class="n">byteBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">msgStoreItemMemory</span><span class="o">.</span><span class="na">array</span><span class="o">(),</span> <span class="mi">0</span><span class="o">,</span> <span class="n">msgLen</span><span class="o">);</span>

    <span class="n">AppendMessageResult</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AppendMessageResult</span><span class="o">(...);</span>
    <span class="o">...</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>如果有足够的剩余空间供消息写入，设置 byteBuffer（writeBuffer/mappedByteBuffer）的 position 等于 wrotePosition，执行 byteBuffer 的 put 方法将字节数组写入即可。如果 MappedFile 没有足够剩余空间（msgLen + END_FILE_MIN_BLANK_LENGTH &gt; maxBlank），向 byteBuffer 写入 BLANK_MAGIC_CODE 后返回 END_OF_FILE，消息处理线程创建新的 MappedFile 并将消息 append 至 byteBuffer，映射关系如下图所示。</p>

<p><img src="/img/2019-07-21-RocketMQ%20doAppend.jpg" alt=""></p>

<h3 id="刷盘策略">刷盘策略</h3>

<p>RocketMQ 刷盘策略分为 commit 和 flush 两阶段，分别由 commitLogService 和 flushCommitLogService 负责，如下图所示：在 commit 阶段，如果 isTransientStorePoolEnable 为 true，数据从 writeBuffer 写入 fileChannel，否则数据仍然驻留在 mappedByteBuffer；在 flush 阶段，将数据从 fileChannel 或者 mappedByteBuffer 持久化至磁盘。</p>

<p><img src="/img/2019-07-21-RocketMQ%20persist.jpg" alt="persist"></p>

<p>在 CommitLog 构造阶段，commitLogService 被实例化为 CommitRealTimeService，对于同步刷盘，flushCommitLogService 被实例化为 GroupCommitService，对于异步刷盘，flushCommitLogService 被实例化为 FlushRealTimeService。CommitRealTimeService、GroupCommitService 和 FlushRealTimeService 均继承自 ServiceThread 类并实现了 Runnable 接口，在 Broker 启动后创建线程并循环执行相应操作。CommitLog 构造函数及启动代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.CommitLog#CommitLog</span>
<span class="kd">public</span> <span class="nf">CommitLog</span><span class="o">(</span><span class="kd">final</span> <span class="n">DefaultMessageStore</span> <span class="n">defaultMessageStore</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">FlushDiskType</span><span class="o">.</span><span class="na">SYNC_FLUSH</span> <span class="o">==</span> 
        <span class="n">defaultMessageStore</span><span class="o">.</span><span class="na">getMessageStoreConfig</span><span class="o">().</span><span class="na">getFlushDiskType</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">flushCommitLogService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GroupCommitService</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">flushCommitLogService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FlushRealTimeService</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">this</span><span class="o">.</span><span class="na">commitLogService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CommitRealTimeService</span><span class="o">();</span>
    <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.CommitLog#start</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">flushCommitLogService</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">defaultMessageStore</span><span class="o">.</span><span class="na">getMessageStoreConfig</span><span class="o">().</span><span class="na">isTransientStorePoolEnable</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">commitLogService</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>GroupCommitService 线程将 writeBuffer 中的数据 commit 至 fileChannel，执行 commit 有以下两个触发条件。</p>

<ul>
  <li>writeBuffer 中待 commit 的数据的页数大于等于 commitCommitLogLeastPages，默认为 4 页，每页大小为 4 KB，即当待 commit 的数据超过 16 KB 时，执行 commit 操作。</li>
  <li>最近 commitCommitLogThoroughInterval 时间间隔内没有执行 commit 操作，主动执行一次 commit 操作，默认为 200 ms。</li>
</ul>

<p>上述两个触发条件控制了 writeBuffer 中的数据能够在合并后再写入 fileChannel，提升 IO 性能。commit 操作执行完成后，GroupCommitService 唤醒 flushCommitLogService 线程执行 flush 操作。上述流程对应代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.CommitLog.CommitRealTimeService#run</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isStopped</span><span class="o">())</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="kt">int</span> <span class="n">commitDataLeastPages</span> <span class="o">=</span> <span class="o">...</span>
        <span class="kt">int</span> <span class="n">commitDataThoroughInterval</span> <span class="o">=</span> <span class="o">...</span>
        <span class="kt">long</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">begin</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">lastCommitTimestamp</span> <span class="o">+</span> <span class="n">commitDataThoroughInterval</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">lastCommitTimestamp</span> <span class="o">=</span> <span class="n">begin</span><span class="o">;</span>
            <span class="n">commitDataLeastPages</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CommitLog</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">mappedFileQueue</span><span class="o">.</span><span class="na">commit</span><span class="o">(</span><span class="n">commitDataLeastPages</span><span class="o">);</span>
            <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">result</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">lastCommitTimestamp</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span> <span class="c1">// result = false means some data committed.</span>
                <span class="c1">//now wake up flush thread.</span>
                <span class="n">flushCommitLogService</span><span class="o">.</span><span class="na">wakeup</span><span class="o">();</span>
            <span class="o">}</span>

            <span class="o">...</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>commit 操作本节不再详细讨论，MappedFile 维护的 committedPosition 和 wrotePosition 分别标记了 writeBuffer 中待 commit 数据的起始偏移量和终止偏移量，commit 操作基于此构造 ByteBuffer 并写入 fileChannel。上述流程核心代码如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.MappedFile#commit0</span>
<span class="kd">protected</span> <span class="kt">void</span> <span class="nf">commit0</span><span class="o">(</span><span class="kd">final</span> <span class="kt">int</span> <span class="n">commitLeastPages</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">writePos</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">wrotePosition</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">lastCommittedPosition</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">committedPosition</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">writePos</span> <span class="o">-</span> <span class="k">this</span><span class="o">.</span><span class="na">committedPosition</span><span class="o">.</span><span class="na">get</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="n">writeBuffer</span><span class="o">.</span><span class="na">slice</span><span class="o">();</span>
            <span class="n">byteBuffer</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">lastCommittedPosition</span><span class="o">);</span>
            <span class="n">byteBuffer</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="n">writePos</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">fileChannel</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">lastCommittedPosition</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">fileChannel</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">byteBuffer</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">committedPosition</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">writePos</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>相比于 Kafka，除了提供异步刷盘的能力，RocketMQ 还提供了同步刷盘的能力。同步刷盘的实现方式类似于 MappedFile 创建，即构造刷盘请求 GroupCommitRequest 写入请求队列，由异步线程 GroupCommitService 消费请求。对于异步刷盘，如果 isTransientStorePoolEnable 为 true，唤醒 CommitRealTimeService 线程将 writeBuffer 中的数据 commit 至 fileChannel，否则唤醒 FlushRealTimeService 线程将 mappedByteBuffer 的数据刷盘。RocketMQ 发起刷盘的核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.CommitLog#handleDiskFlush</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handleDiskFlush</span><span class="o">(</span><span class="n">AppendMessageResult</span> <span class="n">result</span><span class="o">,</span> 
                            <span class="n">PutMessageResult</span> <span class="n">putMessageResult</span><span class="o">,</span> <span class="n">MessageExt</span> <span class="n">messageExt</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// Synchronization flush</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">FlushDiskType</span><span class="o">.</span><span class="na">SYNC_FLUSH</span> <span class="o">==</span> 
        <span class="k">this</span><span class="o">.</span><span class="na">defaultMessageStore</span><span class="o">.</span><span class="na">getMessageStoreConfig</span><span class="o">().</span><span class="na">getFlushDiskType</span><span class="o">())</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">GroupCommitService</span> <span class="n">service</span> <span class="o">=</span> <span class="o">(</span><span class="n">GroupCommitService</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">flushCommitLogService</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">messageExt</span><span class="o">.</span><span class="na">isWaitStoreMsgOK</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">GroupCommitRequest</span> <span class="n">request</span> <span class="o">=</span> 
                <span class="k">new</span> <span class="nf">GroupCommitRequest</span><span class="o">(</span><span class="n">result</span><span class="o">.</span><span class="na">getWroteOffset</span><span class="o">()</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="na">getWroteBytes</span><span class="o">());</span>
            <span class="n">service</span><span class="o">.</span><span class="na">putRequest</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
            <span class="kt">boolean</span> <span class="n">flushOK</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">waitForFlush</span><span class="o">(...);</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">flushOK</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">...</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">service</span><span class="o">.</span><span class="na">wakeup</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// Asynchronous flush</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isTransientStorePoolEnable</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">flushCommitLogService</span><span class="o">.</span><span class="na">wakeup</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">commitLogService</span><span class="o">.</span><span class="na">wakeup</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>为了避免刷盘请求 GroupCommitRequest 的锁竞争，GroupCommitService 线程维护了 GroupCommitRequest 读队列 requestsRead 和写队列 requestsWrite，GroupCommitRequest 的提交和消费互不阻塞。当 GroupCommitService 线程消费完 requestsRead 队列后，清空 requestsRead，交换 requestsRead 和 requestsWrite。上述逻辑核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">GroupCommitService</span> <span class="kd">extends</span> <span class="n">FlushCommitLogService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GroupCommitRequest</span><span class="o">&gt;</span> <span class="n">requestsWrite</span> <span class="o">=</span> 
        <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">GroupCommitRequest</span><span class="o">&gt;();</span>
    <span class="kd">private</span> <span class="kd">volatile</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">GroupCommitRequest</span><span class="o">&gt;</span> <span class="n">requestsRead</span> <span class="o">=</span> 
        <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">GroupCommitRequest</span><span class="o">&gt;();</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">putRequest</span><span class="o">(</span><span class="kd">final</span> <span class="n">GroupCommitRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">requestsWrite</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">requestsWrite</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hasNotified</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">waitPoint</span><span class="o">.</span><span class="na">countDown</span><span class="o">();</span> <span class="c1">// notify</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">swapRequests</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">GroupCommitRequest</span><span class="o">&gt;</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestsWrite</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">requestsWrite</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestsRead</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">requestsRead</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">doCommit</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">requestsRead</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">requestsRead</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">GroupCommitRequest</span> <span class="n">req</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">requestsRead</span><span class="o">)</span> <span class="o">{</span>
                   <span class="c1">// Invoke force() to flush fileChannel/mappedByteBuffer to disk.</span>
                <span class="o">}</span>
                <span class="o">...</span>
                <span class="k">this</span><span class="o">.</span><span class="na">requestsRead</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="o">...</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">isStopped</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">waitForRunning</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
                <span class="k">this</span><span class="o">.</span><span class="na">doCommit</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">...</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="o">...</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">swapRequests</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">this</span><span class="o">.</span><span class="na">doCommit</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>无论是否开启 isTransientStorePoolEnable，异步刷盘交由 FlushRealTimeService 线程处理。在 handleDiskFlush 方法中，如果 isTransientStorePoolEnable 为 true，仅唤醒了 CommitRealTimeService 线程，但是实际上 CommitRealTimeService 线程在 commit 之后也会唤醒 FlushRealTimeService 线程。FlushRealTimeService 线程维护了 lastFlushTimestamp 以标记上次 flush 磁盘的时间点。 FlushRealTimeService 线程 flush 磁盘的触发条件与 GroupCommitService 线程 commit 数据的触发条件类似： fileChannel 或者 mappedByteBuffer 中待 flush 的数据页大小大于等于 flushPhysicQueueLeastPages 页，默认为 4 页；距上次 flush 磁盘时间间隔超过 flushPhysicQueueThoroughInterval，默认为 10 s。最终 FlushRealTimeService 线程调用 fileChannel 和 mappedByteBuffer 的 force 方法将数据刷盘。</p>

<h3 id="内存映射优化">内存映射优化</h3>

<p>RocketMQ 利用 mmap 将内核空间的一段内存区域映射至用户空间，映射关系一旦建立，应用程序对这段内存区域的修改可以直接反映到内核空间，反之亦然。相比如 read/write 系统调用，mmap 减少了内核空间和用户空间之间的数据拷贝，在存在大量数据传输的场景下可以有效提升 IO 效率。但是，通过 mmap 建立内存映射仅是将文件磁盘地址和虚拟地址通过映射对应起来，此时物理内存并没有填充磁盘文件内容。当实际发生文件读写时，产生产生缺页中断并陷入内核，然后才会将磁盘文件内容读取至物理内存。针对上述场景，RocketMQ 设计了 MappedFile 预热机制。</p>

<p>回顾 MappedFile 的创建流程，AllocateMappedFileService 线程轮询 AllocateRequest 请求队列并创建MappedFile，此时文件系统中已经存在对应的固定大小的文件。当 RocketMQ 开启 MappedFile 内存预热（warmMapedFileEnable），且 MappedFile 文件映射空间大小大于等于 mapedFileSizeCommitLog（1 GB） 时，调用 warmMappedFile 方法对 MappedFile 进行预热。上述逻辑核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.AllocateMappedFileService#mmapOperation</span>
<span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">mmapOperation</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="n">isSuccess</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="n">AllocateRequest</span> <span class="n">req</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">req</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">requestQueue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getMappedFile</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">MappedFile</span> <span class="n">mappedFile</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">messageStore</span><span class="o">.</span><span class="na">getMessageStoreConfig</span><span class="o">().</span><span class="na">isTransientStorePoolEnable</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">mappedFile</span> <span class="o">=</span> <span class="n">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">MappedFile</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
                <span class="n">mappedFile</span><span class="o">.</span><span class="na">init</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getFilePath</span><span class="o">(),</span> <span class="n">req</span><span class="o">.</span><span class="na">getFileSize</span><span class="o">(),</span> 
                                <span class="n">messageStore</span><span class="o">.</span><span class="na">getTransientStorePool</span><span class="o">());</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">mappedFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MappedFile</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getFilePath</span><span class="o">(),</span> <span class="n">req</span><span class="o">.</span><span class="na">getFileSize</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="o">...</span>
            <span class="c1">// pre write mappedFile</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mappedFile</span><span class="o">.</span><span class="na">getFileSize</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">getMapedFileSizeCommitLog</span><span class="o">()</span>
                						<span class="o">&amp;&amp;</span> <span class="n">isWarmMapedFileEnable</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">mappedFile</span><span class="o">.</span><span class="na">warmMappedFile</span><span class="o">(</span><span class="n">getFlushDiskType</span><span class="o">(),</span>
                                          <span class="n">getFlushLeastPagesWhenWarmMapedFile</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>warmMappedFile 每间隔 OS_PAGE_SIZE 向 mappedByteBuffer 写入一个 0，此时对应页恰好产生一个缺页中断，操作系统为对应页分配物理内存。同时，如果刷盘策略为同步刷盘，需要对每页进行刷盘。最后，通过 JNA 调用 mlock 方法锁定 mappedByteBuffer 对应的物理内存，阻止操作系统将相关的内存页调度到交换空间（swap space），以此提升后续在访问 MappedFile 时的读写性能。warmMappedFile 核心代码精简如下。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// org.apache.rocketmq.store.MappedFile#warmMappedFile</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">warmMappedFile</span><span class="o">(</span><span class="n">FlushDiskType</span> <span class="n">type</span><span class="o">,</span> <span class="kt">int</span> <span class="n">pages</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">ByteBuffer</span> <span class="n">byteBuffer</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mappedByteBuffer</span><span class="o">.</span><span class="na">slice</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">.</span><span class="na">fileSize</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">MappedFile</span><span class="o">.</span><span class="na">OS_PAGE_SIZE</span><span class="o">,</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">byteBuffer</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="kt">byte</span><span class="o">)</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">FlushDiskType</span><span class="o">.</span><span class="na">SYNC_FLUSH</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">((</span><span class="n">i</span> <span class="o">/</span> <span class="n">OS_PAGE_SIZE</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">flush</span> <span class="o">/</span> <span class="n">OS_PAGE_SIZE</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="n">pages</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">flush</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="n">mappedByteBuffer</span><span class="o">.</span><span class="na">force</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// prevent gc</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">...</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// force flush when prepare load finished</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">FlushDiskType</span><span class="o">.</span><span class="na">SYNC_FLUSH</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mappedByteBuffer</span><span class="o">.</span><span class="na">force</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="k">this</span><span class="o">.</span><span class="na">mlock</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// org.apache.rocketmq.store.MappedFile#mlock</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">mlock</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="kt">long</span> <span class="n">address</span> <span class="o">=</span> <span class="o">((</span><span class="n">DirectBuffer</span><span class="o">)</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">mappedByteBuffer</span><span class="o">)).</span><span class="na">address</span><span class="o">();</span>
    <span class="n">Pointer</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Pointer</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LibC</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">.</span><span class="na">mlock</span><span class="o">(</span><span class="n">pointer</span><span class="o">,</span> <span class="k">new</span> <span class="n">NativeLong</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">fileSize</span><span class="o">));</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="总结">总结</h3>

<p>为了实现高性能的消息中间件，RocketMQ 做了诸多性能优化。本文结合源码分析了 RocketMQ 消息存储的设计与实现，重点对支持顺序写的消息存储结构、MappedFile 创建、异步线程结合 CountDownLatch 实现任务执行的异步转同步、堆外内存、MappedFile 内存预热 和 JNA 内存锁定展开了讨论。</p>

<h3 id="参考">参考</h3>

<p>[1] https://github.com/apache/rocketmq</p>

<p>[2] http://jm.taobao.org/2016/04/07/kafka-vs-rocketmq-topic-amout/</p>

<p>[3] https://rocketmq.apache.org/docs/quick-start/</p>

<p>[4] http://man7.org/linux/man-pages/man2/mmap.2.html</p>

<p>[5] http://man7.org/linux/man-pages/man2/mlock.2.html</p>

  </div>
  <footer class="post-footer">

    <!-- Social Share Button-->
    <!-- <ul class="sharebutton">
      <li class="share">Share :</li>
      <li class="fb">
        <a href="#" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),'facebook-share-dialog','width=626,height=436');return false;">Facebook</a>
      </li>
      <li class="linkedin">
        <a href="http://www.linkedin.com/cws/share?url=https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/" onclick="window.open(this.href,&quot;popupwindow&quot;,&quot;status=0,height=500,width=700,resizable=0,top=50,left=100&quot;);return false;" target="_blank" title="Share on Linkedin">Linkedin</a>
      </li>
      <li class="twitter">
        <a href="https://twitter.com/intent/tweet?text=https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/ - 谈谈 RocketMQ 消息存储的设计与实现 by @" target="_blank" title="Share to Twitter">Twitter</a>
      </li>
      <li class="gplus">
        <a href="https://plus.google.com/share?url=https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/" onclick="window.open(this.href,&quot;popupwindow&quot;,&quot;status=0,height=500,width=700,resizable=0,top=50,left=100&quot;);return false;" target="_blank" title="Share on Google Plus">Google+</a>
      </li>
      <li class="pinterest">
        <a href="http://pinterest.com/pin/create/link/?url=https://tinylcy.github.io/2019/the-design-of-rocketmq-message-storage-system/" target="_blank" title="Share to Pinterest">Pinterest</a>
      </li>
    </ul> -->

    <!-- Post Navigation -->
    <div class="post-navigation">
      <a class="prev" href="/2019/the-art-of-code/">← Previous Post</a>
      
    </div>
      

  </footer>
</article>

      </div>
    </div>
    <footer class="site-footer">
  <div class="wrapper">
      <div class="copy">
          2019 © STAR 皆空
      </div>
  </div>
</footer>

    <script type="text/javascript" src="/assets/js/jquery-1.11.2.min.js"></script>

<script type="text/javascript" src="/assets/js/scripts.js"></script>

  </body>
</html>
