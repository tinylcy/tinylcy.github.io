<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-02-10T13:40:25+08:00</updated><id>http://localhost:4000/</id><title type="html">STAR 皆空</title><subtitle>Welcome to my awesome blog.
</subtitle><entry><title type="html">我对Raft的理解 - Two</title><link href="http://localhost:4000/2018/Understanding-the-Raft-consensus-algorithm-Two/" rel="alternate" type="text/html" title="我对Raft的理解 - Two" /><published>2018-02-10T00:00:00+08:00</published><updated>2018-02-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/Understanding%20the%20Raft%20consensus%20algorithm-Two</id><content type="html" xml:base="http://localhost:4000/2018/Understanding-the-Raft-consensus-algorithm-Two/">&lt;p&gt;我们已对 Raft Leader 选举进行了&lt;a href=&quot;http://tinylcy.me/2018/%E6%88%91%E5%AF%B9Raft%E7%9A%84%E7%90%86%E8%A7%A3-One/&quot;&gt;理解&lt;/a&gt;，Leader 一旦被选举出来，对外提供服务，对内协调体日志复制。日志复制是 Raft 共识算法最核心的部分，我们逐步递进的去理解 Raft 是如何通过添加限制条件来保证日志能够被正确的复制。&lt;/p&gt;

&lt;h4 id=&quot;slide-11&quot;&gt;Slide 11&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.011.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个节点都维护了一份私有的日志的拷贝，节点存在宕机的风险，为了保证宕机后能够恢复日志，日志需要持久化存储在类似磁盘等介质中。日志由一组日志项组成，每个日志项（Log Entry）包含三部分：Index、Term 和 Command。Index 指示了日志项在日志中的索引，它是日志项的附加属性，类似数组元素下标；Term 指示了日志项被创建时 Leader 所处的任期；Command 指示了日志项包含的操作。&lt;/p&gt;

&lt;p&gt;Slide 11 中有一个 Leader，4 个 Follower，Leader 需要将日志项正确的复制到 Follower。&lt;strong&gt;注意，Leader 的目标并不在于将所有的日志项都复制到 Follower，而在于复制已经 Committed 的日志项&lt;/strong&gt;。Committed 是 Raft 中另一个非常重要的概念，需要好好理解。那么什么样的日志可以被认为是 Committed 的？我们先给出一个定义：&lt;strong&gt;如果某个日志项已经被复制到了大多数节点，那么就可以认为该日志项是 Committed 了，Raft 需要保证，已经 Committed 的日志项会永远存在于大部分节点的日志中&lt;/strong&gt;。不过，目前这个定义并不能保证日志被正确的复制，还需要添加限制条件。&lt;/p&gt;

&lt;p&gt;按照目前对 Committed 的定义，日志项 1 至日志项 7 已经被 Leader 复制到了大部分节点，因此可以认为前 7 项日志项已经 Committed 了。Committed 的日志项可以被状态机执行，而只有被状态机执行，才能响应客户端。&lt;/p&gt;

&lt;h4 id=&quot;slide-12&quot;&gt;Slide 12&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.012.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 反复强调算法的可理解性，在日志复制的过程中，Raft 将问题再次分解：&lt;strong&gt;Leader 正常运行时的日志复制&lt;/strong&gt;和 &lt;strong&gt;Leader 变更后的日志复制&lt;/strong&gt;。Leader 正常运行时的日志复制比较简单，分为以下几个步骤。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端向 Leader 发送指令，如果客户端向 Follower 发送了指令，Follower 会将请求重定向至 Leader。&lt;/li&gt;
  &lt;li&gt;Leader 创建日志项并 Append 至日志中。&lt;/li&gt;
  &lt;li&gt;Leader 向 Follower 发送 AppendEntries 消息，消息中包含了任期 Term 和指令（消息内容会在下文扩展）。&lt;/li&gt;
  &lt;li&gt;Follower 收到 AppendEntries 消息后，也会将日志 Append 至自己的日志中，然后响应 Leader。&lt;/li&gt;
  &lt;li&gt;如果 Leader 收到了大多数 Follower 的响应，说明日志项已经被复制到大多数节点了，即日志项已 Committed，Leader 将指令传递给状态机执行，并将结果返回给客户端。然后，Leader 向 Follower 发送 AppendEntries 消息，通知 Follower 该日志项已经 Committed，Follower 在收到消息后也会将指令传递给状态机执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 Follower 宕机，或者响应特别慢怎么办？Raft 会不断重试 RPC 请求直到成功。但是这对 Raft 的性能并不会有影响，因为 Leader 只需要收到大多数 Follower 的响应即可。&lt;/p&gt;

&lt;h4 id=&quot;slide-13&quot;&gt;Slide 13&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.013.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 解决的核心问题是如何安全的复制日志，使大多数节点都拥有已经 Committed 的日志。如果日志能够达成一致，那么 Raft 可以做出以下&lt;strong&gt;承诺&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;位于不同节点的两个日志项如果有相同的 Index 和 Term，那么他们有相同的指令&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;位于不同节点的两个日志项如果有相同的 Index 和 Term，那么该日志项之前的所有日志项也是相同的，包括 Index、Term 和指令&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于以上两个承诺，可以进一步得出：&lt;strong&gt;如果某个日志项已经是 Committed，那么该日志项之前的所有日志项也已是 Committed 的&lt;/strong&gt;。可以这么理解：如果某个日志项是 Committed 的，那么说明该日志项已经被复制到了大多数节点，根据两个承诺，该日志项之前的所有日志项是也都已经被复制到了大多数节点，因此也是 Committed 的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，不要忘记目前我们仍然简单地认为，只要日志项被复制到大多数节点上就是 Committed 了，接下来我们会修改日志项 Committed 的条件&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;接下来我们开始分析，Raft 是如何能够在复制日志时始终兑现承诺的？&lt;/p&gt;

&lt;h4 id=&quot;slide-14&quot;&gt;Slide 14&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.014.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基于 Raft 在复制日志时的承诺，我们可以得出重要的一个结论：Index 和 Term 可以唯一确定一个日志项&lt;/strong&gt;。也就是说，如果两个日志项有相同的 Index 和 Term，那么这两个日志项的指令一定相同。这是因为如果 Term 相同，说明是同一个 Leader 创建的日志项，而同一个 Leader 在某个 Index 下创建的日志项一定是相同的。这个结论会贯穿我们对 Raft 剩余部分的理解。我们现在关注 Raft 是如何实现承诺的。&lt;/p&gt;

&lt;p&gt;Leader 在向 Follower 复制日志时，发送的 AppendEntries 消息内会携带&lt;strong&gt;待复制日志项的前一个日志项的 Index 和 Term&lt;/strong&gt;。当 Follower 收到消息时，并不是无条件的 Append，而是会校验消息中的 Index 值和 Term 值是否等于 Follower 最后一个日志项的 Index 值和 Term 值，只有匹配才会 Append，否则直接拒绝。例如，Slide 14 中 Leader 准备复制 （5，3）日志项，消息中会附带上一个日志项（4，2）至 Follower，Slide 14 描述了两种可能的情况。&lt;/p&gt;

&lt;p&gt;基于 Follower 在 Append 日志项时会进行校验，我们尝试证明 Slide 13 中的两个承诺：证明过程实际上就是一个归纳的过程，一开始，所有 Follower 的日志为空时一定是成立，而接下来每次 Append 日志项都会校验前一个日志项是否一致，因此可以保证当前复制成功的日志项之前的所有日志项也都是一致的。&lt;/p&gt;

&lt;p&gt;注意：目前我们还不考虑 Leader 发生变更，这意味着 Leader 一定拥有所有已经 Committed 的日志项，那么如果出现 Leader 变更怎么办？我们会继续理解 Raft，实际上 Raft 在 Leader 选举时也有限制条件，并不是任意 Candidate 都能赢得选举。&lt;/p&gt;

&lt;h4 id=&quot;slide-15&quot;&gt;Slide 15&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.015.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前的讨论都是基于 Leader 正常运行时的情况，现在我们看看 Leader 发生变更时 Raft 是怎么处理的。&lt;/p&gt;

&lt;p&gt;Slide 15 展示了一种比较混乱的情况，不过我们可以推导 Leader 选举情况。Term 1 各个节点都运行正常，然后发生了 Leader 变更进入 Term 2， S5 成为了 Leader，接着又发生了 Leader 变更，S5 又成为 Leader，在运行一段时间后 S5 崩溃，S4 成为新的 Leader，然后 S4 又崩溃，S3 成为 Leader，然后 S1 成为 Leader，最后 S2 又成为 Leader。期间很可能发生了网络隔离，S1、S2 和 S3 在一个分区，S4 和 S5 在另一个分区。&lt;/p&gt;

&lt;p&gt;注意，我们已经强调过，&lt;strong&gt;Raft 的目的是要把已经 Committed 的日志项到大部分节点，而那些尚未 Committed 的日志项并不需要复制&lt;/strong&gt;。如果某个日志项没有 Committed，那么该日志项对应的客户端也不会收到响应，客户端在超时后重试即可。&lt;strong&gt;所以，Raft 要做的就是让新选举出来的 Leader 包含所有已经 Committed 的日志项，然后再由 Leader 将 Committed 的日志项复制到其他节点上&lt;/strong&gt;。因此，如果 Leader 包含所有已经 Committed 的日志项，那么 Leader 就是所谓的 “The Truth”，所以 Leader 只需要把自己的日志项复制到 Follower 就实现了一致。&lt;/p&gt;

&lt;p&gt;按照我们目前对 Committed 的定义，Term 1 中的所有日志项以及 Term 5 中 Index 等于 3 的日志项已经是 Committed 的。&lt;strong&gt;因此 Raft 要做的就是选举一个拥有所有 Committed 日志项的 Candidate 作为 Leader，然后让 Follower 的日志和 Leader 一致就可以了&lt;/strong&gt;。整个过程是非常自然：新选举出来的 Leader 并不会先和 Follower 进行日志同步，而是在进行日志复制时进行校验，一旦出现不一致再进行日志的复制。同时，为了和 Leader 达成一致，Follower 势必会舍弃自己原有的尚未 Committed 的日志项。&lt;/p&gt;

&lt;p&gt;小结：当 Leader 发生变更，Raft 要求新选举出来的 Leader 必须包含所有已经 Committed 的日志项，Leader 接下来只需要单纯的进行日志复制。 &lt;strong&gt;因此，我们接下来需要理解的问题就是：Raft 是如何保证新选举出来的 Leader 一定是拥有所有 Committed 日志项的&lt;/strong&gt;？&lt;/p&gt;

&lt;h4 id=&quot;slide-16&quot;&gt;Slide 16&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.016.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了保证 Leader 变更时的安全性，Raft 提出了一个 Safe Property：&lt;strong&gt;如果一个 Leader 决定某个日志项已经是 Committed 的，那么该日志项会一直出现在未来 Leader 的日志中&lt;/strong&gt;。 Safe Property 其实是和 Slide 15 提到的概念是一致的，即&lt;strong&gt;新选举出来的 Leader 需要包含所有已经 Committed 的日志项&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了满足安全性需求，Leader 需要满足以下三点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leader 只能 Append 日志项，不能覆盖日志项。&lt;strong&gt;需要注意的是，这点仅仅是针对 Leader 的要求，Leader 包含所有已经 Committed 的日志项，同时 Leader 也可能包含某些尚未 Committed 的日志项，Raft 要做的是将已经 Committed 的日志项复制到 Follower，但是如果把 Leader 尚未 Committed 的日志项复制给 Follower，也是没有问题的。而一旦下次出现 Leader 变更，上个 Leader 中尚未 Committed 的日志项也是会被舍弃的&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;只有在 Leader 中的日志项才能被 Committed。&lt;/li&gt;
  &lt;li&gt;只有已经 Committed 的日志项才能被应用到状态机。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;回顾 Slide 15，Raft 要保证新选举出来的 Leader 必须是包含所有已经 Committed 的日志项，接下来我们开始分析 Raft 增加了哪些限制条件来实现这一目标。同时，我们也进一步在日志项 Committed 的定义上增加限制条件。&lt;/p&gt;

&lt;h4 id=&quot;slide-17&quot;&gt;Slide 17&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.017.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前文已经说到，新选举出来的 Leader 应该包含所有 Committed 日志项，但是实际上很难界定一个日志项是否是 Committed 的，按照目前对 Committed 的定义，即很难界定一个日志项是否已经被复制到大部分节点。Slide 17 描述了一种场景：存在三个节点，其中日志项 5 已经被复制到大多数节点，即日志项 5 已经是 Committed 的，如果节点 3 突然宕机，需要从剩余 2 个节点中选举 Leader，此时日志项 5 是否已经 Committed 是无法得知的，因为日志项 5 是否 Committed 取决于节点 3，而节点 3 宕机了。&lt;/p&gt;

&lt;p&gt;Raft 采取的策略是：&lt;strong&gt;选择最有可能包含所有 Committed 日志项的节点作为 Leader&lt;/strong&gt;。&lt;strong&gt;最有可能&lt;/strong&gt;的含义是指&lt;strong&gt;某个节点包含最新且数量最多&lt;/strong&gt;的日志项。其中&lt;strong&gt;最新&lt;/strong&gt;体现在节点最后一个日志项有&lt;strong&gt;最大的 Term&lt;/strong&gt;，&lt;strong&gt;数量最多&lt;/strong&gt;是在&lt;strong&gt;最新&lt;/strong&gt;的基础上，日志项的 &lt;strong&gt;Index 最大&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;现在给 Raft Leader 选举增加限制条件：Candidate 给其他节点发送的 RequestVote 消息中会同时携带 Candidate 最后一个日志项的 Term 和 Index，其他节点在收到 RequestVote 消息后，如果发现消息中的 Term 大于自己当前的 Term，或者 Term 相同，但是消息中的 Index 更大，那么可以认为 Candidate 拥有更完整的日志项，因此就会给 Candidate 投票，否则拒绝投票。&lt;/p&gt;

&lt;h4 id=&quot;slide-18&quot;&gt;Slide 18&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.018.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们以具体的场景进一步理解 Leader 选举。5 个节点，S1 为 Leader，其余均为 Follower。S1 将日志项 4 复制到了 S3，此时日志项 4 已经是 Committed 了。如果现在出现 Leader 变更，S4 最多能够获得来自 S5 的投票，S5 不会获得任何投票，只有 S1、S2 或 S3 可以赢得选举，而 S1、S2 和 S3 都是拥有所有已经 Committed 日志项的节点，所以能够保证安全性。&lt;/p&gt;

&lt;h4 id=&quot;slide-19&quot;&gt;Slide 19&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.019.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再分析一个场景。5 个节点，S1 当选为 Term 2 的 Leader，复制日志项 2 至 S2后，S1 宕机。在 Term 3，S5 可以获得来自 S3、S4 和自身的投票并当选为 Leader，S5 创建了 3 个日志项后宕机。进入 Term 4，S1 可以获得来自 S2、S3 和 S4 的投票并当选为 Leader，S1 将日志项 3 复制至 S3 后，日志项 3 已经在被复制到了大多数节点，&lt;strong&gt;那么此时能否认为日志项 3 是 Committed 的呢&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;答案是不能，考虑这种场景：当 S1 把 日志项 3 复制到 S3 后，S1 又宕机了。进入 Term 5，S5 可以获得来自 S2、S3 和 S4 的投票，因为 S5 的 Term 更大，所以 S5 可以当选为 Leader。当 S5 成为 Leader 之后，S3 将会用自己的日志项 3 覆盖 S1、S2 和 S3 的日志项 3，&lt;strong&gt;这将导致覆盖已经 Committed 的日志项&lt;/strong&gt;，显然不能保证安全性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们意识到之前关于 Committed 的定义已经不能够保证安全性了，所以我们需要给 Committed 的定义增加限制条件&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;slide-20&quot;&gt;Slide 20&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.020.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为 Committed 的定义增加一条新的限制：&lt;strong&gt;只有在当前 Term 内创建的新日志项被复制到大部分节点后，之前 Term 内被复制到大部分节点的日志项才是 Committed 的。可以这么理解，如果当前 Term 内的日志项都已经被复制到了大部分节点，那么该日志项之前的日志项更应该是被复制到了大部分节点。而当前 Term 内的日志项被复制到大部分节点，又可以保证比当前 Term 低的节点不可能在下次选举中成为 Leader。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再次回顾上一个不安全的场景：S1 把在 Term 4 内创建的日志项 4 复制到了大部分节点后，如果 S1 宕机了，S5 是无法获取大部分投票从而无法成为 Leader。因为日志项 4 已经被复制到了大部分节点，所以此时才可以认为日志项 3 已经是 Committed 的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;截止目前，我们梳理完毕 Raft 算法为了保证安全性给 Leader 选举 和 Committed 定义增加的限制条件。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;slide-21&quot;&gt;Slide 21&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.021.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过增加限制条件，我们现在已经可以保证 Raft 的安全性。当 Leader 选举出来后，有些 Follower 可能缺少日志项，有些 Follower 可能存在无关的未提交日志项。&lt;strong&gt;注意，Follower 中如果存在 Leader 不存在的日志项，Follower 并不需要复制给 Leader，因为日志项未提交说明该日志项对应的客户端没有收到响应，客户端可以通过重试解决问题。所以，只需要让 Follower 的日志和 Leader 保持一致即可。&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;slide-22&quot;&gt;Slide 22&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.022.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们已经知道，为了和 Leader 的日志一致，Follower 需要删除不相关的日志项和填充缺失的日志项，那么 Raft 是怎么实现的呢？Leader 为每个 Follower 维护了一个 NextIndex 标记，NextIndex 的值初始化为 Leader 最后一个日志项的 Index 加 1。Leader 在向 Follower 发送 AppendEntries 消息时会发现一致性问题，一旦不一致，那么 NextIndex 减 1。&lt;/p&gt;

&lt;p&gt;以 Slide 22 图例说明，Leader 为每个 Follower 的 NextIndex 值初始化为 11，然后进行日志复制，Leader 发送 AppendEntries 消息给 Follower，AppendEntries 消息中会携带 Leader 的&lt;strong&gt;最后一个日志项&lt;/strong&gt;的 Index 和 Term，即（10，6）。如果发生冲突，NextIndex 减 1，Leader 会发送携带（9，6）的 AppendEntries 消息，直至 Leader 发送携带（4，4）的 AppendEntries 消息后，才解决冲突。冲突解决后，Leader 就可以将后续所有的日志项发送给 Follower。&lt;/p&gt;

&lt;p&gt;注意，因为在节点刚当选 Leader 时很可能首先会发送心跳消息（不包含日志的 AppendEntries 消息）给 Follower，因此我们认为是&lt;strong&gt;最后一个日志项的 Index 和 Term&lt;/strong&gt;。如果是普通的 AppendEntries 消息（包含日志），依旧发送包含（10，6）的 AppendEntries 消息给Follower，如果一致那么消息中的日志就直接复制给 Follower，如果不一致 NextIndex 减 1。&lt;/p&gt;

&lt;h4 id=&quot;slide-23&quot;&gt;Slide 23&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.023.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在进行日志复制时，当 Leader 通过调整 NextIndex 找到了冲突日志的起始位置后，就开始复制日志给 Follower。一旦 Follower 的日志项被覆盖，那么该日志项之后的所有日志项都会被舍弃。&lt;/p&gt;

&lt;p&gt;以 Slide 23 为例，当 Leader 将 日志项 4 复制给 Follower 后，Follower 日志项 4 之后的所有日志项便是多余的，可以直接舍弃。&lt;/p&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;p&gt;Raft 为了保证日志复制时的安全性，为 Leader 选举和日志项的 Committed 增加了限制条件。通过分析各种场景，我们理解了 Raft 增加这些限制条件的原因，以及这些限制条件为什么能够保证安全。&lt;/p&gt;</content><author><name></name></author><summary type="html">我们已对 Raft Leader 选举进行了理解，Leader 一旦被选举出来，对外提供服务，对内协调体日志复制。日志复制是 Raft 共识算法最核心的部分，我们逐步递进的去理解 Raft 是如何通过添加限制条件来保证日志能够被正确的复制。</summary></entry><entry><title type="html">我对Raft的理解 - One</title><link href="http://localhost:4000/2018/Understanding-the-Raft-consensus-algorithm-One/" rel="alternate" type="text/html" title="我对Raft的理解 - One" /><published>2018-02-09T00:00:00+08:00</published><updated>2018-02-09T00:00:00+08:00</updated><id>http://localhost:4000/2018/Understanding%20the%20Raft%20consensus%20algorithm-One</id><content type="html" xml:base="http://localhost:4000/2018/Understanding-the-Raft-consensus-algorithm-One/">&lt;p&gt;重新阅读了 Raft &lt;a href=&quot;https://raft.github.io/raft.pdf&quot;&gt;论文&lt;/a&gt;，结合 John Ousterhout 在斯坦福大学的课程&lt;a href=&quot;https://www.youtube.com/watch?v=YbZ3zDzDnrw&amp;amp;feature=youtu.be&quot;&gt;视频&lt;/a&gt;，对 Raft 重新梳理了一遍，并决定用文字记录下来。&lt;/p&gt;

&lt;p&gt;Raft 是一个共识算法，何为共识算法？通俗的说，共识算法的目的就是要实现分布式环境下各个节点上数据达成一致。那么节点的数据为什么会出现不一致？原因有很多，例如节点宕机、网络延迟、数据包乱序等等。但是要注意的是，Raft 并不考虑存在恶意的节点的情况，也就是说，不存在主动篡改数据的节点。所以可以理解为：允许节点宕机，但是只要节点没有宕机，那么它就是正常工作的。&lt;/p&gt;

&lt;h4 id=&quot;slide-1&quot;&gt;Slide 1&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.001.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 是为 Replicated Logs 设计的共识算法。一条日志对应于一个指令。可以这么理解：如果各个节点的日志在&lt;strong&gt;数量&lt;/strong&gt;和&lt;strong&gt;顺序&lt;/strong&gt;都达成一致，那么节点只需顺序执行日志，就能够得到一致的结果。注意，真正执行日志的是状态机（State Machine），Raft 协调的正是日志和状态机。&lt;/p&gt;

&lt;h4 id=&quot;slide-2&quot;&gt;Slide 2&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.002.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再次回顾 Replicated Log，Raft 需要实现将日志完全一致的复制到其他节点，进而创建多副本状态机（Replicated State Machine），状态机可以理解为一个&lt;strong&gt;确定&lt;/strong&gt;的应用程序，所谓确定是指只要是相同的输入，那么任何状态机都会计算出相同的输出。至于如何实现日志完全一致的复制，则是 Raft 即一致性模块（Consensus Module）需要做的事。&lt;/p&gt;

&lt;p&gt;重新思考，为什么需要在多个节点维护一份完全一致的日志？如果只有 1 个节点提供服务，那么它就会成为整个系统的瓶颈，如果这个节点崩溃了，服务也就不能提供了。所以很自然的，需要让多个节点能够提供服务，也就是说，如果提供服务的某个节点崩溃了，系统中其他节点依旧可以提供等价的服务，但是如何做到等价？这就需要系统中的节点维持一致的状态。注意，实际上并不需要所有的节点同时拥有一致的状态，只要大多数节点拥有即可。大多数指的是：如果一共存在 3 个节点，允许 1 个几点不能正常工作；如果一共有 5 个节点，允许 2 个节点不能正常工作。为什么是大多数？我们将通过接下来的 Slides 进一步理解。&lt;/p&gt;

&lt;h4 id=&quot;slide-3&quot;&gt;Slide 3&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.003.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;共识算法通常分为两类：对称式共识算法和非对称式共识算法。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对称式共识算法指网络中不存在中心节点 Leader，所有的节点都具有相同的地位，节点与节点之间通过互相通信来达成共识，即网络拓扑结构类似 P2P 网络。可想而知，对称式类的共识协议会非常复杂，但是性能会更好，因为网络中的节点可以同时提供服务。&lt;/li&gt;
  &lt;li&gt;非对称式共识算法会选举出一个 Leader，剩余的节点作为 Follower，客户端只能和 Leader 通信，节点之间的共识通过 Leader 来协调。相比于对称式共识算法，非对称式共识算法能够简化算法的设计，所有的操作都通过 Leader 完成，Follower 只需被动接受来自 Leader 的消息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Raft 是一种非对称的共识算法，也正是采用了非对称的设计，Raft 得以将整个共识过程分解：&lt;strong&gt;共识算法正常运行&lt;/strong&gt;和 &lt;strong&gt;Leader 变更&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;slide-4&quot;&gt;Slide 4&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.004.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 论文中多次强调 Raft 的设计是围绕算法的&lt;strong&gt;可理解性&lt;/strong&gt;展开，我们将从六个部分对 Raft 进行理解。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leader 选举，以及如何检测异常并进行新一轮的 Leader 选举。&lt;/li&gt;
  &lt;li&gt;基本的日志复制操作，也就是 Raft 正常运行是时的操作。&lt;/li&gt;
  &lt;li&gt;在 Leader 发生变更时如何保证安全性和一致性，这是 Raft 算法最关键的部分。&lt;/li&gt;
  &lt;li&gt;如何避免过时的 Leader 带来的影响，因为一个 Leader 宕机后再恢复仍然会认为自己是 Leader。&lt;/li&gt;
  &lt;li&gt;客户端交互，所谓实现线性化语义可以理解为实现幂等性。&lt;/li&gt;
  &lt;li&gt;配置变更，如何维持在线增删节点时的安全性和一致性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;slide-5&quot;&gt;Slide 5&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.005.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 算法有几个关键属性，我们需要提前了解。首先是节点的状态，相比于 Paxos，Raft 简化了节点可能的状态，在任何时候，节点可能处于以下三种状态。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Leader。Leader 负责处理客户端的请求，同时还需要协调日志的复制。在任意时刻，最多允许存在 1 个 Leader，也就是说，可能存在 0 个 Leader，什么时候会出现不存在 Leader 的情况？接下来会说明。&lt;/li&gt;
  &lt;li&gt;Follwer。在 Raft 中，Follower 是一个完全被动的角色，Follower 只会响应消息。注意，在 Raft 中，节点之间的通信是通过 RPC 进行的。&lt;/li&gt;
  &lt;li&gt;Candidate。Candidate 是节点从 Follower 转变为 Leader 的过渡状态。因为 Follower 是一个完全被动的状态，所以当需要重新选举时，Follower 需要将自己提升为 Candidate，然后发起选举。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Raft 正常运行时只有一个 Leader，剩下的均为 Follower。&lt;/p&gt;

&lt;p&gt;从状态转换图可以看到，所有的节点都是从 Follower 开始，如果 Follower 经过一段时间后收不到来自 Leader 的心跳，那么 Follower 就认为需要 Leader 已经崩溃了，需要进行新一轮的选举，因此 Follower 的状态变更为 Candidate。Candidate 有可能被选举为 Leader，也有可能回退为 Follower，具体情况下文会继续分析。如果 Leader 发现自己已经过时了，它会主动变更为 Follower，Leader 如何发现自己过时了？我们下文也会分析。&lt;/p&gt;

&lt;h4 id=&quot;slide-6&quot;&gt;Slide 6&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.006.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 的另一个关键属性是任期（Term），在分布式系统中，由于节点的物理时间戳都不统一，因此需要一个逻辑时间戳来表明事件发生的先后顺序，Term 正是起到了逻辑时间戳的作用。Raft 的运行过程被划分为一系列 Term，一次 Leader 选举会开启一个新的 Term。&lt;/p&gt;

&lt;p&gt;因为一次选举最多允许产生一个 Leader，一次选举又会开启一个新的 Term，所以每个 Leader 都会维护自己当前的 Term（Current Term）。注意，Leader 需要持久化存储 Current Term，当 Leader 宕机后再恢复，Leader 仍然会认为自己是 Leader，除非发现自己已经过时了，如何发现自己过时？依靠的正是 Current Term  的值。&lt;/p&gt;

&lt;p&gt;一次 Term 也可能选不出 Leader，这是因为各个 Candidate 都获得了相同数量的选票，具体细节下文会再阐述。目前我们需要知道的是 Term 在 Raft 中是一个非常关键的属性，Term 始终保持单调递增，而 Raft 认为一个节点的 Term 越大，那么它所拥有的日志就越准确。&lt;/p&gt;

&lt;h4 id=&quot;slide-7&quot;&gt;Slide 7&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.007.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，Raft 有需要持久化存储的状态，包括 Current Term、VotedFor（下文会解析）和日志。每个日志项结构非常简单，包括日志所在 Term、Index 和状态机需要执行的指令。节点之间的 RPC 消息分为两类，一类为选举时的消息，另一类为 Raft 正常运行时的消息。具体细节我们会在下文理解。&lt;/p&gt;

&lt;h4 id=&quot;slide-8&quot;&gt;Slide 8&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.008.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Raft 中 Leader 和 Follower 之间需要通过心跳消息来维持关系，Follower 一旦在 Election Timeout 后没有收到来自 Leader 的心跳消息，那么 Follower 就认为 Leader 已经崩溃了，于是就发起一轮新的选举。在 Raft 中，心跳消息复用日志复制消息 AppendEntries 数据结构，只不过不携带任何日志。&lt;/p&gt;

&lt;h4 id=&quot;slide-9&quot;&gt;Slide 9&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.009.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在开始正式理解 Raft 的选举过程，大部分内容已有所介绍，我们再梳理一遍。&lt;/p&gt;

&lt;p&gt;当新的一轮选举开始时，Follower 首先要自增当前 Term，代表进入新的任期，紧接着变更状态为 Candidate，每个 Candidate 会先给自己投上一票，然后通过发送 RequestVote RPC 消息呼吁其他节点给自己投票。选举结果存在三种可能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Candidate 收到了大多数节点的投票，那么 Candidate 自然就成为 Leader，然后马上发送心跳消息维护自己的 Leader 地位，并对外提供服务。&lt;/li&gt;
  &lt;li&gt;Candidate 在等待来自其他节点的选票的过程中收到了来自 Leader 的心跳消息，Candidate 可以看到当前的心跳消息中包含更新的 Term，就会意识到新的 Leader 已经被选举出来，于是就自降为 Follower。&lt;/li&gt;
  &lt;li&gt;各个 Candidate 都获得了相同数量的选票，那么每个节点都会继续等待选票，没有新的 Leader 产生。等待一定的时间后，重新开启选举过程，知道选出新的 Leader。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要考虑的是 Raft 如何避免重复出现 Candidate 瓜分选票的情况：如果当前轮选举 Candidate 瓜分了选票，那么Candidate 会进入下一轮的选举，但是各个 Candidate 开始选举的时刻是随机的。&lt;/p&gt;

&lt;h4 id=&quot;slide-10&quot;&gt;Slide 10&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/raft.010.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;继续理解选举过程，选举过程需要保证两个特性：Safety 和 Liveness。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Safety 要求每个 Term 最多只能选举出一个 Leader，Raft 约束每个节点除了能给自己投一票，也只能给其他节点投一票。因此，如果 Candidate A 已经获得了大多数选票，由于每个节点只能向外投一票，因此 Candidate B 不可能获得大多数选票。Safety 特性保证一段时间内只可能存在一个 Leader 提供服务并协调日志的复制，避免因为存在多个 Leader 导致日志不一致。&lt;/li&gt;
  &lt;li&gt;Safety 要求一段时间内最多只能存在一个 Leader，而 Liveness 保证系统最终必须要有要有一个 Candidate 赢得选举成为 Leader，Leader 无法选举出来意味着系统不能对外提供服务。Raft 实现 Liveness 的方式很简单，在 Slide 9 已经提及：当某一轮选举 Candidate 瓜分了选票，那么各个节点进入下一轮选举等待的时间是随机的，Candidate 随机等待 [T, 2T]， T 为选举超时时间，这样就大大减少了再次瓜分选票的概率。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;p&gt;对 Raft Leader 选举过程的理解基本结束，Raft 为了提高算法的可理解性，将问题分解，我们接下来会继续理解 Raft 的剩余部分。&lt;/p&gt;</content><author><name></name></author><summary type="html">重新阅读了 Raft 论文，结合 John Ousterhout 在斯坦福大学的课程视频，对 Raft 重新梳理了一遍，并决定用文字记录下来。</summary></entry><entry><title type="html">2017年度总结与2018年度计划</title><link href="http://localhost:4000/2017/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8E2018%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/" rel="alternate" type="text/html" title="2017年度总结与2018年度计划" /><published>2017-12-31T00:00:00+08:00</published><updated>2017-12-31T00:00:00+08:00</updated><id>http://localhost:4000/2017/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8E2018%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92</id><content type="html" xml:base="http://localhost:4000/2017/2017%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E4%B8%8E2018%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/">&lt;p&gt;今年事情比较多，重要的事情有两件，一是还有 6 个月就要毕业，这意味着留给我在学校里纯粹打磨技术的时间已经不多了；二是确定了自己的职业生涯将会从阿里开始，这意味着什么我暂时还不确定。去年此时，我认为自己一定会去试水一大堆公司，但是实际上我只投了寥寥几个，整个过程比我预想的要顺利，我想究其原因自然离不开这几年几乎不间断的积累，但是也有运气的成分在。&lt;/p&gt;

&lt;p&gt;上半年读了不少 paper 和技术书籍。在阅读的过程中，我喜欢在学习到一个新的知识点后，尽可能的通过一段程序去验证，那么理解的程度很可能会从「 意会」变成「 感同身受」。因此，当我在若干次阅读 JVM 虚拟机规范时都被冗长的 Class 文件格式搞得想困觉时，我做出了一个决定：自己编程实现 Class 文件的解析，这也是 &lt;a href=&quot;https://github.com/tinylcy/ClassAnalyzer&quot;&gt;ClassAnalyzer&lt;/a&gt; 诞生的原因。写完 ClassAnalyzer 后，春节结束，我便动身回到了学校。&lt;/p&gt;

&lt;p&gt;回学校不久，一位我曾经联系过的淘宝工程师（其实是技术专家）给我打了电话，不过当时时间尚早，阿里的实习生招聘工作并未开始，我们聊了一会儿并互加了微信。其实，当时和我期望最匹配的是阿里中间件、阿里云或者腾讯 TEG，对别的公司或团队我并不感冒。我咨询了曾在阿里实习的师姐，她很强烈的向我推荐了菜鸟网络，「 做网络也 OK，我对计算机网络也挺感兴趣的」，我当时想。于是我便内推了菜鸟网络，几天后，我得知菜鸟网络做的原来是「物流网络」，而不是「计算机网络」……当然这是后话了。另外，我还内推了腾讯 TEG、美团基础架构部、网易游戏、华为和今日头条。&lt;/p&gt;

&lt;p&gt;二月底，我收到了网易游戏的电话面试邀请，一面面试官和我聊得非常投机，我们交流了许多并发和 JVM 相关的内容，最后意犹未尽的挂了电话。晚上我收到了杭州现场面试的邀请，但是时间极其仓促，我人在广州，极有可能无法准时参加面试，我询问 HR 能否把我安排在下一轮面试，HR 遂给我安排了两轮电话面试，我也欣然接受。于是现场面试当天，我在宿舍面了两轮电话面试，聊了一些项目，但是面试官并没有问到点上，两轮面试体验总体感觉一般。那天是周五，周末估计员工不加班，周末过后，第四轮面试如约而至，面试官和我聊了一些基础且常规的话题，这些话题其实任何面试者都能说上几句，但是如果要回答的让面试官和我自己满意，我认为需要有感同身受的理解，这正是我擅长的。又过了一天，我便收到了第一个实习 offer。&lt;/p&gt;

&lt;p&gt;腾讯 TEG 的现场面试效率颇高，一天就可以完成所有的技术面试。相比于其他公司，腾讯给我的感觉是面试官更加关注面试者对底层知识的理解。我的第一轮面试持续了近 80 分钟，其中前 10 分钟做了一道算法题，我写了一些伪代码，后 70 分钟重点针对虚拟内存（尤其是 &lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap&lt;/a&gt; 系统调用）进行了较为深入的探讨。我认为这一轮面试是我生涯为数不多的面试中最纯粹、最享受的一轮面试，不仅暴露出我的知识体系中的不少漏洞，也大大增加了我对 TEG 的好感度。二面面试官和我聊了做技术的态度以及人生，他觉得我应该更加 open 一些，我认可他的说法，在遇到问题时，有时候换个思路，从业务的角度，而非技术的角度去解决，或许能达到事半功倍的效果。&lt;/p&gt;

&lt;p&gt;都是同行的承托，阿里的面试效率低到让我累觉不爱，五轮面试，持续了近两个月。并且，令人吃惊的是，我已然不记得五轮面试都问了我些什么……&lt;/p&gt;

&lt;p&gt;回顾三月和四月，我的状态比较不错，除了需要应对某些突如其来的面试，我仍然保持着读 paper 和看书以及 coding 的习惯。&lt;/p&gt;

&lt;p&gt;当需要决定去哪儿实习时，我致电了几个好友，TA 们倾向于我选择腾讯，理由从本文第三至六段也能看出个大概。然而我选择了去阿里实习，我想，既然是实习，那就意味着有试错的机会，待我前去一探究竟，到时候再投奔他家不迟。我便接受了阿里的实习 offer，并通过邮件或电话的方式真诚的婉拒了其他公司。&lt;/p&gt;

&lt;p&gt;五月，我依旧进行着我的常规操作，期间参加了阿里安排的入职体检。但是，俗话说的好，「天有不测风云，人有旦夕祸福」，我没有通过入职体检，理由是我的心脏伴有一定程度的室性早搏。恰逢今年又是我的本命年，而本命禁忌，在民间有着广泛的影响。在南北民俗中，都有在本命年挂红避邪躲灾的传统。因此人们每逢本命年对红色就特别钟爱。在大年三十，人们便会穿上红色内衣，来迎接自己的本命年，认为这样才能趋吉避凶，消灾免祸。显然，对于穿红色内衣，我是拒绝的。&lt;/p&gt;

&lt;p&gt;实际上，当时我还是不以为然并怀揣侥幸心理，认为只是需要一个三甲医院的确认，然后拟定个治疗方案就可以了。但是，当广东省中医院主任医师盛小刚告知我「你都没必要吃药，直接手术吧」的时候，我非常沮丧，理由有三，一是按照医生的说法，我的身体似乎不能支持我在未来进行高强度的研发工作及剧烈运动；二是不论接不接受手术，我基本是错过实习了；三是如果我接受了手术，并且手术恢复周期太长，那么我很可能会错过校园招聘。&lt;/p&gt;

&lt;p&gt;和父母沟通之后，我迅速回到杭州，并选择在浙江大学附属第二医院进行心脏射频消融术治疗，射频消融术是将电极导管经静脉或动脉血管送入心腔特定部位，释放射频电流导致局部心内膜及心内膜下心肌凝固性坏死，达到阻断快速心律失常异常传导束和起源点的介入性技术。医生告诉我，手术本身是一个微创手术，但是这并不意味着没有风险，具体差异在于病人本身。从住院开始，我就希望赶快手术，手术带给我的痛苦相比于我当时的沮丧可以忽略不计。如我所愿，公元 2017 年 5 月 27 日，在端午节放假前一天的下午，我被一个陌生中年男子推进了手术室。&lt;/p&gt;

&lt;p&gt;我的主刀医生有两位，其中一位似乎是印度人。我躺在冷冰冰的手术台上，护士们和助手们在进行术前准备，他们查阅了我的病历，看起来我的手术对于他们来说已经是轻车熟路了，他们谈笑风生，有条不紊，氛围轻松，手术室里充满了法定节假日前的喜悦气氛。然后手术就开始了，好在没有辜负我的期望，手术进行的很顺利。&lt;/p&gt;

&lt;p&gt;回顾那段时间，毫无疑问我最需要感谢的是人我的父母，我的生病让他们无比焦虑和痛苦，这其实非常折磨我，他们为了我真的可以付出任何代价，这点我已经感同身受了；感谢前来看望我的长辈们和兄弟姐妹们；感谢我的朋友们，你们的远程持续鼓励让我在医院元气满满；感谢我的主管给我打电话并告知已为我保留一个实习岗位，这着实给我吃了一颗速效定心丸。&lt;/p&gt;

&lt;p&gt;住院的这段时间，我完成了之前没有完成的 &lt;a href=&quot;https://book.douban.com/subject/1139336/&quot;&gt;The C Programming Language&lt;/a&gt; 编程习题。&lt;/p&gt;

&lt;p&gt;六月出了院，在家修养了两周后，我便决定返回学校。在家父母能够把我照顾的很周全，但是我仍觉得有些无所事事。现在想想，我错了，我应该安静的进行术后恢复，并且我的提早出走导致他们担心。七月初，HR 正式确定了我的实习报道时间，我再次回到杭州，为期不长的实习就这样开始了。&lt;/p&gt;

&lt;p&gt;和往年一致，阿里会给予每个实习生一个转正答辩的机会，转正答辩通过即意味着能够成为正式员工，这对绝大部分实习生来说还是很有诱惑力的。相比于其他实习生，我的实习起始时间已经滞后了许多，以至于在入职后师兄带着我去领笔记本时，已经没有多余的 MacBook Pro 分配给我，只能退而求其次用 ThinkPad……同时，这意味着我需要投入更多的时间和精力，于是我租了一个距离公司只有 13 分钟步行时间的房间。&lt;/p&gt;

&lt;p&gt;实习前两周，我的所有时间用于熟悉大名鼎鼎的阿里中间件，并阅读了 Webx 和 MetaQ 的部分源码。期间，师兄们给了我各种资源，让我尽可能快的理解复杂的业务逻辑。师兄们觉得通过代码理解业务是更高效的方式，于是给我分配了一个小需求，我花了一个周末完成。第三周伊始，团队启动了一个核心平台项目，对实习生而言，能够有机会参与到这类项目其实是不错的经历。&lt;/p&gt;

&lt;p&gt;众所周知，长期以来我打心眼儿里排斥「业务系统」的开发，觉得它没有技术含量，每天还要浪费很多时间讨论业务……对我而言，最能激发我多巴胺分泌的一直都是类似「基础架构」、「性能优化」等名词。不过，实习时我的想法有了转变，技术的诞生应该服务于社会，应该用于解决实际的问题。实际问题总是在不断发生着演化，这意味着如何把业务系统设计的可伸缩和可扩展将会变得至关重要。同时，如何保证在海量用户下系统的高可用、高性能和一致性也是极具挑战性的问题。&lt;/p&gt;

&lt;p&gt;转变归转变，问题也接踵而来，由于我对业务的生疏，每天我都需要花费大量的时间用于梳理业务逻辑，尽管师兄们对我始终是有问必答，但是他们的答复对我而言却始终是雾里看花，这让我很绝望，我没有办法写出让我自己信服的程序。不过我还是坚持了下来，尽我所能写出考虑完备的程序，业务逻辑不对的地方，测试工程师给我指出来，我改就是了。&lt;/p&gt;

&lt;p&gt;值得一提的是实习期间我参加了集团内部的百技培训和菜鸟内部的破壳班，见识了不少杰出科学家和顶尖工程师，认识了许多特别优秀的同学。另外，我还参加了为期两天黑客马拉松，那是我实习期间最开心的两天。&lt;/p&gt;

&lt;p&gt;临近转正答辩，我向主管、师兄们以及 HR 表露了我的想法：我决定放弃转正答辩的机会，因为我认为实习期间我并没有很好的完成我的工作，这让我对自己感到不满意。现在回头看看，我当时真是在自挂东南枝……多亏我的 HR，一个极具人格魅力的中年大叔，很容易就把我自认为发育的很成熟的想法给扼杀了，我乖乖的熬了一个通宵做了 PPT 参加了转正答辩。答辩过程轻松愉快，我很快就得知我将会获得正式的 offer，最终我也接受了 offer。&lt;/p&gt;

&lt;p&gt;九月初，办理完实习离职手续后我马不停蹄回到学校，这学期学院邀请了 &lt;a href=&quot;https://scholar.google.co.uk/citations?user=W-IMms4AAAAJ&amp;amp;hl=en&quot;&gt;David Walker&lt;/a&gt; 教授给学生们讲授高性能计算课程，David Walker 是并行计算领域的资深专家，而我有幸可以成为该课程的助教。尽管以我目前的知识储备还无法和教授进行深入的学术探讨，但是教授却给了我不少建设性的建议。 九月底送别教授回国后，我便动身前往北京。去北京的主要目的是想约几个好友聊聊天，几年不见，久违而又熟悉，好友们的招待可以说是无微不至，甚至让我有些不好意思，但真是高兴！当然，最令我骄傲的是他们都在各自的领域取得了不俗的成绩：有已在职场风生水起的，有手握多个 offer 不知如何选择的，有继续深造投身科研的……在北京待了一周后，我回到了家，和父母一起度过了中秋节，然后回到学校，班长通知我获得了今年的国家奖学金。&lt;/p&gt;

&lt;p&gt;十月，我完成了 Andrew Ng 在 Coursera 开设的 &lt;a href=&quot;https://www.coursera.org/learn/machine-learning/home/welcome&quot;&gt;Machine Learning&lt;/a&gt; 课程及对应的 Labs。我为什么要去学这门课程？尽管目前人工智能仍处于并将长期处于「弱人工智能」阶段，离真正的「人工智能」相去甚远，但是不可否认的是人工智能正在影响我们的生活，尤其是在图像识别、语音识别、文字识别等领域，人工智能算法的准确度之高，令传统算法难以望其项背。除此之外，实习时我发现公司目前正需要具备出色工程能力且懂算法的研发工程师，或者是对算法有深入理解同时还能把算法落地的算法工程师，未来我希望能有机会参与数据驱动的项目。&lt;/p&gt;

&lt;p&gt;十一月，我重构了 2016 年造的轮子 &lt;a href=&quot;https://github.com/tinylcy/vino&quot;&gt;Vino&lt;/a&gt;。Vino 旨在实现一个轻量并且能够保证性能的 Web Server，仅关注 Web Server 的本质部分。在重构过程中，我阅读了不少优秀开源项目的相关源码，包括 Nginx、Mongoose 、Redis 和 WebBench，Vino 许多模块的思想正是借鉴于他们。因此，对比上一个版本的 Vino，现在的 Vino 不仅性能得到提升，而且设计也更为优雅、健壮。另外，挺有意思的是，Vino 还屡次登上 GitHub Trending（C 语言类），这直接导致长年不发微信朋友圈的我发布了一条状态，顺便学会了如何发布仅含文字不配图片的状态……期间也有高中同学来广州出差顺便小聚，朋友之间交流近况很有意义，高中毕业至今 7 年，在一起还能说说知心话，很窝心。&lt;/p&gt;

&lt;p&gt;十二月，我没有目的性的尝试了一些新技术。我对异步编程感兴趣，所以开始了对 Node.js 的学习。同时，我开始了对区块链技术的研究，并且我将会对区块链技术进行一定深度的挖掘……十二月，我又回到了读 paper、看书和 coding 的时光。&lt;/p&gt;

&lt;p&gt;过往的事情能够给我不少启示。2018 年我将开启职业生涯，这让我有些担忧：一心扑在技术上专研打磨的日子很有可能一去不复返，充斥生活的变成无穷无尽的需求、支持和维护，还要加上现实琐事的拖累。如何克服这个问题？我认为最重要的是保持对编程的热情。也许我会不可避免的遇到业务问题，但是如何透过业务看清其后本质的技术问题？这将是需要我长期思考的一个问题。&lt;/p&gt;

&lt;p&gt;回顾 &lt;a href=&quot;http://tinylcy.me/2017/2016%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E5%8F%8A2017%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/&quot;&gt;2016年度总结与2017年度计划&lt;/a&gt;，除了身体机能上的锻炼，我基本完成了年初给自己设定的目标。关于锻炼，我心里是有罪恶感的。不过，无例外的是，我还是会大言不惭的把「锻炼身体」列为新年计划中的重要组成部分之一。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2018 上半年的绝大部分时间我仍然会在学校度过，对我而言，这半年的主题将会是「毕业设计」，具体内容暂不透露。&lt;/li&gt;
  &lt;li&gt;MIT &lt;a href=&quot;https://pdos.csail.mit.edu/6.828/2017/&quot;&gt;6.828: Operating System Engineering&lt;/a&gt;，这门课程主要讲的是操作系统原理与实践，与其他操作系统课程不同的是，6.828 的实践部分比重非常大，对应的编程练习能够帮助我非常清晰的理解操作系统的相关概念，并最终实现一个真正意义上的操作系统。&lt;/li&gt;
  &lt;li&gt;不出意外的话，2018 年 7 月，我将再次回到那个熟悉的团队，首要任务是做好自己的本职工作，尽快的熟悉团队正在使用的技术，哪怕是我不喜欢的老技术。我相信「工作对我而言不再是追逐一个梦想和追求一段经历了」这一天总会到来，但不是现在。&lt;/li&gt;
  &lt;li&gt;抽空锻炼身体，希望新的一年能有所改善。&lt;/li&gt;
  &lt;li&gt;做一次志愿者。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Always be prepared！&lt;/p&gt;</content><author><name></name></author><summary type="html">今年事情比较多，重要的事情有两件，一是还有 6 个月就要毕业，这意味着留给我在学校里纯粹打磨技术的时间已经不多了；二是确定了自己的职业生涯将会从阿里开始，这意味着什么我暂时还不确定。去年此时，我认为自己一定会去试水一大堆公司，但是实际上我只投了寥寥几个，整个过程比我预想的要顺利，我想究其原因自然离不开这几年几乎不间断的积累，但是也有运气的成分在。</summary></entry><entry><title type="html">如何实现一个Web Server</title><link href="http://localhost:4000/2017/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb-Server/" rel="alternate" type="text/html" title="如何实现一个Web Server" /><published>2017-12-09T06:08:34+08:00</published><updated>2017-12-09T06:08:34+08:00</updated><id>http://localhost:4000/2017/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb-Server</id><content type="html" xml:base="http://localhost:4000/2017/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWeb-Server/">&lt;p&gt;最近重构了去年造的一个轮子 &lt;a href=&quot;https://github.com/tinylcy/vino&quot;&gt;Vino&lt;/a&gt;。Vino 旨在实现一个轻量并且能够保证性能的 Web Server，仅关注 Web Server 的本质部分。在重构过程中，Vino 借鉴了许多优秀开源项目的思想，如 Nginx、Mongoose 和 Webbench。因此，对比上一个版本的 Vino，现在的 Vino 不仅性能得到提升，而且设计也更为优雅、健壮 :D。&lt;/p&gt;

&lt;p&gt;本文将会对 Vino 目前所具备的关键特性进行阐述，并总结开发过程中的一点心得。&lt;/p&gt;

&lt;h2 id=&quot;单线程--non-blocking&quot;&gt;单线程 + Non-Blocking&lt;/h2&gt;

&lt;p&gt;Vino 整体采用了基于事件驱动的单线程 + Non-Blocking 模型。采用单线程模型，避免了系统分配多线程及线程之间通信的开销，同时降低了内存的耗用。由于采用了单线程模型，为了更好的提高线程利用率，Vino 将默认 Blocking 的 I/O 设置为 Non-Blocking I/O，即在线程读/写数据的过程中，如果缓冲区为空/缓冲区满，线程不会阻塞，而是立即返回，并设置 errno。&lt;/p&gt;

&lt;p&gt;Vino 最初的灵感来源于 &lt;a href=&quot;http://csapp.cs.cmu.edu/&quot;&gt;Computer Systems: A Programmer’s Perspective&lt;/a&gt; 一书讲述网络编程时实现的一个简单的 &lt;a href=&quot;http://csapp.cs.cmu.edu/2e/ics2/code/netp/tiny/tiny.c&quot;&gt;Web Server&lt;/a&gt;，每到来一个请求，Web Server 都会 fork 一个进程去处理。显然，在高并发的场景下，这种模型是不合理的。每次 fork 进程会带来巨大的开销，并且系统中进程的数量是有限的。同时，伴随多进程带来的进程调度的开销也不可小觑，CPU 会花费大量的时间用于决定调用哪一个进程。进程调度引发的进程上下文之间的切换，也需要耗费相当大的资源。&lt;/p&gt;

&lt;p&gt;很容易联想到采用多线程模型来替代多进程模型，相比于多进程模型，多线程模型占用的系统资源会大大降低，但是本质上并没有减小线程调度带来的开销。为了减小由线程调度导致的开销，我们可以采用线程池模型，即固定线程的数量，但是问题依旧存在：因为 Linux 默认 I/O 是阻塞（Blocking）的，如果线程池中所有的线程同时阻塞于正在处理的请求，那么新到来的请求就没有线程去处理了。因此，如果我们用 Non-Blocking 的 I/O 替换默认的 Blocking I/O，线程将不会阻塞于数据的读写，问题便可得到解决。&lt;/p&gt;

&lt;h2 id=&quot;http-keep-alive&quot;&gt;HTTP Keep-Alive&lt;/h2&gt;

&lt;p&gt;Vino 支持 HTTP 长连接（Persistent Connections），即多个请求可以复用同一个 TCP 连接，以此减少由 TCP 建立/断开连接所带来的性能开销。每到来一个请求，Vino 会对请求进行解析，判断请求头中是否存在 Connection: keep-alive 请求头。如果存在，在处理完一个请求后会保持连接，并对数据缓冲区（用于保存请求内容，响应内容）及状态标记进行重置，否则，关闭连接。&lt;/p&gt;

&lt;p&gt;关于 HTTP Keep-Alive 的优势，&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 有着更完善的总结，引用如下。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;By opening and closing fewer TCP connections, CPU time is saved in routers and hosts (clients, servers, proxies, gateways, tunnels, or caches), and memory used for TCP protocol control blocks can be saved in hosts.&lt;/li&gt;
    &lt;li&gt;HTTP requests and responses can be pipelined on a connection. Pipelining allows a client to make multiple requests without waiting for each response, allowing a single TCP connection to be used much more efficiently, with much lower elapsed time.&lt;/li&gt;
    &lt;li&gt;Network congestion is reduced by reducing the number of packets caused by TCP opens, and by allowing TCP sufficient time to determine the congestion state of the network.&lt;/li&gt;
    &lt;li&gt;Latency on subsequent requests is reduced since there is no time spent in TCP’s connection opening handshake.&lt;/li&gt;
    &lt;li&gt;HTTP can evolve more gracefully, since errors can be reported without the penalty of closing the TCP connection. Clients using future versions of HTTP might optimistically try a new feature, but if communicating with an older server, retry with old semantics after an error is reported.&lt;/li&gt;
  &lt;/ul&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;定时器-timer&quot;&gt;定时器 Timer&lt;/h2&gt;

&lt;p&gt;如果一个请求在建立连接后迟迟没有发送数据，或者对方突然断电，应该如何处理？我们需要实现定时器来处理超时的请求。Vino 定时器的实现参考了 Nginx 的设计，Nginx 使用一颗红黑树来存储各个定时事件，每次事件循环时从红黑树中不断找出最小（早）的事件，如果超时则触发超时处理。为了简化实现，在 Vino 中，我实现了一个小顶堆来存储定时事件，如果被处理的定时事件同时支持长连接，那么在该请求处理完毕后会更新该请求对应的定时器，也就是重新计时。定时器相关代码见 &lt;a href=&quot;https://github.com/tinylcy/vino/blob/master/src/vn_event_timer.h&quot;&gt;vn_event_timer.h&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/tinylcy/vino/blob/master/src/vn_event_timer.c&quot;&gt;vn_event_timer.c&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;http-parser&quot;&gt;HTTP Parser&lt;/h2&gt;

&lt;p&gt;由于网络的不确定性，我们并不能保证一次就能读取所有的请求数据。因此，对于每一个请求，我们都会开辟一段缓冲区用于保存已经读取到的数据。同时，我们需要同时对读取到的数据进行解析，以保证读取到的数据都是合理的数据，例如，假设目前缓冲区内的数据为 GET /index.html HTT，那么下一次读取到的字符必须为 P，否则，应立即检测出当前请求是一个异常的请求，并主动关闭当前的连接。&lt;/p&gt;

&lt;p&gt;基于以上分析，我们需要实现一个 HTTP 状态机（Parser）来维持当前的解析状态，Vino 状态机的实现参考了 Nginx 的设计，并对 Nginx 的实现做了简化。HTTP Parser 相关代码见 &lt;a href=&quot;https://github.com/tinylcy/vino/blob/master/src/vn_http_parse.h&quot;&gt;vn_http_parse.h&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/tinylcy/vino/blob/master/src/vn_http_parse.c&quot;&gt;vn_http_parse.c&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;memory-pool&quot;&gt;Memory Pool&lt;/h2&gt;

&lt;p&gt;我们一般使用 malloc/calloc/free 来分配/释放内存，但是这些函数对于一些需要长时间运行的程序来说会有一些弊端。频繁使用这些函数分配和释放内存，会导致内存碎片，不容易让系统直接回收内存。典型的例子就是大并发频繁分配和回收内存，会导致进程的内存产生碎片，并且不会立马被系统回收。&lt;/p&gt;

&lt;p&gt;使用内存池分配内存，可以在一定程度上提升内存分配的效率，不需要每次都调用  malloc/calloc 函数。同时，使用内存池使得内存管理更加简单。在 Vino 中，针对每一个请求，Vino 都会为其分配一或多个内存池（各个内存池形成一个单链表），在请求处理完毕后，一并释放所有的内存。&lt;/p&gt;

&lt;p&gt;Vino 内存池的实现依旧参考了 Nginx 的实现，并做了简化，Memory Pool 相关代码见 &lt;a href=&quot;https://github.com/tinylcy/vino/blob/master/src/vn_palloc.h&quot;&gt;vn_palloc.h&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/tinylcy/vino/blob/master/src/vn_palloc.c&quot;&gt;vn_palloc.c&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;在开发 Vino 的过程中，还有许多需要考虑和权衡的地方。响应请求时，如果用户请求的是一个很大的文件，导致写缓冲区满，我们如何更好的设计响应缓冲区？如何更高效的设计底层数据结构（如字符串、链表、小顶堆等）？如何更优雅的解析命令行参数？如何对特定信号进行处理？如何更健壮的处理错误信息？当代码的数量达到一定程度后，如何更快的定位异常代码？&lt;/p&gt;

&lt;p&gt;Vino 的开发 &amp;amp; 重构暂时告一段落，源码放在了 &lt;a href=&quot;https://github.com/tinylcy/vino&quot;&gt;GitHub&lt;/a&gt; 上。当然，Vino 还有许多不足之处，以及未实现的特性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅支持 HTTP GET 方法，暂不支持其他 HTTP method。&lt;/li&gt;
  &lt;li&gt;暂不支持动态请求的处理。&lt;/li&gt;
  &lt;li&gt;支持的 HTTP/1.1 特性有限。&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写这篇文章，希望对初学者有所帮助。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;[1] Vino, &lt;a href=&quot;https://github.com/tinylcy/vino&quot;&gt;https://github.com/tinylcy/vino&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[2] Computer Systems: A Programmer’s Perspective, &lt;a href=&quot;http://csapp.cs.cmu.edu/&quot;&gt;http://csapp.cs.cmu.edu&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[3] Advanced Programming in the UNIX Environment (3rd Edition), &lt;a href=&quot;https://www.amazon.ca/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739&quot;&gt;https://www.amazon.ca/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[4] Unix Network Programming, Volume 1, &lt;a href=&quot;https://www.amazon.ca/Unix-Network-Programming-Sockets-Networking/dp/0131411551&quot;&gt;https://www.amazon.ca/Unix-Network-Programming-Sockets-Networking/dp/0131411551&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[5] Nginx, &lt;a href=&quot;https://github.com/nginx/nginx&quot;&gt;https://github.com/nginx/nginx&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[6] Mongoose, &lt;a href=&quot;https://github.com/cesanta/mongoose&quot;&gt;https://github.com/cesanta/mongoose&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[7] Web Bench, &lt;a href=&quot;http://home.tiscali.cz/~cz210552/webbench.html&quot;&gt;http://home.tiscali.cz/~cz210552/webbench.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[8] Zaver, &lt;a href=&quot;https://github.com/zyearn/zaver&quot;&gt;https://github.com/zyearn/zaver&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[9] RFC 2616, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;https://tools.ietf.org/html/rfc2616&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;[10] How to use epoll? A complete example in C, &lt;a href=&quot;https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c/&quot;&gt;https://banu.com/blog/2/how-to-use-epoll-a-complete-example-in-c&lt;/a&gt; .&lt;/p&gt;</content><author><name></name></author><category term="Unix/Linux" /><category term="C" /><summary type="html">最近重构了去年造的一个轮子 Vino。Vino 旨在实现一个轻量并且能够保证性能的 Web Server，仅关注 Web Server 的本质部分。在重构过程中，Vino 借鉴了许多优秀开源项目的思想，如 Nginx、Mongoose 和 Webbench。因此，对比上一个版本的 Vino，现在的 Vino 不仅性能得到提升，而且设计也更为优雅、健壮 :D。</summary></entry><entry><title type="html">CUDA Lab: Sum of Squares &amp;amp; Matrix Multiplication</title><link href="http://localhost:4000/2017/CUDA-Lab-Sum-of-Squares-Matrix-Multiplication/" rel="alternate" type="text/html" title="CUDA Lab: Sum of Squares &amp; Matrix Multiplication" /><published>2017-10-17T05:24:12+08:00</published><updated>2017-10-17T05:24:12+08:00</updated><id>http://localhost:4000/2017/CUDA-Lab-Sum-of-Squares-Matrix-Multiplication</id><content type="html" xml:base="http://localhost:4000/2017/CUDA-Lab-Sum-of-Squares-Matrix-Multiplication/">&lt;p&gt;CUDA（Compute Unified Device Architecture）是显卡厂商 NVIDIA 推出的运算平台，是一种通用的并行计算架构，该架构使 GPU 能够解决复杂的计算问题。我们可以使用 GPU 来并行例如神经网络、图像处理等在 CPU 上运行起来比较耗时的程序，通过 GPU 并行计算可以大大提高算法的运行速度。&lt;/p&gt;

&lt;p&gt;本实验包含两部分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一部分（Sum of Squares）：计算数组元素的平方和，并通过不断的优化来提高程序的性能，以此来学习和理解 CUDA 编程需要注意之处。&lt;/li&gt;
  &lt;li&gt;第二部分（Matrix Multiplication）：利用 CUDA 实现矩阵乘法并行化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cuda安装&quot;&gt;CUDA安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Visual Studio 2015 Community &lt;a href=&quot;https://www.visualstudio.com/zh-hans/vs/older-downloads/&quot;&gt;Download&lt;/a&gt;，CUDA Tookit 与 Visual Studio 2017 Community 暂不兼容。&lt;/li&gt;
  &lt;li&gt;CUDA Tookit &lt;a href=&quot;https://developer.nvidia.com/cuda-downloads&quot;&gt;Download&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下载 CUDA Tookit 时选择相应的操作系统及版本等平台参数。例如，在 Win10 下进行实验，参数选择如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：应先安装 Visual Studio 再安装 CUDA Tookit，因为在安装 CUDA Tookit 时会自动配置 CUDA for Visual Studio，CUDA Tookit 安装成功后可以在 Visual Studio 中创建 CUDA Project。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cpu--gpu&quot;&gt;CPU &amp;amp; GPU&lt;/h3&gt;

&lt;p&gt;下图为 CPU 和 GPU 的对比图，相比于 CPU，GPU 更加适用于计算强度高，多并行的计算中。GPU 拥有更多的晶体管，而不是数据 Cache 和控制器，这样设计的意图是在并行计算过程中，每个数据单元经常执行相同的程序，不需要繁琐的复杂流程控制和 Cache，而更需要强大的计算能力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用 GPU 来进行运算工作，和使用 CPU 相比，主要有以下优势。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GPU 通常具有更大的内存带宽。例如，NVIDIA 的 GeForce 8800GTX 具有超过 50GB/s 的内存带宽，而目前高阶 CPU 的内存带宽则在 10GB/s 左右。&lt;/li&gt;
  &lt;li&gt;GPU 具有更大量的执行单元。例如 GeForce 8800GTX 具有 128 个 “stream processors”，频率为 1.35GHz。CPU 频率通常较高，但是执行单元的数目则要少得多。&lt;/li&gt;
  &lt;li&gt;和高阶 CPU 相比，GPU 的价格较为低廉。例如目前一张 GeForce 8800GT 包括 512MB 内存的价格，和一颗 2.4GHz 四核心 CPU 的价格相当。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cuda架构&quot;&gt;CUDA架构&lt;/h3&gt;

&lt;p&gt;在 CUDA 架构下，一个程序被划分为两个部分：Host 端和 Device 端。Host 端是指运行在 CPU 的部分，而 Device 端则是在 GPU 上运行的部分，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在程序执行过程中，通常 Host 端程序会将数据在主内存中准备好并复制到显存，再由 GPU 执行 Device 端程序，完成后由 Host 端程序将结果从显存拷贝至主内存。由于 CPU 存取显存时只能通过 PCI Express 接口，因此速度较慢（PCI Express x16 的理论带宽是双向各 4 GB/s），因此不能太频繁的执行这类操作，以免降低效率。&lt;/p&gt;

&lt;p&gt;在 CUDA  架构下，GPU 执行时的最小单元是 Thread，数个 Thread 可以组成一个 Block ，&lt;strong&gt;一个 Block 中的 Thread 能够存取同一块共享的内存，而且可以快速进行同步操作&lt;/strong&gt;。每一个 Block 所能包含的 Thread 数目是有限的，但是执行相同程序的 Block 可以组成 Grid。不同 Block 中的 Thread 无法存取同一个共享内存，因此无法进行通信和同步。&lt;/p&gt;

&lt;p&gt;由于 GPU 具备大量适用于并行计算的特性，因此 GPU 处理问题的方式和 CPU 是不同的，主要体现在以下两点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存存取 latency 的问题：CPU 通常使用 Cache 开减少存取主内存的次数，以避免内存 latency 影响到执行效率。GPU 通常没有 Cache（或很小），其利用并行化的方式来隐藏内存的 latency（当一个 Thread 需要等待内存读取时，开始执行另一个 Thread）。&lt;/li&gt;
  &lt;li&gt;分支指令的问题：CPU 通常利用分支预测等方式来减少分支指令造成的 pipeline bubble。GPU 则多半使用类似处理内存 latency 的方式。不过，通常 GPU 处理分支的效率会比较差。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1-sum-of-squares&quot;&gt;Section 1: Sum of Squares&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：对于给定数组，利用 CUDA 编程实现对该数组所有元素的平方进行求和，并计算每次求和&lt;strong&gt;所消耗的时间&lt;/strong&gt;及&lt;strong&gt;显存带宽&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;我们首先实现在 GPU 上的串行求和程序，然后将串行程序并行化，并从两个维度对并行程序进行优化。&lt;/p&gt;

&lt;h4 id=&quot;step-1-cuda初始化&quot;&gt;Step 1: CUDA初始化&lt;/h4&gt;

&lt;p&gt;首先实验需要使用 CUDA 的 RunTime API，所以需要引入头文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;cuda_runtime.h&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// CUDA Runtime API
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cuda_runtime.h&amp;gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;编写程序对当前环境进行检测，如果存在支持 CUDA 的设备，需要设置相应的设备。如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* CUDA初始化 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initCUDA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 取得支持CUDA的装置的数目
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;cudaGetDeviceCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;There is no device.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cudaDeviceProp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cudaGetDeviceProperties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaSuccess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;major&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;There is no device.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;cudaSetDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段程序首先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;cudaGetDeviceCount&lt;/code&gt;函数获取支持 CUDA 的设备的数量，如果不存在支持 CUDA 的设备 ，则会传入 1（ Device 0），Device 0 只是一个仿真设备，CUDA 的很多功能都不支持，因此如果要真正的确定是否存在支持 CUDA 的设备，需要对每个设备调用&lt;code class=&quot;highlighter-rouge&quot;&gt;cudaGetDeviceProperties&lt;/code&gt;函数来获取具体的参数。&lt;/p&gt;

&lt;h4 id=&quot;step-2-cuda核函数&quot;&gt;Step 2: CUDA核函数&lt;/h4&gt;

&lt;p&gt;在介绍核函数前，通过一段程序创建待求和的数组，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 产生0-9之间的随机数 */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果要进行求和计算，需要将生成的数组从主内存拷贝至显存。因此，我们需要在显存开辟一块合适的空间，然后将数组拷贝至显存空间，相关代码如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpudata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;generateNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 在显存上分配空间
// 思考：为什么cudaMalloc函数原型的第一个参数类型为 (void **)？
// 原因：gpudata指向某块内存区域的首地址，cudaMalloc在显存中分配一块内存，然后将该内存区域的首地址
//      赋值给gpudata，因此cudaMalloc修改的是gpudata本身的值，而不是gpudata指向的内存区域的值。
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpudata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cudaMalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 将数据从内存复制到显存
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpudata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyHostToDevice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在完成主内存和显存的数据拷贝后，开始着手编写核函数实现在 GPU 上的求和计算，核函数在编写时需要在函数返回值（&lt;code class=&quot;highlighter-rouge&quot;&gt;void&lt;/code&gt;）加添加&lt;code class=&quot;highlighter-rouge&quot;&gt;__global__&lt;/code&gt;，同时，核函数不允许有返回值。目前我们仅实现串行求和，其核函数如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;step-3-执行核函数&quot;&gt;Step 3: 执行核函数&lt;/h4&gt;

&lt;p&gt;在 CUDA 中，使用如下规则执行核函数。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;函数名称&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Shared&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Memory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;参数&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为目前我们仅需要实现串行计算，因此设置Block Num = 1，Thread Num = 1，Shared Memory Size = 0，相关程序如下所示。同时，在执行核函数后不要忘记释放程序分配的显存。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sumOfSquares&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpudata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 把计算结果从显存复制到内存
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cudaMemcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cudaMemcpyDeviceToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gpudata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cudaFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Step 1，Step 2 和 Step 3 的完整程序&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_1.cu&lt;/code&gt;见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_1.cu&quot;&gt;GitHub&lt;/a&gt; 。&lt;/p&gt;

&lt;h4 id=&quot;step-4-评估程序表现&quot;&gt;Step 4: 评估程序表现&lt;/h4&gt;

&lt;p&gt;在介绍 CUDA 架构时提到，GPU 通常没有 Cache（或很小），因此我们在编写程序时需要避免内存 latency 影响到执行效率。&lt;strong&gt;本实验通过核函数的运行时间来计算程序所使用的显存带宽，以此作为评估程序性能表现的标准之一&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_1.cu&lt;/code&gt;进行部分改动：利用&lt;code class=&quot;highlighter-rouge&quot;&gt;clock&lt;/code&gt;函数获取当前时间，时间差值即为核函数的运行时间，相关代码如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 获取起始时间
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 获取结束时间
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于核函数不能有返回值，因此需要在显存开辟一块空间来保存运行时间，然后将该运行时间值拷贝至内存。注意，该时间值的单位是时钟周期，我们需要将消耗的时钟周期数除以 GPU 自身的频率得到以秒为单位的时间值。&lt;/p&gt;

&lt;p&gt;对于显存带宽的计算，整个过程程序传输的数据量大小为 40 MB，将其除以时间得到程序运行过程中占用的显存带宽。程序运行结果如下图所示，此时显存访问带宽约为 46 MB/s。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step 4 的完整程序 &lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_2.cu&lt;/code&gt; 见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_2.cu&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;step-5-串行程序并行化&quot;&gt;Step 5: 串行程序并行化&lt;/h4&gt;

&lt;p&gt;在 CUDA 中，数据是从主内存复制到显存的 Global Memory，而Global Memory 是没有 Cache 的 ，因此存取 Global Memory 所需要的时间是非常长的（通常有数百个时钟周期）。由于之前的程序只有一个线程，当线程读取 Global Memory 时，线程会等待至实际数据读取成功，才能进行下一步计算。&lt;/p&gt;

&lt;p&gt;如果程序有多个线程，当其中一个线程在等待读取 Global Memory 时，GPU 可以立即切换至另一个线程。因此，通过增加线程的数量来提高显存的带宽是有效的策略。&lt;/p&gt;

&lt;p&gt;首先在程序中定义线程的数量，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 线程数
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#define THREAD_NUM 256
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序将数组划分为 &lt;code class=&quot;highlighter-rouge&quot;&gt;THREAD_NUM&lt;/code&gt;段，每个线程负责计算其中一段。最后，CPU 负责将各个线程计算得到的子结果进行累加。相关代码如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 获取当前线程Id（从0开始）
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 每个线程累加元素的个数
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序运行结果如下图所示，当实现初步并行化后，显存的使用带宽上升至 1.2 GB/s。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step 5 的完整程序&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_3.cu&lt;/code&gt;见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_3.cu&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;step-6-改进显存存取模式&quot;&gt;Step 6: 改进显存存取模式&lt;/h4&gt;

&lt;p&gt;显卡内存一般都是 DRAM，因此最有效的显存存取方式为连续存取。对于&lt;code class=&quot;highlighter-rouge&quot;&gt;cuda_sample_3&lt;/code&gt;，虽然每个线程操作的都是一块连续的内存，但是考虑当一个线程等待 Global Memory 的数据时，GPU 切换至另一个线程，而另一个线程会从显存的其它位置存取数据，下图描述了上述过程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;综上分析，虽然在同一个线程中是在一块连续的显存空间读取数据，但是在实际执行时并不是连续读取的，而是跳跃式的存取模式。因此，我们需要将显存的存取模式改进为连续存取模式，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;修改核函数，改进显存的存取模式，相关程序如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
    &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 线程0获取第0个元素，线程1获取第1个元素，以此类推... 
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序运行结果如下图所示，当我们优化了显存的存取模式后，显存的使用带宽上升至 1.9 GB/s。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step 6 的完整程序&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_4.cu&lt;/code&gt;见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_4.cu&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;step-7-进一步并行&quot;&gt;Step 7: 进一步并行&lt;/h4&gt;

&lt;p&gt;在介绍 CUDA 架构时提到，CUDA 除了提供了 Thread，还提供了 Block 及 Grid等重要的机制。每个 Block 的数量是有限的，但是可以通过增加 Block 的数量来成倍的增加线程的数量。需要注意的是，不同 Block 内的线程相互不能同步和通信，不过在我们的程序中线程之间并不需要进行同步或通信。因此，Step 7 将会使用多个 Block 来进一步并行化程序。相关代码如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 获取当前线程所属的Block号（从0开始）
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Block0-线程0获取第0个元素，Block0-线程1获取第1个元素...Block1-线程0获取第THREAD_NUM个元素，以此类推... 
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLOCK_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序运行结果如下图所示，当我们通过使用多 Block 来增加线程数目时，显存的使用带宽约为 11 GB/s。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step 7 的完整程序&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_5.cu&lt;/code&gt;见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_5.cu&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;step-8-共享内存和线程同步&quot;&gt;Step 8: 共享内存和线程同步&lt;/h4&gt;

&lt;p&gt;在 Step 7 中，CPU 需要进行 &lt;code class=&quot;highlighter-rouge&quot;&gt;BLOCK_NUM * THREAD_NUM&lt;/code&gt; 个元素的累加，如果可以让 GPU 执行一部分的累加，理应能够进一步提高程序的并行度。因为在一个 Block 内，线程是可以共享内存的，因此可以在 GPU 上实现一个 Block 内的线程结果累加，CPU 仅需要完成各个 Block 的计算结果的累加。&lt;/p&gt;

&lt;p&gt;需要注意：需要等待一个 Block 内的所有线程都完成计算才进行各个线程的计算结果的类型。因此，程序需要进行线程的同步，在 CUDA 中，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;__syncthreads&lt;/code&gt;函数进行线程的同步，相关代码如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 声明共享内存区域，用于存储每个Block中线程计算结果的累加和
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__shared__&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
    &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLOCK_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 线程同步，所有线程需要执行到此处方可继续向下执行
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;__syncthreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 线程0负责计算所有线程的计算结果累加和
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序运行结果如下图所示，显存使用带宽有所提升，但提升效果并不明显。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step 8 的完整程序&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_6.cu&lt;/code&gt;见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_6.cu&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&quot;step-9-树状加法&quot;&gt;Step 9: 树状加法&lt;/h4&gt;

&lt;p&gt;在 Step 8 中，一个 Block 中所有线程的结果的累加是通过一个线程（Thread 0）实现的，如果能够把每个 Block 内的加法并行化，那么程序的并行度应该能够进一步提高。我们利用树状加法将加法并行，树状加法计算过程如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图一个格子代表一个线程的计算结果，当进行第一轮迭代时，步长等于 1，Thread 0 和 Thread 1 相加，Thread 2 和 Thread 3 相加，依次类推…当进行第二轮迭代时，步长等于 1 + 1 = 2，Thread 0 和 Thread 2 相加，Thread 4 和 Thread 6 相加，依次类推…当进行第三轮迭代时，步长等于 2 + 2 = 4， Thread 0 和 Thread 4 相加，Thread 8 和 Thread 12 相加…依次类推。相关代码如下。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* 计算平方和（__global__函数运行于GPU）*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__global__&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sumOfSquares&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;clock_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__shared__&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blockIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadIdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 定义步长和计算掩码
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
    &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DATA_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLOCK_NUM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;__syncthreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* 并行加法代码段 */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 注意 &amp;amp; 的优先级小于 ==
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THREAD_NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 每迭代一轮需要所有线程进行一次同步
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;__syncthreads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;sub_sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shared&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序运行结果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-10-16-Image-13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step 9 的完整程序&lt;code class=&quot;highlighter-rouge&quot;&gt;sum_squares_7.cu&lt;/code&gt;见 &lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/SumSquares/sum_squares_7.cu&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-2-matrix-multiplication&quot;&gt;Section 2: Matrix Multiplication&lt;/h3&gt;

&lt;p&gt;目标：利用 CUDA 编写矩阵乘法并行程序，为了简化程序编写，假设待相乘的两个矩阵均为方块矩阵。&lt;/p&gt;

&lt;p&gt;在 CUDA 上实现矩阵乘法有多种方法，我自己实现了一个&lt;a href=&quot;https://github.com/tinylcy/cuda_lab/blob/master/MatrixMultiplication/matrix_multiplication.cu&quot;&gt;版本&lt;/a&gt;，供参考。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/column/details/computervision.html&quot;&gt;计算机视觉编程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.smallgui.com/wp-content/uploads/2016/04/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B0%88CUDA.pdf&quot;&gt;深入浅出谈 CUDA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="CUDA" /><summary type="html">CUDA（Compute Unified Device Architecture）是显卡厂商 NVIDIA 推出的运算平台，是一种通用的并行计算架构，该架构使 GPU 能够解决复杂的计算问题。我们可以使用 GPU 来并行例如神经网络、图像处理等在 CPU 上运行起来比较耗时的程序，通过 GPU 并行计算可以大大提高算法的运行速度。</summary></entry><entry><title type="html">初探Webx之约定胜于配置</title><link href="http://localhost:4000/2017/%E5%88%9D%E6%8E%A2Webx%E4%B9%8B%E7%BA%A6%E5%AE%9A%E8%83%9C%E4%BA%8E%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="初探Webx之约定胜于配置" /><published>2017-07-13T06:15:18+08:00</published><updated>2017-07-13T06:15:18+08:00</updated><id>http://localhost:4000/2017/%E5%88%9D%E6%8E%A2Webx%E4%B9%8B%E7%BA%A6%E5%AE%9A%E8%83%9C%E4%BA%8E%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://localhost:4000/2017/%E5%88%9D%E6%8E%A2Webx%E4%B9%8B%E7%BA%A6%E5%AE%9A%E8%83%9C%E4%BA%8E%E9%85%8D%E7%BD%AE/">&lt;p&gt;实习期间接触到了早有耳闻的&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;，于是很自然的按照官方文档运行了一个 &lt;a href=&quot;http://openwebx.org/docs/firstapp.html&quot;&gt;Demo&lt;/a&gt; ，粗略的阅读了一下代码，发现并不能很快的梳理清&lt;code class=&quot;highlighter-rouge&quot;&gt;Web&lt;/code&gt;请求的处理逻辑，以及视图层和控制层之间的关联关系。&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;为什么会被调用？&lt;code class=&quot;highlighter-rouge&quot;&gt;doChinese()&lt;/code&gt;为什么会被调用？这是我当时的两个疑问，为了解答这些疑问，需要理解&lt;code class=&quot;highlighter-rouge&quot;&gt;Web&lt;/code&gt;请求在&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;中经历的处理流程，为此我阅读了&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;部分源码，并以此文作为小结。&lt;/p&gt;

&lt;p&gt;在分析之前，我们需要强调&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;的一个重要设计理念——约定胜于配置。“约定”即规则，规则是预先定义的，工程师只需要按着规则来做事，就不需要额外的“配置”。对比其它一些框架，往往每增加一个页面，都需要在配置文件中增加若干行内容。&lt;/p&gt;

&lt;p&gt;注意，本篇文章仅用于解答上文提出的两个疑问，更多&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;的设计理念及原理性知识请参阅&lt;a href=&quot;http://openwebx.org/docs/&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;execute为什么会被调用&quot;&gt;execute()为什么会被调用？&lt;/h2&gt;

&lt;p&gt;本文以解析请求&lt;code class=&quot;highlighter-rouge&quot;&gt; http://localhost:8080/webx/simple/say_hi.do&lt;/code&gt;为例来回答第一个问题，在&lt;code class=&quot;highlighter-rouge&quot;&gt;SayHi&lt;/code&gt;类中&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;处添加断点，启动&lt;code class=&quot;highlighter-rouge&quot;&gt;Tomcat&lt;/code&gt;，程序执行至断点处，查看此时当前线程的函数调用栈，如下图所示（截取了部分）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-07-12-Image 1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;想要更好的理解该函数调用栈的信息，需要先从理论上对&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;处理一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Web&lt;/code&gt;请求有一个认知。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;首先，增强&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;response&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;session&lt;/code&gt;的功能，并把它们打包成更易使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestContext&lt;/code&gt;对象。&lt;/li&gt;
  &lt;li&gt;其次，它会调用相应子应用的&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;，用它来做进一步的处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;的一种机制，这种机制给予开发者极大的自由来自定制处理请求的流程。&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;由一系列的&lt;code class=&quot;highlighter-rouge&quot;&gt;valve&lt;/code&gt;构成，一个请求在获取响应（&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;）前需经历这一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;valve&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;映射成&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;，由开发者定制不同类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;所匹配的&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;。例如，当前请求的&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;/simple/say_hi.do&lt;/code&gt;，与之对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;如下所示。&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;when&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 执行不带模板的screen，无layout。 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;pl-conditions:target-extension-condition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;extension=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;do&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;pl-valves:performAction&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;pl-valves:performScreen&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/when&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结合&lt;code class=&quot;highlighter-rouge&quot;&gt;pipeline&lt;/code&gt;与函数调用栈，在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;之前，请求经历了一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;invoke()&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeNext()&lt;/code&gt;。首先执行&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pl-valves:performAction /&amp;gt;&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;PerformActionValve&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;invoke()&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;invokeNext()&lt;/code&gt;，由于当前请求并不包含表单提交，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;PerformActionValve&lt;/code&gt;不做任何操作。接着执行&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;pl-valves:performScreen /&amp;gt;&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;PerformScreenValve&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;invoke()&lt;/code&gt;，这也是我们分析的重点，该&lt;code class=&quot;highlighter-rouge&quot;&gt;invoke&lt;/code&gt;方法对应的源码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PipelineContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipelineContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;TurbineRunData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TurbineUtil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTurbineRunData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isRedirected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setContentType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;performScreenModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setOutputValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipelineContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;pipelineContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invokeNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;进入&lt;code class=&quot;highlighter-rouge&quot;&gt;performScreenModule&lt;/code&gt;方法，其源码如下所示（省略部分无关代码）。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;performScreenModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TurbineRunData&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;PerformScreenValve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ModuleFinder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerformScreenValve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ModuleFinder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTarget&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setLayoutEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getScreenModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ScreenEventUtil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setEventName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rundata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleReturningValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ModuleReturningValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;executeAndReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
            &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;performScreenModule&lt;/code&gt;首先根据当前&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;获取对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;。在&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;承担了用户提交数据的接收与处理、请求的控制与转发、处理结果的展示等重要功能。&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;缺省定义了三种类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt;：主要用于处理用户提交的数据，以及请求的控制与转发。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt;：主要用于处理页面的主体内容。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;control&lt;/code&gt;：主要用于处理页面的部分内容，特别是可重用的内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们接着进入&lt;code class=&quot;highlighter-rouge&quot;&gt;finder.getScreenModule()&lt;/code&gt;，源码如下。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getScreenModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleLoaderException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerformScreenValve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModuleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerformScreenValve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleLoaderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModuleQuiet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;screen&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerformScreenValve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleLoaderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModuleQuiet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;screen&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;eventModuleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打断点一步一步深入下去，进入&lt;code class=&quot;highlighter-rouge&quot;&gt;getModuleQuiet()&lt;/code&gt;，源码如下。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getModuleQuiet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleLoaderException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ModuleKey&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleKey&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;moduleType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModuleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;moduleName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModuleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;booleanValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleObject&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ModuleFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;factories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ModuleFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ModuleAdapterFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var11&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;adapters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;ModuleAdapterFactory&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var12&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var11&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var12&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;adapt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;UnadaptableModuleException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Could not adapt object to module: type=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, name=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, class=&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;var10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cacheEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;booleanValue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleCache&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;getModuleQuiet()&lt;/code&gt;中，首先根据&lt;code class=&quot;highlighter-rouge&quot;&gt;moduleType&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;moduleName&lt;/code&gt;创建&lt;code class=&quot;highlighter-rouge&quot;&gt;modulekey&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;会对&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;进行缓存，因此首先根据&lt;code class=&quot;highlighter-rouge&quot;&gt;moduleKey&lt;/code&gt;从缓存中获取&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;。如果缓存中还不存在当前&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;，继续深入，进入&lt;code class=&quot;highlighter-rouge&quot;&gt;DataBindingAdapterFactory&lt;/code&gt;类的&lt;code class=&quot;highlighter-rouge&quot;&gt;adapt&lt;/code&gt;方法，源码如下。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Module&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;adapt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ModuleInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleInfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;executeMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;execute&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executeMethod&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;FastClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FastClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;FastMethod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;executeMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;skippable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DataBindingAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;moduleObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethodInvoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;skippable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;adapt&lt;/code&gt;方法中，一切开始变得清晰起来：首先尝试获取&lt;code class=&quot;highlighter-rouge&quot;&gt;moduleObject&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;方法，若存在，那么当前&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;对应的Module的最关键部分也就构建完成了。&lt;strong&gt;至此，第一个疑问“为什么&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;会被调用”得到了解答&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;获取了&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;executeAndReturn()&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;，完成页面主体内容的处理。&lt;code class=&quot;highlighter-rouge&quot;&gt;executeAndReturn()&lt;/code&gt;源码如下。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;executeAndReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;executeMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;dochinese为什么会被调用&quot;&gt;doChinese()为什么会被调用？&lt;/h2&gt;

&lt;p&gt;此时&lt;code class=&quot;highlighter-rouge&quot;&gt;Web&lt;/code&gt;请求&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;为 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080/webx/multievent/say_hello_1/chinese.do&lt;/code&gt; ，因此相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;即为&lt;code class=&quot;highlighter-rouge&quot;&gt;/multievent/say_hello_1/chinese.do&lt;/code&gt;。与第一个问题的请求处理流程相同，&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;首先根据当前&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;去获取&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;，若无法获取，那么认为当前&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;是由两部分组成：&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;eventModuleName&lt;/code&gt;，解析&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;的源码如下。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parseEvent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slashIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lastIndexOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dotIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lastIndexOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slashIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;slashIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dotIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slashIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;dotIndex:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;eventModuleName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerformScreenValve&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getModuleName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slashIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;继续打断点深入源码，&lt;code class=&quot;highlighter-rouge&quot;&gt;Webx&lt;/code&gt;会将&lt;code class=&quot;highlighter-rouge&quot;&gt;eventModuleName&lt;/code&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;moduleName&lt;/code&gt;获取&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;。同样的，首先尝试获取&lt;code class=&quot;highlighter-rouge&quot;&gt;execute()&lt;/code&gt;，如果获取不到便获取所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;EventHandler&lt;/code&gt;，源码如下。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getEventHandlers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;HashMap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduleClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checkMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;startsWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;do&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Character&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isUpperCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eventName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringUtil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toCamelCase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;methodName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;perform&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eventName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;eventName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CollectionUtil&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eventName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此我们理解为什么&lt;code class=&quot;highlighter-rouge&quot;&gt;doChinese()&lt;/code&gt;为什么会被调用了：获取当前&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt;的类的所有以&lt;code class=&quot;highlighter-rouge&quot;&gt;do&lt;/code&gt;开头的方法，构建&lt;code class=&quot;highlighter-rouge&quot;&gt;eventName&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Method&lt;/code&gt;的映射关系，存储在一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;中，注意我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;已被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;eventModuleName&lt;/code&gt;，在&lt;code class=&quot;highlighter-rouge&quot;&gt;executeAndReturn()&lt;/code&gt;中根据&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;中获取相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;Method&lt;/code&gt;并执行，源码如下（省略部分无关代码）。&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;executeAndReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleEventException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ModuleEventNotFoundException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getEventName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MethodInvoker&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MethodInvoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MethodInvoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;handlers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	   &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;moduleObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;所以第二个疑问也得到了解答 :P&lt;/strong&gt;&lt;/p&gt;</content><author><name></name></author><category term="Webx" /><summary type="html">实习期间接触到了早有耳闻的Webx，于是很自然的按照官方文档运行了一个 Demo ，粗略的阅读了一下代码，发现并不能很快的梳理清Web请求的处理逻辑，以及视图层和控制层之间的关联关系。execute()为什么会被调用？doChinese()为什么会被调用？这是我当时的两个疑问，为了解答这些疑问，需要理解Web请求在Webx中经历的处理流程，为此我阅读了Webx部分源码，并以此文作为小结。</summary></entry><entry><title type="html">如何实现一个分布式RPC框架</title><link href="http://localhost:4000/2017/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6/" rel="alternate" type="text/html" title="如何实现一个分布式RPC框架" /><published>2017-07-04T19:57:15+08:00</published><updated>2017-07-04T19:57:15+08:00</updated><id>http://localhost:4000/2017/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6</id><content type="html" xml:base="http://localhost:4000/2017/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6/">&lt;p&gt;远程过程调用（&lt;code class=&quot;highlighter-rouge&quot;&gt;Remote Procedure Call&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;的主要目标是让构建分布式应用更加容易，在提供强大的远程调用能力的同时不损失本地调用的语义的简洁性。&lt;/p&gt;

&lt;p&gt;趁实习前的这段业余时间，我实现了一个轻量级的分布式&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;框架，名字叫做 &lt;a href=&quot;https://github.com/tinylcy/buddha&quot;&gt;buddha&lt;/a&gt;，代码量不大，但是麻雀虽小却五脏俱全。本篇文章将一步步阐明&lt;code class=&quot;highlighter-rouge&quot;&gt;buddha&lt;/code&gt;的设计、框架组件的拆解以及需要考虑的因素。&lt;/p&gt;

&lt;h2 id=&quot;序列化与反序列化&quot;&gt;序列化与反序列化&lt;/h2&gt;

&lt;p&gt;在网络中，所有的数据都将会被转化为字节进行传送，所以在代码层面上，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;框架需要实现特定格式的数据与字节数组之间的相互转化。像&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;已经提供了默认的序列化方式，但是如果是在高并发的场景下，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;原生的序列化方式可能会遇到性能瓶颈。于是，出现了许多开源的、高效的序列化框架：如&lt;code class=&quot;highlighter-rouge&quot;&gt;Kryo&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;fastjson&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Protobuf&lt;/code&gt;等。&lt;code class=&quot;highlighter-rouge&quot;&gt;buddha&lt;/code&gt;目前支持&lt;code class=&quot;highlighter-rouge&quot;&gt;Kryo&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fastjson&lt;/code&gt;两种序列化框架。&lt;/p&gt;

&lt;h2 id=&quot;tcp拆包粘包&quot;&gt;TCP拆包、粘包&lt;/h2&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP&lt;/code&gt;只关心字节流，并不知晓上层的数据格式。如果客户端应用层一次要发送的数据过大时，&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP&lt;/code&gt;会将该数据进行分解传送，因此在服务端需要进行粘包处理（由&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP&lt;/code&gt;来保证数据的有序性）；如果客户端一次要发送的数据量很小时，&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP&lt;/code&gt;并不会马上把数据发送出去，而是将其存储在缓冲区，当达到某个阈值的时候再发送出去，因此在服务端需要进行拆包的工作。&lt;/p&gt;

&lt;p&gt;通过以上分析，我们了解了&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP&lt;/code&gt;粘包或者拆包的原因，解决这个问题的关键在于向数据包添加边界信息，常用的方法有如下三个。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;发送端给每个数据包添加包首部，首部中至少包含数据包的长度，这样在接收端接收到数据时，通过读取首部的长度信息得到该数据包有效数据的长度。&lt;/li&gt;
  &lt;li&gt;发送端将每个数据包封装为固定长度（多余用&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;填充），这样接收端在接收到数据后根据约定好的固定长度读取每个数据包的数据。&lt;/li&gt;
  &lt;li&gt;使用特殊符号将每个数据包区分开来，接收端也是通过该特殊符号的划分数据包的边界。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buddha&lt;/code&gt;采用第一种方式来解决&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP&lt;/code&gt;拆包、粘包的问题。&lt;/p&gt;

&lt;h2 id=&quot;bio与nio&quot;&gt;BIO与NIO&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BIO&lt;/code&gt;往往用于经典的每连接每线程模型，之所以使用多线程，是因为像&lt;code class=&quot;highlighter-rouge&quot;&gt;accept()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;等函数都是同步阻塞的，这意味着当应用为单线程且进行&lt;code class=&quot;highlighter-rouge&quot;&gt;IO&lt;/code&gt;操作时，如果线程阻塞那么该应用必然会进入挂死状态，但是实际上此时&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;是处于空闲状态的。开启多线程，就可以让&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;去为更多的线程服务，提高&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;的利用率。但是在活跃线程数较多的情况下，采用多线程模型回带来如下几个问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;线程的创建和销毁代价颇高，在&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;操作系统中，线程本质上就是一个进程，创建和销毁线程属于重量级的操作。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;中，每个线程会占用固定大小的栈空间，而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;的内存空间是有限的，因此如果线程数量过多那么线程本身就会占据过多的资源。&lt;/li&gt;
  &lt;li&gt;线程的切换成本较高，每次线程切换需要涉及上下文的保存、恢复以及用户态和内核态的切换。如果线程数过多，那么会有较大比例的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;时间花费在线程切换上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用线程池的方式解决前两个问题，但是线程切换带来的开销还是存在。所以在高并发的场景下，传统的&lt;code class=&quot;highlighter-rouge&quot;&gt;BIO&lt;/code&gt;是无能为力的。而&lt;code class=&quot;highlighter-rouge&quot;&gt;NIO&lt;/code&gt;的重要特点是：读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，可以立即返回，这就允许我们不使用多线程充分利用&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;。如果一个连接不能读写，可以把这个事件记录下来，然后切换到别的就绪的连接进行数据读写。在&lt;code class=&quot;highlighter-rouge&quot;&gt;buddha&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Netty&lt;/code&gt;被用来编写结构更加清晰的&lt;code class=&quot;highlighter-rouge&quot;&gt;NIO&lt;/code&gt;程序。&lt;/p&gt;

&lt;h2 id=&quot;服务注册与发现&quot;&gt;服务注册与发现&lt;/h2&gt;

&lt;p&gt;在实际应用中，&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;服务的提供者往往需要使用集群来保证服务的稳定性与可靠性。因此需要实现一个服务注册中心，服务提供者将当前可用的服务地址信息注册至注册中心，而客户端在进行远程调用时，先通过服务注册中心获取当前可用的服务列表，然后获取具体的服务提供者的地址信息（该阶段可以进行负载均衡），根据地址信息向服务提供者发起调用。客户端可以缓存可用服务列表，当注册中心的服务列表发生变更时需要通知客户端。同时，当服务提供者变为不可用状态时也需要通知注册中心服务不可用。&lt;code class=&quot;highlighter-rouge&quot;&gt;buddha&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ZooKeeper&lt;/code&gt;实现服务注册与发现功能。&lt;/p&gt;

&lt;h2 id=&quot;代码实现&quot;&gt;代码实现&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;buddha&lt;/code&gt;是我学习验证&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;过程中诞生的一个轻量级分布式&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;框架，代码放在了 &lt;a href=&quot;https://github.com/tinylcy/buddha&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://mindwind.me/blog/2016/05/22/RPC-%E7%9A%84%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90.html&quot;&gt;RPC 的概念模型与实现解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/luxiaoxun/NettyRpc&quot;&gt;NettyRpc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="DistributedSystems" /><summary type="html">远程过程调用（Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。RPC的主要目标是让构建分布式应用更加容易，在提供强大的远程调用能力的同时不损失本地调用的语义的简洁性。</summary></entry><entry><title type="html">CSAPP: Attack Lab</title><link href="http://localhost:4000/2017/CSAPP-Attack-Lab/" rel="alternate" type="text/html" title="CSAPP: Attack Lab" /><published>2017-05-07T06:38:55+08:00</published><updated>2017-05-07T06:38:55+08:00</updated><id>http://localhost:4000/2017/CSAPP-Attack-Lab</id><content type="html" xml:base="http://localhost:4000/2017/CSAPP-Attack-Lab/">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Attack Lab&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;CS:APP&lt;/code&gt;一书中第三个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/attacklab.pdf&quot;&gt;实验&lt;/a&gt;，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Part I&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Part II&lt;/code&gt;两部分，分别实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Code Injection Attacks&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Return-Oriented Programming&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;Code Injection Attacks&lt;/code&gt;主要利用缓冲区溢出执行不安全的代码片段；当栈被标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;nonexecutable&lt;/code&gt;或者位置随机时，可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;Return-Oriented Programming&lt;/code&gt;达到攻击的目的。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;目前的进度是完成了&lt;code class=&quot;highlighter-rouge&quot;&gt;Part I&lt;/code&gt;，等有时间再回来完成&lt;code class=&quot;highlighter-rouge&quot;&gt;Part II&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;part-i-code-injection-attacks&quot;&gt;Part I: Code Injection Attacks&lt;/h2&gt;

&lt;h3 id=&quot;level-1&quot;&gt;Level 1&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;利用输入字符串使当前执行的代码段跳转到预设的代码片段，不会涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;code injection&lt;/code&gt;：当&lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;返回后，我们要改变&lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;正常的执行逻辑，不再执行下一条指令，而是让&lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;touch1()&lt;/code&gt;执行指令。 &lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;touch1()&lt;/code&gt;对应的代码如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No exploit. Getbuf returned 0x%x&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touch1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vlevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Part&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Touch1!: You called touch1()&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;中的跳转，关键是利用缓冲区溢出来修改&lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;时栈帧中的返回地址。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;ctarget&lt;/code&gt;反编译，提取&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;关联的的汇编代码，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;00000000004017a8 &amp;lt;getbuf&amp;gt;:
  4017a8:       48 83 ec 28             sub    $0x28,%rsp
  4017ac:       48 89 e7                mov    %rsp,%rdi
  4017af:       e8 8c 02 00 00          callq  401a40 &amp;lt;Gets&amp;gt;
  4017b4:       b8 01 00 00 00          mov    $0x1,%eax
  4017b9:       48 83 c4 28             add    $0x28,%rsp
  4017bd:       c3                      retq
  4017be:       90                      nop
  4017bf:       90                      nop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;%rsp&lt;/code&gt;被减小了&lt;code class=&quot;highlighter-rouge&quot;&gt;$0x28&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;字节，这意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;开辟了&lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;字节的缓冲区，而缓冲区以上的&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;字节则是&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;指令后&lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;继续执行的指令的地址。&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;要做的就是利用缓冲区溢出，修改这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;字节的值，使之等于&lt;code class=&quot;highlighter-rouge&quot;&gt;touch1()&lt;/code&gt;的地址。根据反编译&lt;code class=&quot;highlighter-rouge&quot;&gt;ctarget&lt;/code&gt;得到的汇编代码，&lt;code class=&quot;highlighter-rouge&quot;&gt;touch1()&lt;/code&gt;的起始地址为&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4017c0&lt;/code&gt;，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;00000000004017c0 &amp;lt;touch1&amp;gt;:
  4017c0:       48 83 ec 08             sub    $0x8,%rsp
  4017c4:       c7 05 0e 2d 20 00 01    movl   $0x1,0x202d0e(%rip)        # 6044dc &amp;lt;vlevel&amp;gt;
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;综上，&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;所需的输入字符串长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;44&lt;/code&gt;字节，前&lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;字节用于填充缓冲区，具体的值不重要，后&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;字节等于&lt;code class=&quot;highlighter-rouge&quot;&gt;touch1()&lt;/code&gt;的地址值&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4017c0&lt;/code&gt;，注意内存存储规则为&lt;code class=&quot;highlighter-rouge&quot;&gt;Little Endian&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们利用&lt;code class=&quot;highlighter-rouge&quot;&gt;hex2raw&lt;/code&gt;将输入字符串(&lt;code class=&quot;highlighter-rouge&quot;&gt;level1.txt&lt;/code&gt;)转化为字节码，并将字节码文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;level1_bc.txt&lt;/code&gt;)作为&lt;code class=&quot;highlighter-rouge&quot;&gt;ctarget&lt;/code&gt;的输入，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-05-06-Image 1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;通过缓冲区溢出帮助我们理解函数与函数之间跳转的原理，但是并未涉及到参数的传递，这需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;code injection&lt;/code&gt;来实现。&lt;/p&gt;

&lt;h3 id=&quot;level-2&quot;&gt;Level 2&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;的流程与&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;相似：&lt;code class=&quot;highlighter-rouge&quot;&gt;test()&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;，当&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;返回之后，开始执行&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;的指令。&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;有着如下的代码逻辑。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touch2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vlevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Part&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cookie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Touch2!: You called touch2(0x%.8x)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Misfire: You called touch2(0x%.8x)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;不同，&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;除了需要实现指令跳转，还需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;作为参数传递至&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;。这意味着需要执行一段我们自定义的代码来实现参数的传递，这就是所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;code injection&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;中，我们通过改写返回地址值达到跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;touch1()&lt;/code&gt;的目的，如果我们现在也仅仅是将返回地址修改为&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;的地址，那么参数传递的问题并没有解决。根据&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;寄存器使用规范，&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;val&lt;/code&gt;存储于寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;，此时&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;的值并不是我们期望的&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;值。如果在跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;执行指令之前，先跳转到某个区域执行一段代码，这段代码能够设置寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;的值，然后再跳转到&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;执行，就可以达到我们的目的。关键是这段代码存储于内存的哪块区域？答案是由&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;开辟的缓冲区，也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;中可以是任意值的&lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;字节。基于以上思路，我们需要明确缓冲区的地址以及待注入的代码。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Gets()&lt;/code&gt;函数开辟缓冲区，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Gets()&lt;/code&gt;的返回值即是缓冲区的地址，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;寄存器使用规范，返回值存储于寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rax&lt;/code&gt;。利用&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;查看寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rax&lt;/code&gt;的值，如下图所示，缓冲区的起始地址为&lt;code class=&quot;highlighter-rouge&quot;&gt;0x5561dc78&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-05-06-Image 2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;待注入的代码设置寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;的值等于&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;值，然后跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;touch2()&lt;/code&gt;执行指令。用汇编代码来描述，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;mov $0x59b997fa,%rdi
pushq $0x4017ec
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将以上汇编代码进行汇编，然后进行反编译得到机器代码，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-05-06-Image 3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，可以写出&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;所需的输入字符串，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;48 c7 c7 fa 97 b9 59 68 ec 17 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;hex2raw&lt;/code&gt;将输入字符串转化为字节码，并将字节码文件作为&lt;code class=&quot;highlighter-rouge&quot;&gt;ctarget&lt;/code&gt;的输入，运行结果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-05-06-Image 4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;level-3&quot;&gt;Level 3&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;也需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;code injection&lt;/code&gt;来传递参数。比&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;更复杂的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;传递的参数类型是字符串，更确切的说，应该是字符串的地址。与&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;相关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;touch3()&lt;/code&gt;如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;touch3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;vlevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Part&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hexmatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cookie&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Touch3!: You called touch3(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Misfire: You called touch3(&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;touch3()&lt;/code&gt;内部调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;，其代码如下所示。同时，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;的代码逻辑我们推断出&lt;code class=&quot;highlighter-rouge&quot;&gt;touch3()&lt;/code&gt;期待的参数为&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;值的字符串表示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compare&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;represention&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hexmatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Make&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unpredictable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cbuf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;%.8x&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strncmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;的思路类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;通过向&lt;code class=&quot;highlighter-rouge&quot;&gt;getbuf()&lt;/code&gt;开辟的缓冲区中注入代码来达到设置参数值的目的，但是我们发现&lt;code class=&quot;highlighter-rouge&quot;&gt;touch3()&lt;/code&gt;调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;又调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;strncmp()&lt;/code&gt;，这就出现了问题：函数的调用会导致新的数据被&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;到栈中，这意味着栈中原有的数据会被覆盖。那么，我们传递的参数，也就是字符串，应该存储在内存的什么位置？&lt;/p&gt;

&lt;p&gt;基于以上分析，&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;中待注入的代码与&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;非常类似，唯一不同的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;向寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;值，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;向寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;字符串的地址值。我们借助&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;对比&lt;code class=&quot;highlighter-rouge&quot;&gt;touch3()&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;前后缓冲区的变化情况，以此定位安全的存储字符串的地址。为此，我们先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 1&lt;/code&gt;中的方法进入&lt;code class=&quot;highlighter-rouge&quot;&gt;touch3()&lt;/code&gt;，并将指令执行至&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;前一条的指令，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-05-06-Image 5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着执行&lt;code class=&quot;highlighter-rouge&quot;&gt;callq 0x40184c &amp;lt;hexmatch&amp;gt;&lt;/code&gt;指令，对比执行前后缓冲区内容的变化，可以发现缓冲区的	前&lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;个字节并没有连续的&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个安全的字节供&lt;code class=&quot;highlighter-rouge&quot;&gt;cookie&lt;/code&gt;字符串存储，但是从&lt;code class=&quot;highlighter-rouge&quot;&gt;0x5561dca0&lt;/code&gt;开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;个字节在&lt;code class=&quot;highlighter-rouge&quot;&gt;hexmatch()&lt;/code&gt;调用前后并没有发生变化。因此，可以把字符串存储在缓冲区以外的这片内存区域中(我选择以&lt;code class=&quot;highlighter-rouge&quot;&gt;0x5561dca8&lt;/code&gt;为首地址的&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节)。&lt;/p&gt;

&lt;p&gt;现在可以将已确定的字符串地址存储至寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;，对应的汇编代码如下所示，获取对应机器码的方式与&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 2&lt;/code&gt;一致。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;mov $0x5561dca8,%rdi
pushq $0x4018fa
ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Level 3&lt;/code&gt;的输入字符串需要根据字符串的存储地址做相应的补充，由于字符串的首地址为&lt;code class=&quot;highlighter-rouge&quot;&gt;0x5561dca8&lt;/code&gt;，且字符串长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;，因此输入字符串的总长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;56&lt;/code&gt;字节，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 35 39 62 39 39 37 66 61
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;借助&lt;code class=&quot;highlighter-rouge&quot;&gt;hex2raw&lt;/code&gt;将输入字符串转化为字节码，并将其作为&lt;code class=&quot;highlighter-rouge&quot;&gt;ctarget&lt;/code&gt;的输入，结果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-05-06-Image 6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-ii-return-oriented-programming&quot;&gt;Part II: Return-Oriented Programming&lt;/h2&gt;

&lt;h3 id=&quot;-todo&quot;&gt;// TODO&lt;/h3&gt;</content><author><name></name></author><category term="CSAPP" /><category term="Assembly" /><summary type="html">Attack Lab是CS:APP一书中第三个实验，包括Part I和Part II两部分，分别实现Code Injection Attacks和Return-Oriented Programming。Code Injection Attacks主要利用缓冲区溢出执行不安全的代码片段；当栈被标记为nonexecutable或者位置随机时，可以利用Return-Oriented Programming达到攻击的目的。</summary></entry><entry><title type="html">6 824 Lab 1 Mapreduce</title><link href="http://localhost:4000/2017/6-824-Lab-1-MapReduce/" rel="alternate" type="text/html" title="6 824 Lab 1 Mapreduce" /><published>2017-05-03T00:00:00+08:00</published><updated>2017-05-03T00:00:00+08:00</updated><id>http://localhost:4000/2017/6-824-Lab-1-MapReduce</id><content type="html" xml:base="http://localhost:4000/2017/6-824-Lab-1-MapReduce/">&lt;p&gt;开始学习大名鼎鼎的&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2016/index.html&quot;&gt;MIT 6.824: Distributed Systems&lt;/a&gt;课程，我跟的是&lt;code class=&quot;highlighter-rouge&quot;&gt;2016&lt;/code&gt;年的课程，课程的主要内容是读&lt;code class=&quot;highlighter-rouge&quot;&gt;Paper&lt;/code&gt;和做&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab&lt;/code&gt;，使用的语言为&lt;code class=&quot;highlighter-rouge&quot;&gt;Go&lt;/code&gt;。五一假期期间我基本做完了&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2016/labs/lab-1.html&quot;&gt;Lab 1&lt;/a&gt;，感觉难度还是相当大的。本篇文章是我对&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab 1&lt;/code&gt;的一个总结。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;mapreduce&quot;&gt;MapReduce&lt;/h2&gt;

&lt;p&gt;每次读&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf&quot;&gt;MapReduce&lt;/a&gt;论文，都会有新的收获，也自知还有理解不到位的地方。&lt;/p&gt;

&lt;h3 id=&quot;execution-overview&quot;&gt;Execution Overview&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;输入数据被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;个分片，由&lt;code class=&quot;highlighter-rouge&quot;&gt;map worker&lt;/code&gt;产生的中间&lt;code class=&quot;highlighter-rouge&quot;&gt;key-value pairs&lt;/code&gt;被划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个分片。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;的大小取决于&lt;code class=&quot;highlighter-rouge&quot;&gt;GFS&lt;/code&gt;块的大小，&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;取决于&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;的个数。所以，整个&lt;code class=&quot;highlighter-rouge&quot;&gt;MapReduce Job&lt;/code&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;阶段，&lt;code class=&quot;highlighter-rouge&quot;&gt;map worker&lt;/code&gt;把输出的中间&lt;code class=&quot;highlighter-rouge&quot;&gt;key-value pairs&lt;/code&gt;分割成&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;region&lt;/code&gt;，注意&lt;code class=&quot;highlighter-rouge&quot;&gt;pairs&lt;/code&gt;首先会存储在缓冲区中，然后定期的写入本地磁盘。&lt;code class=&quot;highlighter-rouge&quot;&gt;pairs&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;map worker&lt;/code&gt;上的位置信息会发送给&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，由&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;通知&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;数据读取位置信息。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;阶段，当&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;获取了输入数据的位置信息后，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;读取数据。当&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;获取了所有的相关数据之后，会对它们进行一次排序，排序的目的在于不同&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;pairs&lt;/code&gt;会汇聚到同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;当所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;完成后，一共会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个输出文件，每个&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;对应一个。一般来说没有必要将这&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个文件合并成一个文件，因为这&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个文件往往会作为下一个&lt;code class=&quot;highlighter-rouge&quot;&gt;MapReduce Job&lt;/code&gt;的输入数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;master-data-structures&quot;&gt;Master Data Structures&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;会记录所有&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;的状态(&lt;code class=&quot;highlighter-rouge&quot;&gt;idle&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;in-progress&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;completed&lt;/code&gt;)信息。同时，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;还会保存那些处于&lt;code class=&quot;highlighter-rouge&quot;&gt;non-idle&lt;/code&gt;状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;所关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;的信息。&lt;/li&gt;
  &lt;li&gt;对于每个状态为&lt;code class=&quot;highlighter-rouge&quot;&gt;completed&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;会保存该&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;region&lt;/code&gt;的位置信息和大小信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fault-tolerance&quot;&gt;Fault Tolerance&lt;/h3&gt;

&lt;h4 id=&quot;worker-failure&quot;&gt;Worker Failure&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;通过周期性的&lt;code class=&quot;highlighter-rouge&quot;&gt;ping&lt;/code&gt;所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;来确认&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;是否可用，如果某个&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;崩溃了，那么在该&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;上完成的所有&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;都会回退到&lt;code class=&quot;highlighter-rouge&quot;&gt;idle&lt;/code&gt;状态，因此这些&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;会被重新调度到可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;上。同理，如果处于&lt;code class=&quot;highlighter-rouge&quot;&gt;in-progress&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;所在的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;崩溃了，那么这些&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;也会被重新调度到可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;上重新执行。&lt;/li&gt;
  &lt;li&gt;如果某个&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;崩溃了，其上处于&lt;code class=&quot;highlighter-rouge&quot;&gt;completed&lt;/code&gt;状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;需要重新被调度执行，这是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;的输出数据是存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;local disk&lt;/code&gt;。相反，如果某个&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;崩溃了，其上处于&lt;code class=&quot;highlighter-rouge&quot;&gt;completed&lt;/code&gt;状态的&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;不需要重新被调度执行，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;的输出数据是存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;global file system&lt;/code&gt;上的。&lt;/li&gt;
  &lt;li&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;时，如果某个&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;worker A&lt;/code&gt;切换到了&lt;code class=&quot;highlighter-rouge&quot;&gt;worker B&lt;/code&gt;(可能是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;worker A&lt;/code&gt;崩溃了)，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;会通知该&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;worker B&lt;/code&gt;读取数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;master-failure&quot;&gt;Master Failure&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;通过定期的做&lt;code class=&quot;highlighter-rouge&quot;&gt;checkpoints&lt;/code&gt;来保证&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;的容错性。&lt;/li&gt;
  &lt;li&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;只有一个，所以可以认为&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;出故障的概率很小。如果真的出故障了，那么根据需要重新执行&lt;code class=&quot;highlighter-rouge&quot;&gt;MapReduce Job&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lab&quot;&gt;Lab&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab 1&lt;/code&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;Part&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 1 &amp;amp; Part 2&lt;/code&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequential MapReduce&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 3 &amp;amp; Part 4&lt;/code&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed MapReduce&lt;/code&gt;，并且要解决&lt;code class=&quot;highlighter-rouge&quot;&gt;worker failure&lt;/code&gt;。同时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab 1&lt;/code&gt;提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;MapReduce&lt;/code&gt;的整个框架，并实现了与核心内容无关的代码。在完成各个&lt;code class=&quot;highlighter-rouge&quot;&gt;Part&lt;/code&gt;之前，我们需要理解&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab 1&lt;/code&gt;实现的两个版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;MapReduce&lt;/code&gt;框架的设计思路。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;goroutine&lt;/code&gt;的形式存在，当&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;可用时，以&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;的方式向&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;注册，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;来实现&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;的调度。同时，在&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed MapReduce&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;还需要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;worker failure&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;将会以参数的形式存在于&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequential/Distributed MapReduce&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;论文中&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;以块作为分割，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;将以文件作为分割。&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;阶段，对于每个&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;(一个输入文件)，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;会至少调用一次&lt;code class=&quot;highlighter-rouge&quot;&gt;doMap()&lt;/code&gt;。同理在&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;阶段，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;对每个&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;至少调用一次&lt;code class=&quot;highlighter-rouge&quot;&gt;doReduce()&lt;/code&gt;。在&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequential MapReduce&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequential()&lt;/code&gt;[&lt;code class=&quot;highlighter-rouge&quot;&gt;master.go&lt;/code&gt;]的核心参数&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;遍历了&lt;code class=&quot;highlighter-rouge&quot;&gt;file slice&lt;/code&gt;，根据当前所处的&lt;code class=&quot;highlighter-rouge&quot;&gt;phase&lt;/code&gt;对每个&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;doMap()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;doReduce()&lt;/code&gt;。在&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed MapReduce&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed()&lt;/code&gt;[&lt;code class=&quot;highlighter-rouge&quot;&gt;master.go&lt;/code&gt;]的核心参数&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;需要我们去实现(&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 3 &amp;amp; Part 4&lt;/code&gt;)。&lt;/li&gt;
  &lt;li&gt;在完成了所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;map task&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce task&lt;/code&gt;之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;merge()&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce worker&lt;/code&gt;的输出文件进行合并。&lt;/li&gt;
  &lt;li&gt;最后&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;向每个&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;发送&lt;code class=&quot;highlighter-rouge&quot;&gt;Shutdown RPC&lt;/code&gt;，然后关闭整个应用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;理解完整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab&lt;/code&gt;的框架，下面谈谈每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Part&lt;/code&gt;需要注意的地方。&lt;/p&gt;

&lt;h3 id=&quot;part-1-mapreduce-input-and-output&quot;&gt;Part 1: Map/Reduce input and output&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 1&lt;/code&gt;主要的内容是完成&lt;code class=&quot;highlighter-rouge&quot;&gt;doMap()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;doReduce()&lt;/code&gt;，在编码前一定要仔细阅读注释给我们提供的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;doMap()&lt;/code&gt;读取输入文件(&lt;code class=&quot;highlighter-rouge&quot;&gt;inFile&lt;/code&gt;)的内容，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mapF&lt;/code&gt;将其转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;[]KeyValue&lt;/code&gt;。对于每个&lt;code class=&quot;highlighter-rouge&quot;&gt;inFile&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;doMap&lt;/code&gt;将产生&lt;code class=&quot;highlighter-rouge&quot;&gt;nReduce&lt;/code&gt;(对应于论文中的&lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt;)个输出文件。同时，数据以&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt;的格式存储至输出文件中。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;doReduce()&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;nMap&lt;/code&gt;(对应于论文中的&lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt;)个&lt;code class=&quot;highlighter-rouge&quot;&gt;map worker&lt;/code&gt;读取输入数据(&lt;code class=&quot;highlighter-rouge&quot;&gt;[]KeyValue&lt;/code&gt;)，注意输入数据的格式为&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt;。根据&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;构建出&lt;code class=&quot;highlighter-rouge&quot;&gt;map[key]values&lt;/code&gt;数据结构，对每个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;)和对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;values&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;[]string&lt;/code&gt;)调用&lt;code class=&quot;highlighter-rouge&quot;&gt;reduceF()&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;doReduce()&lt;/code&gt;产生一个输出文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-2-single-worker-word-count&quot;&gt;Part 2: Single-worker word count&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 2&lt;/code&gt;实现经典的&lt;code class=&quot;highlighter-rouge&quot;&gt;WordCount&lt;/code&gt;，需要我们实现&lt;code class=&quot;highlighter-rouge&quot;&gt;mapF&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;reduceF&lt;/code&gt;中的逻辑。需要注意的是要按照&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab&lt;/code&gt;提供的切词规范(&lt;code class=&quot;highlighter-rouge&quot;&gt;determined by unicode.IsLetter&lt;/code&gt;)去分词，而不要想当然的用空格作为分隔符。&lt;/p&gt;

&lt;h3 id=&quot;part-3-distributing-mapreduce-tasks&quot;&gt;Part 3: Distributing MapReduce tasks&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 3&lt;/code&gt;着手实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed MapReduce&lt;/code&gt;，为了模拟真正的分布式环境，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;之间的通信和同步仅通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;channel&lt;/code&gt;来实现。&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 3&lt;/code&gt;需要我们实现&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;的调度逻辑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed MapReduce&lt;/code&gt;的实现逻辑在上文已有所提及，&lt;code class=&quot;highlighter-rouge&quot;&gt;Sequential MapReduce&lt;/code&gt;顺序调度每个&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;执行，而在&lt;code class=&quot;highlighter-rouge&quot;&gt;Distributed MapReduce&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;调度到当前可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;上去执行。&lt;/li&gt;
  &lt;li&gt;只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;map/reduce&lt;/code&gt;阶段所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;全部完成后，&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;才能返回。这一点在代码中我是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sync.WaitGroup&lt;/code&gt;来实现。&lt;/li&gt;
  &lt;li&gt;在分布式环境下，&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;调度&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;，同时输入文件的信息也是作为&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;参数传递。&lt;/li&gt;
  &lt;li&gt;当前可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;registerChannel&lt;/code&gt;中。如果当前没有可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;会进入阻塞状态，直至出现新的可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;。只有当存在可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;时才允许创建&lt;code class=&quot;highlighter-rouge&quot;&gt;goroutine&lt;/code&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;(这一点体现在&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule.go&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;line 38&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;line 42&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-4-handling-worker-failures&quot;&gt;Part 4: Handling worker failures&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Part 4&lt;/code&gt;需要解决&lt;code class=&quot;highlighter-rouge&quot;&gt;worker failure&lt;/code&gt;，映射到具体的代码实现上，&lt;code class=&quot;highlighter-rouge&quot;&gt;work failure&lt;/code&gt;是指在进行&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;时，&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;服务器返回了&lt;code class=&quot;highlighter-rouge&quot;&gt;call failed&lt;/code&gt;信息。根据论文，我们只需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;重新分配给另一个可用的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;，并将上次&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;失败的输入文件信息作为本次&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;的参数传递。&lt;/p&gt;

&lt;p&gt;需要注意的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;RPC&lt;/code&gt;失败并不一定意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;崩溃了，也有可能是因为网络原因导致&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;不可达，所以有可能导致多个&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;在执行着相同的&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;。不过由于&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;的幂等性，这并没有什么问题，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;记录着每个&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;对应的真正有效的&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lab 1&lt;/code&gt;的代码实现在&lt;a href=&quot;https://github.com/tinylcy/mit-6.824&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">CSAPP: Bomb Lab</title><link href="http://localhost:4000/2017/CSAPP-Bomb-Lab/" rel="alternate" type="text/html" title="CSAPP: Bomb Lab" /><published>2017-04-27T03:14:51+08:00</published><updated>2017-04-27T03:14:51+08:00</updated><id>http://localhost:4000/2017/CSAPP-Bomb-Lab</id><content type="html" xml:base="http://localhost:4000/2017/CSAPP-Bomb-Lab/">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Bomb Lab&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;CS:APP&lt;/code&gt;一书中第二个&lt;a href=&quot;http://csapp.cs.cmu.edu/3e/bomblab.pdf&quot;&gt;实验&lt;/a&gt;，实验中的&lt;code class=&quot;highlighter-rouge&quot;&gt;bomb&lt;/code&gt;实际上是一个程序的二进制文件，该程序由一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;phase&lt;/code&gt;组成，每个&lt;code class=&quot;highlighter-rouge&quot;&gt;phase&lt;/code&gt;需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印&lt;code class=&quot;highlighter-rouge&quot;&gt;BOOM!!!&lt;/code&gt;。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;完成整个实验的思路是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;bome&lt;/code&gt;进行反编译（&lt;code class=&quot;highlighter-rouge&quot;&gt;objdump -d bomb &amp;gt; bomb.txt&lt;/code&gt;），获取所有的汇编代码。提取每个阶段对应的代码并借助&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;进行分析，逐一拆弹。&lt;/p&gt;

&lt;h2 id=&quot;phase-1&quot;&gt;Phase 1&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_1&lt;/code&gt;对应的代码如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;0000000000400ee0 &amp;lt;phase_1&amp;gt;:
  400ee0: 48 83 ec 08           sub    $0x8,%rsp
  400ee4: be 00 24 40 00        mov    $0x402400,%esi
  400ee9: e8 4a 04 00 00        callq  401338 &amp;lt;strings_not_equal&amp;gt;
  400eee: 85 c0                 test   %eax,%eax
  400ef0: 74 05                 je     400ef7 &amp;lt;phase_1+0x17&amp;gt;
  400ef2: e8 43 05 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  400ef7: 48 83 c4 08           add    $0x8,%rsp
  400efb: c3                    retq  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;callq&lt;/code&gt;指令可以得知，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_1&lt;/code&gt;调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;strings_not_equal&lt;/code&gt;，并将返回值存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;中，&lt;code class=&quot;highlighter-rouge&quot;&gt;test&lt;/code&gt;指令计算&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值是否等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;je&lt;/code&gt;指令决定是否跳转，若&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，则跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400ef7&lt;/code&gt;处，也就是安全区域，拆弹成功，否则不跳转，即执行&lt;code class=&quot;highlighter-rouge&quot;&gt;explode_bomb&lt;/code&gt;，拆弹失败。通过以上分析，可以得知&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_1&lt;/code&gt;的关键在于控制&lt;code class=&quot;highlighter-rouge&quot;&gt;strings_not_equal&lt;/code&gt;的返回值。&lt;/p&gt;

&lt;p&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;callq strings_not_equal&lt;/code&gt;指令之前，&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x402400,%esi&lt;/code&gt;将常数&lt;code class=&quot;highlighter-rouge&quot;&gt;0x402400&lt;/code&gt;传递至&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;寄存器使用规范，&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;strings_not_equal&lt;/code&gt;函数的第二个参数，而第一个参数则是我们输入的值。因此，问题的关键在于如何得到&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;的值。&lt;/p&gt;

&lt;p&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;bomb&lt;/code&gt;进行调试，并在&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_1&lt;/code&gt;处设置断点，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;disassemble&lt;/code&gt;对当前函数进行反编译，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;stepi&lt;/code&gt;对指令进行单步调试，运行至&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_1&lt;/code&gt;第一条指令的初始状态如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在进入&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_1&lt;/code&gt;之前，&lt;code class=&quot;highlighter-rouge&quot;&gt;read_line&lt;/code&gt;函数从终端读取输入（可从&lt;code class=&quot;highlighter-rouge&quot;&gt;bomb.c&lt;/code&gt;得知该信息，我输入的是&lt;code class=&quot;highlighter-rouge&quot;&gt;tinylcy&lt;/code&gt;）。接着，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;stepi&lt;/code&gt;单步执行指令，直至指令&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x402400,%esi&lt;/code&gt;执行完毕，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时，&lt;code class=&quot;highlighter-rouge&quot;&gt;strings_not_equal&lt;/code&gt;函数的第二个参数已经存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt;打印&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;的值，可以得知&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;存储的是一个内存地址，这是因为参数类型是字符串类型，因此寄存器存储的是内存地址，而非确切的字符串值，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;打印位于地址&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;处的内容，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此，我们得到了拆除&lt;code class=&quot;highlighter-rouge&quot;&gt;pahse_1&lt;/code&gt;炸弹所需要的字符串。&lt;/p&gt;

&lt;h2 id=&quot;phase-2&quot;&gt;Phase 2&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_2&lt;/code&gt;对应的代码如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;0000000000400efc &amp;lt;phase_2&amp;gt;:
  400efc: 55                    push   %rbp
  400efd: 53                    push   %rbx
  400efe: 48 83 ec 28           sub    $0x28,%rsp
  400f02: 48 89 e6              mov    %rsp,%rsi
  400f05: e8 52 05 00 00        callq  40145c &amp;lt;read_six_numbers&amp;gt;
  400f0a: 83 3c 24 01           cmpl   $0x1,(%rsp)
  400f0e: 74 20                 je     400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f10: e8 25 05 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f15: eb 19                 jmp    400f30 &amp;lt;phase_2+0x34&amp;gt;
  400f17: 8b 43 fc              mov    -0x4(%rbx),%eax
  400f1a: 01 c0                 add    %eax,%eax
  400f1c: 39 03                 cmp    %eax,(%rbx)
  400f1e: 74 05                 je     400f25 &amp;lt;phase_2+0x29&amp;gt;
  400f20: e8 15 05 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f25: 48 83 c3 04           add    $0x4,%rbx
  400f29: 48 39 eb              cmp    %rbp,%rbx
  400f2c: 75 e9                 jne    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f2e: eb 0c                 jmp    400f3c &amp;lt;phase_2+0x40&amp;gt;
  400f30: 48 8d 5c 24 04        lea    0x4(%rsp),%rbx
  400f35: 48 8d 6c 24 18        lea    0x18(%rsp),%rbp
  400f3a: eb db                 jmp    400f17 &amp;lt;phase_2+0x1b&amp;gt;
  400f3c: 48 83 c4 28           add    $0x28,%rsp
  400f40: 5b                    pop    %rbx
  400f41: 5d                    pop    %rbp
  400f42: c3                    retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;callq read_six_numbers&lt;/code&gt;可知，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_2&lt;/code&gt;调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;read_six_numbers&lt;/code&gt;函数并读取了&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个数值。根据&lt;code class=&quot;highlighter-rouge&quot;&gt;cmpl $0x1,(%rsp)&lt;/code&gt;可知，若地址&lt;code class=&quot;highlighter-rouge&quot;&gt;%rsp&lt;/code&gt;处的值等于&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;，那么进入安全区域，否则就会引爆炸弹。由此可以得知，我们输入的第&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个数字应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;。然后&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_2&lt;/code&gt;跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400f30&lt;/code&gt;处执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;lea 0x4(%rsp),%rbx&lt;/code&gt;，该指令的效果是将&lt;code class=&quot;highlighter-rouge&quot;&gt;%rsp&lt;/code&gt;的值加&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;并存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;，这意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;的值实际上是下一个数的地址值。&lt;code class=&quot;highlighter-rouge&quot;&gt;lea 0x18(%rsp),%rbp&lt;/code&gt;用于控制循环的次数，&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个整型共占用&lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt;字节，恰好等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0x18&lt;/code&gt;。接着&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_2&lt;/code&gt;跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400f17&lt;/code&gt;处执行&lt;code class=&quot;highlighter-rouge&quot;&gt;mov -0x4(%rbx),%eax&lt;/code&gt;指令，该指令的效果是使&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值等于&lt;code class=&quot;highlighter-rouge&quot;&gt;M[%rbx-4]&lt;/code&gt;的值，即&lt;code class=&quot;highlighter-rouge&quot;&gt;M[%rsp]&lt;/code&gt;的值，也就是第&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个数的值。&lt;code class=&quot;highlighter-rouge&quot;&gt;add %eax,%eax&lt;/code&gt;使&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值扩大为原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;倍，&lt;code class=&quot;highlighter-rouge&quot;&gt;cmp %eax,(%rbx)&lt;/code&gt;将下一个数的值与&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值作比较，若相等则跳转至安全区域&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400f25&lt;/code&gt;，否则拆弹失败。&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400f25&lt;/code&gt;处的指令为&lt;code class=&quot;highlighter-rouge&quot;&gt;add $0x4,%rbx&lt;/code&gt;，该指令的效果是使&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;存储下一个数的地址，与&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbp&lt;/code&gt;的值比较并在不相等的情况下跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400f17&lt;/code&gt;处循环执行指令。&lt;/p&gt;

&lt;p&gt;综上，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_2&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;来获取输入的&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个数字，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;来控制比较的数值大小，&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;初始化为第&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个数字的值，并在每次循环后增长至原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;倍，一共&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;次循环。所以&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_2&lt;/code&gt;的解为&lt;code class=&quot;highlighter-rouge&quot;&gt;1 2 4 8 16 32&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;phase-3&quot;&gt;Phase 3&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_3&lt;/code&gt;对应的代码如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;0000000000400f43 &amp;lt;phase_3&amp;gt;:
  400f43: 48 83 ec 18           sub    $0x18,%rsp
  400f47: 48 8d 4c 24 0c        lea    0xc(%rsp),%rcx
  400f4c: 48 8d 54 24 08        lea    0x8(%rsp),%rdx
  400f51: be cf 25 40 00        mov    $0x4025cf,%esi
  400f56: b8 00 00 00 00        mov    $0x0,%eax
  400f5b: e8 90 fc ff ff        callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  400f60: 83 f8 01              cmp    $0x1,%eax
  400f63: 7f 05                 jg     400f6a &amp;lt;phase_3+0x27&amp;gt;
  400f65: e8 d0 04 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  400f6a: 83 7c 24 08 07        cmpl   $0x7,0x8(%rsp)
  400f6f: 77 3c                 ja     400fad &amp;lt;phase_3+0x6a&amp;gt;
  400f71: 8b 44 24 08           mov    0x8(%rsp),%eax
  400f75: ff 24 c5 70 24 40 00  jmpq   *0x402470(,%rax,8)
  400f7c: b8 cf 00 00 00        mov    $0xcf,%eax
  400f81: eb 3b                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f83: b8 c3 02 00 00        mov    $0x2c3,%eax
  400f88: eb 34                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f8a: b8 00 01 00 00        mov    $0x100,%eax
  400f8f: eb 2d                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f91: b8 85 01 00 00        mov    $0x185,%eax
  400f96: eb 26                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f98: b8 ce 00 00 00        mov    $0xce,%eax
  400f9d: eb 1f                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400f9f: b8 aa 02 00 00        mov    $0x2aa,%eax
  400fa4: eb 18                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fa6: b8 47 01 00 00        mov    $0x147,%eax
  400fab: eb 11                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fad: e8 88 04 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fb2: b8 00 00 00 00        mov    $0x0,%eax
  400fb7: eb 05                 jmp    400fbe &amp;lt;phase_3+0x7b&amp;gt;
  400fb9: b8 37 01 00 00        mov    $0x137,%eax
  400fbe: 3b 44 24 0c           cmp    0xc(%rsp),%eax
  400fc2: 74 05                 je     400fc9 &amp;lt;phase_3+0x86&amp;gt;
  400fc4: e8 71 04 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  400fc9: 48 83 c4 18           add    $0x18,%rsp
  400fcd: c3                    retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;条指令非常普通，并不能吸引我们的注意，能够吸引我们的是&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x4025cf,%esi&lt;/code&gt;这条指令，常数&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4025cf&lt;/code&gt;应该是个内存地址，打印该内存地址的值，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很容易把&lt;code class=&quot;highlighter-rouge&quot;&gt;%d %d&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;&lt;/code&gt;这条指令联系起来，由此我们基本知道，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_3&lt;/code&gt;会输入&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;个值。&lt;code class=&quot;highlighter-rouge&quot;&gt;scanf&lt;/code&gt;函数的返回值存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;，该值代表输入值的个数，&lt;code class=&quot;highlighter-rouge&quot;&gt;cmp $0x1,%eax&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值与&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;做比较，如果输入值的个数大于&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;，跳转至安全区域，即指令&lt;code class=&quot;highlighter-rouge&quot;&gt;cmpl $0x7,0x8(%rsp)&lt;/code&gt;处，否则拆弹失败。&lt;code class=&quot;highlighter-rouge&quot;&gt;cmpl   $0x7,0x8(%rsp)&lt;/code&gt;将输入的第一个数(以&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;为例)与&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;作比较，如果大于&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;，那么拆弹失败，否则执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;mov 0x8(%rsp),%eax&lt;/code&gt;，该指令将第一个数存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;中。接着执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;jmpq *0x402470(,%rax,8)&lt;/code&gt;，该指令是一个间接跳转指令，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;得到执行该指令后的跳转位置，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x2aa,%eax&lt;/code&gt;指令将常数&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2aa&lt;/code&gt;移至&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;，然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;jmp 0x400fbe &amp;lt;phase_3+123&amp;gt;&lt;/code&gt;跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400fbe&lt;/code&gt;处执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;cmp 0xc(%rsp),%eax&lt;/code&gt;，该指令将第二个数与&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;做比较，若相等，安全退出，拆弹成功，否则拆弹失败。&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2aa&lt;/code&gt;的十进制值为&lt;code class=&quot;highlighter-rouge&quot;&gt;682&lt;/code&gt;，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_3&lt;/code&gt;输入的两个数应为&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;682&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注意，第一个数并不一定是&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;，只要小于&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;即可。当第一个数的取值改变，那么在获取第二个数时会跳转到不同的分支，因此会得到不同的值。例如当第一个数等于&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;，那么第二个数应为&lt;code class=&quot;highlighter-rouge&quot;&gt;206&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;phase-4&quot;&gt;Phase 4&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;对应的代码如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;000000000040100c &amp;lt;phase_4&amp;gt;:
  40100c: 48 83 ec 18           sub    $0x18,%rsp
  401010: 48 8d 4c 24 0c        lea    0xc(%rsp),%rcx
  401015: 48 8d 54 24 08        lea    0x8(%rsp),%rdx
  40101a: be cf 25 40 00        mov    $0x4025cf,%esi
  40101f: b8 00 00 00 00        mov    $0x0,%eax
  401024: e8 c7 fb ff ff        callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;
  401029: 83 f8 02              cmp    $0x2,%eax
  40102c: 75 07                 jne    401035 &amp;lt;phase_4+0x29&amp;gt;
  40102e: 83 7c 24 08 0e        cmpl   $0xe,0x8(%rsp)
  401033: 76 05                 jbe    40103a &amp;lt;phase_4+0x2e&amp;gt;
  401035: e8 00 04 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  40103a: ba 0e 00 00 00        mov    $0xe,%edx
  40103f: be 00 00 00 00        mov    $0x0,%esi
  401044: 8b 7c 24 08           mov    0x8(%rsp),%edi
  401048: e8 81 ff ff ff        callq  400fce &amp;lt;func4&amp;gt;
  40104d: 85 c0                 test   %eax,%eax
  40104f: 75 07                 jne    401058 &amp;lt;phase_4+0x4c&amp;gt;
  401051: 83 7c 24 0c 00        cmpl   $0x0,0xc(%rsp)
  401056: 74 05                 je     40105d &amp;lt;phase_4+0x51&amp;gt;
  401058: e8 dd 03 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  40105d: 48 83 c4 18           add    $0x18,%rsp
  401061: c3                    retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_3&lt;/code&gt;类似，首先将内存地址为&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4025cf&lt;/code&gt;的内容打印出来，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由此得知，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;的输入应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;个整数。在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;callq  400bf0 &amp;lt;__isoc99_sscanf@plt&amp;gt;&lt;/code&gt;指令后，返回值存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;，然后判断&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值是否等于&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;，若不等于则会引爆炸弹，否则执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;cmpl $0xe,0x8(%rsp)&lt;/code&gt;，该指令将输入的第一个数与常数&lt;code class=&quot;highlighter-rouge&quot;&gt;0xe&lt;/code&gt;做比较，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;jbe 40103a &amp;lt;phase_4+0x2e&amp;gt;&lt;/code&gt;，如果输入的第一个数大于&lt;code class=&quot;highlighter-rouge&quot;&gt;0xe&lt;/code&gt;，那么拆弹失败，否则跳转到&lt;code class=&quot;highlighter-rouge&quot;&gt;0x40103a&lt;/code&gt;处执行&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0xe,%edx&lt;/code&gt;指令。接下来可以看到&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;调用了函数&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0xe,%edx&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x0,%esi&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mov 0x8(%rsp),%edi&lt;/code&gt;这三条指令用于设置&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;的参数，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;寄存器使用规范，第一个、第二个和第三个参数分别存储于寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%edi&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;%edx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在查看&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;对应的代码之前，先观察执行&lt;code class=&quot;highlighter-rouge&quot;&gt;callq  400fce &amp;lt;func4&amp;gt;&lt;/code&gt;指令之后&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;的操作：&lt;code class=&quot;highlighter-rouge&quot;&gt;test %eax,%eax&lt;/code&gt;指令检查&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值是否等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，如果不等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，则会引爆炸弹，否则执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;cmpl $0x0,0xc(%rsp)&lt;/code&gt;，该指令将输入的第二个数与&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;做比较，如果相等，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;正常退出，拆弹成功。因此，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;的第二个输入值即为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;经过以上的分析，可以意识到&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;的核心目标在于要让&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;执行后，&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值等于&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，这取决于输入的第一个数。接着需要分析&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;执行的操作，其对应代码如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;0000000000400fce &amp;lt;func4&amp;gt;:
  400fce: 48 83 ec 08           sub    $0x8,%rsp
  400fd2: 89 d0                 mov    %edx,%eax
  400fd4: 29 f0                 sub    %esi,%eax
  400fd6: 89 c1                 mov    %eax,%ecx
  400fd8: c1 e9 1f              shr    $0x1f,%ecx
  400fdb: 01 c8                 add    %ecx,%eax
  400fdd: d1 f8                 sar    %eax
  400fdf: 8d 0c 30              lea    (%rax,%rsi,1),%ecx
  400fe2: 39 f9                 cmp    %edi,%ecx
  400fe4: 7e 0c                 jle    400ff2 &amp;lt;func4+0x24&amp;gt;
  400fe6: 8d 51 ff              lea    -0x1(%rcx),%edx
  400fe9: e8 e0 ff ff ff        callq  400fce &amp;lt;func4&amp;gt;
  400fee: 01 c0                 add    %eax,%eax
  400ff0: eb 15                 jmp    401007 &amp;lt;func4+0x39&amp;gt;
  400ff2: b8 00 00 00 00        mov    $0x0,%eax
  400ff7: 39 f9                 cmp    %edi,%ecx
  400ff9: 7d 0c                 jge    401007 &amp;lt;func4+0x39&amp;gt;
  400ffb: 8d 71 01              lea    0x1(%rcx),%esi
  400ffe: e8 cb ff ff ff        callq  400fce &amp;lt;func4&amp;gt;
  401003: 8d 44 00 01           lea    0x1(%rax,%rax,1),%eax
  401007: 48 83 c4 08           add    $0x8,%rsp
  40100b: c3                    retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在分析&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;之前，不要忘了传递到&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;的三个参数分别存储于寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;%edi&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;%esi&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;%edx&lt;/code&gt;，其值分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;(输入的第一个数)、&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;14&lt;/code&gt;。在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400fe9&lt;/code&gt;处执行了指令&lt;code class=&quot;highlighter-rouge&quot;&gt;callq 400fce &amp;lt;func4&amp;gt;&lt;/code&gt;，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;很可能是个递归函数，我们将&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;翻译成等价的&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;代码，如下所示。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;func4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;的目的是要让函数退出后&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，而在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x400ff2&lt;/code&gt;处&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x0,%eax&lt;/code&gt;显示的将&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;的值设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，该指令对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;代码中的&lt;code class=&quot;highlighter-rouge&quot;&gt;t = 0&lt;/code&gt;。并且，&lt;code class=&quot;highlighter-rouge&quot;&gt;func4&lt;/code&gt;执行递归的退出条件为&lt;code class=&quot;highlighter-rouge&quot;&gt;k == x&lt;/code&gt;，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;对应于输入的第一个数，而&lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;则可以通过一系列计算得到，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;y = 0&lt;/code&gt;且&lt;code class=&quot;highlighter-rouge&quot;&gt;z = 14&lt;/code&gt;，易知&lt;code class=&quot;highlighter-rouge&quot;&gt;k = 7&lt;/code&gt;，因此输入的第一个数即为&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;。将字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;7 0&lt;/code&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_4&lt;/code&gt;的输入，拆弹成功，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;phase-5&quot;&gt;Phase 5&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_5&lt;/code&gt;对应的代码如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;0000000000401062 &amp;lt;phase_5&amp;gt;:
  401062: 53                    push   %rbx
  401063: 48 83 ec 20           sub    $0x20,%rsp
  401067: 48 89 fb              mov    %rdi,%rbx
  40106a: 64 48 8b 04 25 28 00  mov    %fs:0x28,%rax
  401071: 00 00 
  401073: 48 89 44 24 18        mov    %rax,0x18(%rsp)
  401078: 31 c0                 xor    %eax,%eax
  40107a: e8 9c 02 00 00        callq  40131b &amp;lt;string_length&amp;gt;
  40107f: 83 f8 06              cmp    $0x6,%eax
  401082: 74 4e                 je     4010d2 &amp;lt;phase_5+0x70&amp;gt;
  401084: e8 b1 03 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  401089: eb 47                 jmp    4010d2 &amp;lt;phase_5+0x70&amp;gt;
  40108b: 0f b6 0c 03           movzbl (%rbx,%rax,1),%ecx
  40108f: 88 0c 24              mov    %cl,(%rsp)
  401092: 48 8b 14 24           mov    (%rsp),%rdx
  401096: 83 e2 0f              and    $0xf,%edx
  401099: 0f b6 92 b0 24 40 00  movzbl 0x4024b0(%rdx),%edx
  4010a0: 88 54 04 10           mov    %dl,0x10(%rsp,%rax,1)
  4010a4: 48 83 c0 01           add    $0x1,%rax
  4010a8: 48 83 f8 06           cmp    $0x6,%rax
  4010ac: 75 dd                 jne    40108b &amp;lt;phase_5+0x29&amp;gt;
  4010ae: c6 44 24 16 00        movb   $0x0,0x16(%rsp)
  4010b3: be 5e 24 40 00        mov    $0x40245e,%esi
  4010b8: 48 8d 7c 24 10        lea    0x10(%rsp),%rdi
  4010bd: e8 76 02 00 00        callq  401338 &amp;lt;strings_not_equal&amp;gt;
  4010c2: 85 c0                 test   %eax,%eax
  4010c4: 74 13                 je     4010d9 &amp;lt;phase_5+0x77&amp;gt;
  4010c6: e8 6f 03 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  4010cb: 0f 1f 44 00 00        nopl   0x0(%rax,%rax,1)
  4010d0: eb 07                 jmp    4010d9 &amp;lt;phase_5+0x77&amp;gt;
  4010d2: b8 00 00 00 00        mov    $0x0,%eax
  4010d7: eb b2                 jmp    40108b &amp;lt;phase_5+0x29&amp;gt;
  4010d9: 48 8b 44 24 18        mov    0x18(%rsp),%rax
  4010de: 64 48 33 04 25 28 00  xor    %fs:0x28,%rax
  4010e5: 00 00 
  4010e7: 74 05                 je     4010ee &amp;lt;phase_5+0x8c&amp;gt;
  4010e9: e8 42 fa ff ff        callq  400b30 &amp;lt;__stack_chk_fail@plt&amp;gt;
  4010ee: 48 83 c4 20           add    $0x20,%rsp
  4010f2: 5b                    pop    %rbx
  4010f3: c3                    retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;寄存器使用规范，&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;寄存器存储的是第一个参数的值，由于输入的是字符串，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdi&lt;/code&gt;存储的应该是输入字符串的起始地址。&lt;code class=&quot;highlighter-rouge&quot;&gt;0x401067&lt;/code&gt;处的指令&lt;code class=&quot;highlighter-rouge&quot;&gt;mov %rdi,%rbx&lt;/code&gt;将字符串起始地址保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;中，即&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;为基址寄存器。指令&lt;code class=&quot;highlighter-rouge&quot;&gt;xor %eax,%eax&lt;/code&gt;的作用是将&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;清零，接着调用&lt;code class=&quot;highlighter-rouge&quot;&gt;string_length&lt;/code&gt;函数获取输入字符串的长度，并将长度值（返回值）存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%eax&lt;/code&gt;。指令&lt;code class=&quot;highlighter-rouge&quot;&gt;cmp $0x6,%eax&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;string_length&lt;/code&gt;的返回值与常数&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;作比较，若不相等则会引爆炸弹，由此可以得知，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_5&lt;/code&gt;的输入字符串长度应该等于&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当输入字符串的长度等于&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_5&lt;/code&gt;跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4010d2&lt;/code&gt;处执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x0,%eax&lt;/code&gt;，接着又跳转至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x40108b&lt;/code&gt;处执行指令&lt;code class=&quot;highlighter-rouge&quot;&gt;movzbl (%rbx,%rax,1),%ecx&lt;/code&gt;，可以发现&lt;code class=&quot;highlighter-rouge&quot;&gt;0x40108b&lt;/code&gt;至&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4010ac&lt;/code&gt;构成了一个循环，且在循环退出后在&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4010bd&lt;/code&gt;处调动了&lt;code class=&quot;highlighter-rouge&quot;&gt;strings_not_equal&lt;/code&gt;来比较字符串是否相等，若相等，则拆弹成功。其中，由&lt;code class=&quot;highlighter-rouge&quot;&gt;mov $0x40245e,%esi&lt;/code&gt;指令可知，待比较的字符串存储于地址&lt;code class=&quot;highlighter-rouge&quot;&gt;0x40245e&lt;/code&gt;处，打印以该地址作为起始地址的字符串，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;待比较的字符串为&lt;code class=&quot;highlighter-rouge&quot;&gt;flyers&lt;/code&gt;，且长度也为&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;。所以，接下来的关键任务是需要对循环操作进行分析，理解该循环操作对输入字符串做了哪些操作。提取循环操作的代码，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;  40108b: 0f b6 0c 03           movzbl (%rbx,%rax,1),%ecx
  40108f: 88 0c 24              mov    %cl,(%rsp)
  401092: 48 8b 14 24           mov    (%rsp),%rdx
  401096: 83 e2 0f              and    $0xf,%edx
  401099: 0f b6 92 b0 24 40 00  movzbl 0x4024b0(%rdx),%edx
  4010a0: 88 54 04 10           mov    %dl,0x10(%rsp,%rax,1)
  4010a4: 48 83 c0 01           add    $0x1,%rax
  4010a8: 48 83 f8 06           cmp    $0x6,%rax
  4010ac: 75 dd                 jne    40108b &amp;lt;phase_5+0x29&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;%rbx&lt;/code&gt;存储的是输入字符串的起始地址，&lt;code class=&quot;highlighter-rouge&quot;&gt;%rax&lt;/code&gt;初始化为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;，其作用等价于下标，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;movzbl (%rbx,%rax,1),%ecx&lt;/code&gt;指令的作用是将字符串的第&lt;code class=&quot;highlighter-rouge&quot;&gt;%rax&lt;/code&gt;个字符存储于&lt;code class=&quot;highlighter-rouge&quot;&gt;%ecx&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;movzbl&lt;/code&gt;意味做了零扩展。接着，&lt;code class=&quot;highlighter-rouge&quot;&gt;mov  %cl,(%rsp)&lt;/code&gt;指令取&lt;code class=&quot;highlighter-rouge&quot;&gt;%ecx&lt;/code&gt;的低&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位，即一个字符的大小，通过内存间接存储至&lt;code class=&quot;highlighter-rouge&quot;&gt;%rdx&lt;/code&gt;中。&lt;code class=&quot;highlighter-rouge&quot;&gt;and  $0xf,%edx&lt;/code&gt;指令将&lt;code class=&quot;highlighter-rouge&quot;&gt;%edx&lt;/code&gt;的值与常数&lt;code class=&quot;highlighter-rouge&quot;&gt;0xf&lt;/code&gt;进行位与，由指令&lt;code class=&quot;highlighter-rouge&quot;&gt;movzbl 0x4024b0(%rdx),%edx&lt;/code&gt;可知，位与后的值将会作为偏移量，以&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4024b0&lt;/code&gt;为基址，将偏移后的值存储至&lt;code class=&quot;highlighter-rouge&quot;&gt;%edx&lt;/code&gt;。最后，指令&lt;code class=&quot;highlighter-rouge&quot;&gt;mov %dl,0x10(%rsp,%rax,1)&lt;/code&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;%edx&lt;/code&gt;低&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位的值作为新的字符，对原有字符进行替换。&lt;/p&gt;

&lt;p&gt;综上，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_5&lt;/code&gt;遍历输入字符串的每个字符，将字符的低&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;位作为偏移量，以&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4024b0&lt;/code&gt;为起始地址，将新地址对应的字符替换原有字符，最终得到&lt;code class=&quot;highlighter-rouge&quot;&gt;flyers&lt;/code&gt;字符串。打印&lt;code class=&quot;highlighter-rouge&quot;&gt;0x4024b0&lt;/code&gt;处的内容，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;例如，如果要得到字符&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;，那么偏移量应为&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;，二进制表示为&lt;code class=&quot;highlighter-rouge&quot;&gt;1001&lt;/code&gt;，通过查找&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;表，可知字符&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;编码为&lt;code class=&quot;highlighter-rouge&quot;&gt;01101001&lt;/code&gt;，满足要求。剩余&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;个字符采用同样的策略可以依次求得，最终，&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_5&lt;/code&gt;的输入字符串为&lt;code class=&quot;highlighter-rouge&quot;&gt;ionefg&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;phase-6&quot;&gt;Phase 6&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_6&lt;/code&gt;对应的代码非常长，如下所示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;00000000004010f4 &amp;lt;phase_6&amp;gt;:
  4010f4: 41 56                 push   %r14
  4010f6: 41 55                 push   %r13
  4010f8: 41 54                 push   %r12
  4010fa: 55                    push   %rbp
  4010fb: 53                    push   %rbx
  4010fc: 48 83 ec 50           sub    $0x50,%rsp
  401100: 49 89 e5              mov    %rsp,%r13
  401103: 48 89 e6              mov    %rsp,%rsi
  401106: e8 51 03 00 00        callq  40145c &amp;lt;read_six_numbers&amp;gt;
  40110b: 49 89 e6              mov    %rsp,%r14               # %r14存储数组起始地址
  40110e: 41 bc 00 00 00 00     mov    $0x0,%r12d              # 将%r12d初始化为0
  
  #################### Section 1:确认数组中所有的元素小于等于6且不存在重复值 ###################
  401114: 4c 89 ed              mov    %r13,%rbp               # %r13和%rbp存储数组某个元素的地址，并不是第1个元素，意识到这点需要结合0x40114d处的指令
  401117: 41 8b 45 00           mov    0x0(%r13),%eax          # %eax存储第%r13个数
  40111b: 83 e8 01              sub    $0x1,%eax               # 将%eax的值减1
  40111e: 83 f8 05              cmp    $0x5,%eax               # 将%eax的值与常数5做比较
  401121: 76 05                 jbe    401128 &amp;lt;phase_6+0x34&amp;gt;
  401123: e8 12 03 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  401128: 41 83 c4 01           add    $0x1,%r12d              # 如果%eax的值小于等于5，%r12d加1
  40112c: 41 83 fc 06           cmp    $0x6,%r12d              # 将%r12d与常数6做比较
  401130: 74 21                 je     401153 &amp;lt;phase_6+0x5f&amp;gt;
  401132: 44 89 e3              mov    %r12d,%ebx              # %ebx起了数组下标的作用
  
  # 用于判断数组6个数是否存在重复值，若存在，引爆炸弹
  401135: 48 63 c3              movslq %ebx,%rax               # 将数组下标存储至%rax
  401138: 8b 04 84              mov    (%rsp,%rax,4),%eax      # 将下一个数存储至%eax
  40113b: 39 45 00              cmp    %eax,0x0(%rbp)          # 将第1个数与%eax的值(当前数)做比较
  40113e: 75 05                 jne    401145 &amp;lt;phase_6+0x51&amp;gt;   # 若相等，引爆炸弹   
  401140: e8 f5 02 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  401145: 83 c3 01              add    $0x1,%ebx               # 数组下标加1            
  401148: 83 fb 05              cmp    $0x5,%ebx               # 判断数组下标是否越界(&amp;lt;=5)
  40114b: 7e e8                 jle    401135 &amp;lt;phase_6+0x41&amp;gt;
  
  40114d: 49 83 c5 04           add    $0x4,%r13               # %r13存储数组下一个数的地址
  401151: eb c1                 jmp    401114 &amp;lt;phase_6+0x20&amp;gt;
  ####################################### Section 1 end ######################################
  
  ################ Section 2：用7减去数组的每个元素，并将相减后的元素替换原有元素 #################
  401153: 48 8d 74 24 18        lea    0x18(%rsp),%rsi         # 0x18(%rsp)是数组的边界地址：0x18 = 24         
  401158: 4c 89 f0              mov    %r14,%rax               # 将数组起始地址存储于%rax
  40115b: b9 07 00 00 00        mov    $0x7,%ecx
  
  401160: 89 ca                 mov    %ecx,%edx               # %edx = 7
  401162: 2b 10                 sub    (%rax),%edx             # %edx = 7 - 数组元素
  401164: 89 10                 mov    %edx,(%rax)             # 用相减后的元素(%edx)替换原有元素
  401166: 48 83 c0 04           add    $0x4,%rax               # %rax存储数组下一个元素的地址
  40116a: 48 39 f0              cmp    %rsi,%rax               # 判断是否越界
  40116d: 75 f1                 jne    401160 &amp;lt;phase_6+0x6c&amp;gt;
  ####################################### Section 2 end ######################################
  
  ########################## Section 3：根据输入数组重排结构体数组 ##############################
  40116f: be 00 00 00 00        mov    $0x0,%esi               # 将%esi初始化为0，作为数组下标
  401174: eb 21                 jmp    401197 &amp;lt;phase_6+0xa3&amp;gt;
  
  401176: 48 8b 52 08           mov    0x8(%rdx),%rdx          # 0x8(%rdx)为下一个元素的地址
  40117a: 83 c0 01              add    $0x1,%eax               
  40117d: 39 c8                 cmp    %ecx,%eax               # %ecx存储了数组当前值(第%esi个元素)
  40117f: 75 f5                 jne    401176 &amp;lt;phase_6+0x82&amp;gt;
  
  401181: eb 05                 jmp    401188 &amp;lt;phase_6+0x94&amp;gt;
  401183: ba d0 32 60 00        mov    $0x6032d0,%edx          # %edx存储结构体数组第1个元素的地址
  401188: 48 89 54 74 20        mov    %rdx,0x20(%rsp,%rsi,2)  # %rsi的初始值为0；该指令的作用是将结构体数组的第%ecx个元素的地址存储在内存的某个位置(以%rsp + 0x20为基地址，%rsi为偏移量)
  40118d: 48 83 c6 04           add    $0x4,%rsi               # 增加偏移量
  401191: 48 83 fe 18           cmp    $0x18,%rsi
  401195: 74 14                 je     4011ab &amp;lt;phase_6+0xb7&amp;gt;
  401197: 8b 0c 34              mov    (%rsp,%rsi,1),%ecx      # %ecx存储数组第%esi个元素
  40119a: 83 f9 01              cmp    $0x1,%ecx               # 将数组第%esi个元素与常数1做比较
  40119d: 7e e4                 jle    401183 &amp;lt;phase_6+0x8f&amp;gt;   # 实际上不会小于1，如果数组的第1个元素等于1，那么跳转至0x401183处
  40119f: b8 01 00 00 00        mov    $0x1,%eax
  4011a4: ba d0 32 60 00        mov    $0x6032d0,%edx          # %edx存储结构体数组第1个元素的地址
  4011a9: eb cb                 jmp    401176 &amp;lt;phase_6+0x82&amp;gt;
  ####################################### Section 3 end ######################################
  
  ######################### Section 4：修改结构体数组元素的next域值 #############################
  4011ab: 48 8b 5c 24 20        mov    0x20(%rsp),%rbx         # %rbx存储地址数组的第1个元素的值
  4011b0: 48 8d 44 24 28        lea    0x28(%rsp),%rax         # %rax存储地址数组的第2个元素的地址
  4011b5: 48 8d 74 24 50        lea    0x50(%rsp),%rsi
  4011ba: 48 89 d9              mov    %rbx,%rcx               # %rcx存储地址数组的第1个元素的值
  
  # 下面用i和i+1来表示元素位置
  4011bd: 48 8b 10              mov    (%rax),%rdx             # %rdx存储地址数组的第i+1个元素的值
  4011c0: 48 89 51 08           mov    %rdx,0x8(%rcx)          # 把第i+1和元素的值存储于第i个结构体元素的next域中，next域的地址为0x8(%rcx)的值
  4011c4: 48 83 c0 08           add    $0x8,%rax
  4011c8: 48 39 f0              cmp    %rsi,%rax
  4011cb: 74 05                 je     4011d2 &amp;lt;phase_6+0xde&amp;gt;
  4011cd: 48 89 d1              mov    %rdx,%rcx
  4011d0: eb eb                 jmp    4011bd &amp;lt;phase_6+0xc9&amp;gt;
  ####################################### Section 4 end ######################################
  
  ######################### Section 5：判断结构体数组是否是递减序列 #############################
  4011d2: 48 c7 42 08 00 00 00  movq   $0x0,0x8(%rdx)
  4011d9: 00 
  4011da: bd 05 00 00 00        mov    $0x5,%ebp
  4011df: 48 8b 43 08           mov    0x8(%rbx),%rax
  4011e3: 8b 00                 mov    (%rax),%eax
  4011e5: 39 03                 cmp    %eax,(%rbx)
  4011e7: 7d 05                 jge    4011ee &amp;lt;phase_6+0xfa&amp;gt;
  4011e9: e8 4c 02 00 00        callq  40143a &amp;lt;explode_bomb&amp;gt;
  4011ee: 48 8b 5b 08           mov    0x8(%rbx),%rbx
  4011f2: 83 ed 01              sub    $0x1,%ebp
  4011f5: 75 e8                 jne    4011df &amp;lt;phase_6+0xeb&amp;gt;
  ####################################### Section 5 end ######################################
  
  4011f7: 48 83 c4 50           add    $0x50,%rsp
  4011fb: 5b                    pop    %rbx
  4011fc: 5d                    pop    %rbp
  4011fd: 41 5c                 pop    %r12
  4011ff: 41 5d                 pop    %r13
  401201: 41 5e                 pop    %r14
  401203: c3                    retq   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析清楚&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_6&lt;/code&gt;非常需要耐心，我将&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_6&lt;/code&gt;划分为&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;Section&lt;/code&gt;，每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Section&lt;/code&gt;完成特定的功能，详细的注释直接附到了相关代码。前两个&lt;code class=&quot;highlighter-rouge&quot;&gt;Section&lt;/code&gt;不难理解：&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 1&lt;/code&gt;确保输入数组的值的范围在&lt;code class=&quot;highlighter-rouge&quot;&gt;1 ~ 6&lt;/code&gt;且不存在重复值；&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 2&lt;/code&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;减去输入数组的每个元素，相当于求补。&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 3&lt;/code&gt;中出现了一个常数地址，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;gdb&lt;/code&gt;将该地址存储的内容打印出来，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以意识到这其实是一个链表数据结构，链表的节点由&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;部分组成：&lt;code class=&quot;highlighter-rouge&quot;&gt;value 1&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;value 2&lt;/code&gt;和一个地址值(&lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;域，指向下一个节点)。&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 3&lt;/code&gt;根据我们输入的数组，按照数组元素的值将对应结构体数组中的元素的首地址存储到内存的某个位置(&lt;code class=&quot;highlighter-rouge&quot;&gt;mov %rdx,0x20(%rsp,%rsi,2)&lt;/code&gt;)。例如，假设输入数组为&lt;code class=&quot;highlighter-rouge&quot;&gt;[3, 4, 5, 6, 1, 2]&lt;/code&gt;，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 3&lt;/code&gt;首先会将结构体数组的第&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;个元素的地址存储到&lt;code class=&quot;highlighter-rouge&quot;&gt;0x20(%rsp,%rsi,2)&lt;/code&gt;处，接着将结构体数组的第&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个元素……依次类推。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 4&lt;/code&gt;根据&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 3&lt;/code&gt;构建的地址数组，修改结构体数组的&lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;域的值，实现单链表的排序操作。&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 5&lt;/code&gt;进行验证，要求单链表递减排序，若满足要求，那么拆弹成功。&lt;/p&gt;

&lt;p&gt;综上，根据已有的结构体数组以及&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_6&lt;/code&gt;的操作，若要实现单链表的递减排序，应将第&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;个节点放在第&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;位，将第&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个节点放在第&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;位……最终得到序列：&lt;code class=&quot;highlighter-rouge&quot;&gt;[3, 4, 5, 6, 1, 2]&lt;/code&gt;。不要忘记&lt;code class=&quot;highlighter-rouge&quot;&gt;Section 2&lt;/code&gt;中的求补操作，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;phase_6&lt;/code&gt;的输入序列应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;[4, 3, 2, 1, 6, 5]&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;至此，&lt;code class=&quot;highlighter-rouge&quot;&gt;Bomb Lab&lt;/code&gt;包含了&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个&lt;code class=&quot;highlighter-rouge&quot;&gt;phase&lt;/code&gt;全部拆弹成功。将输入序列存储在文件，然后将文件作为&lt;code class=&quot;highlighter-rouge&quot;&gt;bomb&lt;/code&gt;二进制文件的参数，运行结果如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/img-2017-04-26-Image 10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="CSAPP" /><category term="Assembly" /><summary type="html">Bomb Lab是CS:APP一书中第二个实验，实验中的bomb实际上是一个程序的二进制文件，该程序由一系列phase组成，每个phase需要我们输入一个字符串，然后该程序会进行校验，如果输入的字符串不满足拆弹要求，那么就会打印BOOM!!!。</summary></entry></feed>