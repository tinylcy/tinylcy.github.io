<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>TCP拥塞控制 | tinylcy</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">TCP拥塞控制</h1><a id="logo" href="/.">tinylcy</a><p class="description">辰洋的博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="https://github.com/tinylcy"><i class="fa fa-github"> GitHub</i></a><a href="mailto:tinylcy@gmail.com"><i class="fa fa-envelope"> Email</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">TCP拥塞控制</h1><div class="post-meta">Aug 14, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><h2 id="TCP基础"><a href="#TCP基础" class="headerlink" title="TCP基础"></a>TCP基础</h2><p>网络的传输层有两种方式——<code>TCP</code>和<code>UDP</code>，其中<code>TCP</code>是基于连接的，而<code>UDP</code>不需要连接。它们各自支持一些应用层协议，但也有些协议是两者都支持的，比如<code>DNS</code>，我们通过<code>DNS</code>来比较<code>TCP</code>和<code>UDP</code>的差别。当前我的计算机的<code>ip</code>为<code>192.168.199.134</code>，向<code>DNS</code>服务器发起一个<code>DNS</code>查询，以期获得<code>tinylcy.me</code>所对应的<code>ip</code>地址。<code>DNS</code>默认使用<code>UDP</code>的情况如下所示：</p>
<p><img src="/img/2016-08-14-Image 1.png" alt="Alt text"></p>
<p>通过<code>Wireshark</code>抓取这个过程的网络包，如下所示：</p>
<p><img src="/img/2016-08-14-Image 2.png" alt="Alt text"></p>
<p>使用<code>set vc</code>强制<code>DNS</code>使用<code>TCP</code>：</p>
<p><img src="/img/2016-08-14-Image 3.png" alt="Alt text"></p>
<p>这个过程所有的网络包如下所示：</p>
<p><img src="/img/2016-08-14-Image 4.png" alt="Alt text"></p>
<p>从以上两种情况可以得知，真正起查询作用的只有两个<code>DNS</code>包。在使用<code>UDP</code>的情况下，确实只需要两个包就可以完成<code>DNS</code>查询，但是在使用<code>TCP</code>时，要先用<code>3</code>个包来建立连接。可以看到，如果<code>DNS</code>使用<code>TCP</code>，那么连接的成本将会远远大于<code>DNS</code>查询本身，这对于繁忙的<code>DNS</code>服务器来说无疑是巨大的压力，因此，<code>DNS</code>服务器默认使用<code>UDP</code>来传输数据。</p>
<p>但是大多数应用层协议还是基于<code>TCP</code>，因为<code>TCP</code>可靠的连接带来的好处更多。首先，需要理解几个重要的<code>TCP</code>参数。</p>
<ul>
<li><code>Seq</code>：表示数据段的序号。<code>TCP</code>提供有序的传输，所以每个数据包都要标上一个序号。当接收方收到乱序的包时，有了这个序号就可以重新排序了。如下图所示，数据包<code>6</code>的起始序号为<code>1</code>，长度为<code>20</code>，那么数据包<code>7</code>的<code>Seq</code>号即为<code>1 + 20 = 21</code>。数据段<code>7</code>的长度为<code>433</code>，所以数据包<code>8</code>的<code>Seq</code>为<code>21 + 433 = 454</code>。</li>
</ul>
<p><img src="/img/2016-08-14-Image 5.png" alt="Alt text"></p>
<ul>
<li><code>Len</code>：对应数据包的长度，注意这个长度不包括<code>TCP</code>头，很多情况下，包的<code>Len = 0</code>，但其实是有<code>TCP</code>头的，并且头部携带的信息量还很大。</li>
<li><code>Ack</code>：确认号，如下图所示，数据段<code>91</code>的<code>Seq = 438</code>，<code>Len = 20</code>，来自接收方的<code>92</code>号数据包的<code>Ack = 438 + 20 = 458</code>，表示收到了之前的<code>458</code>字节。理论上，接收方回复的<code>Ack</code>号恰好等于发送方的下一个<code>Seq</code>号，所以可以看到<code>93</code>号数据包的<code>Seq = 458</code>。</li>
</ul>
<p><img src="/img/2016-08-14-Image 6.png" alt="Alt text"></p>
<p>由于网络传输的不确定性，因此接收方收到的数据包往往是乱序的，此时，接收方只需要根据<code>Seq</code>号从小到大重新排序就好了，这样就保证了<code>TCP</code>的有序性。若存在数据包的丢失，接收方通过前一个<code>Seq + Len</code>的值与下一个<code>Seq</code>的差，就能判断丢失了哪些包，这保证了<code>TCP</code>的可靠性。</p>
<h2 id="TCP窗口"><a href="#TCP窗口" class="headerlink" title="TCP窗口"></a>TCP窗口</h2><p><code>TCP</code>传输数据包之后，需要等待确认包是否到达，这样就花费了一个往返时间。如果每发送一个包就停下来确认，那么在一个往返时间只能发送一个包，这样的传输效率太低。最快的方式就是一次把所有的包全部发送出去，然后一起确认，但是现实存在着限制：接收方的缓存（接收窗口）可能一下子接受不了这么多数据；网络带宽也不一定足够大，一次发太多数据会导致丢包事故。因此，发送方要知道接收方的接收窗口和网络这两个限制因素哪一个更加严格然后在其限制范围内尽可能的多发包。这个一口气能够发送的数据量就是所谓的<code>TCP</code>发送窗口。</p>
<h3 id="Window-size-value"><a href="#Window-size-value" class="headerlink" title="Window size value"></a>Window size value</h3><p>如下图所示，每个包的<code>TCP</code>层都含有<code>Window size value</code>，这个值并不是指发送窗口的大小，而是在向对方声明自己的接收窗口。</p>
<p><img src="/img/2016-08-14-Image 7.png" alt="Alt text"></p>
<p><code>151.101.24.133</code>向<code>192.168.199.134</code>声明自己的接收窗口是<code>28800</code>字节，<code>192.168.199.134</code>收到之后，就会把自己的发送窗口限制在<code>28800</code>字节内。</p>
<h3 id="发送窗口大小"><a href="#发送窗口大小" class="headerlink" title="发送窗口大小"></a>发送窗口大小</h3><p>如果发送窗口的大小由接收窗口决定，那么可以通过<code>Window size value</code>来判断，而当发送窗口的大小由网络因素决定，事情就会变得很复杂。大多数时候，甚至不确定哪个因素在起作用，只能大概推理。如果接收窗口的大小声明为<code>0</code>，那么接收窗口肯定会起作用，因为不能再小了，可以推断对应的发送方的发送窗口就为<code>0</code>。</p>
<h3 id="发送窗口和MSS"><a href="#发送窗口和MSS" class="headerlink" title="发送窗口和MSS"></a>发送窗口和MSS</h3><p>发送窗口决定一次能够发送的字节数，而<code>MSS</code>决定了这些字节需要分多少个包才能发完。举例：在发送窗口为<code>16000</code>字节的情况下，如果<code>MSS</code>是<code>1000</code>字节，那么需要发送<code>16</code>个包；如果<code>MSS</code>为<code>8000</code>字节，那么发送的包数即为<code>2</code>。</p>
<h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><p>网络之所以要限制发送窗口，是因为一次收到太多数据就会拥塞，拥塞的结果就是丢包，能导致网络拥塞的数据流称为拥塞点。发送方希望能够把发送窗口的控制在拥塞点以下，但是网络设备并不知道自己的拥塞点，即便知道了也无法通知给发送方。</p>
<p>目前并没有完美的解决方案，相对靠谱的策略是在发送方维护一个虚拟的拥塞窗口，并利用算法使它尽可能的接近真实的拥塞点，网络对发送窗口的限制，就是通过拥塞窗口来实现的。</p>
<ul>
<li>连接刚刚建立，发送方对网络状况一无所知。如果一次发送太多的数据就可能遭遇拥塞，所以把发送方的拥塞窗口初始值定的很小，RFC的建议是<code>2</code>个、<code>3</code>个或者<code>4</code>个<code>MSS</code>。</li>
<li>用过发出去的包都得到确认，表明还没有到达拥塞点，可以增大拥塞窗口。由于这个阶段发送拥塞的概率很低，所以增速可以快一些。<code>RFC</code>建议的算法是每收到<code>n</code>个确认，可以把拥塞窗口增加<code>n</code>个<code>MSS</code>。这个过程的增速很快，但是由于基数低，传输速度还是比较慢的，所以被称为慢启动过程。</li>
<li>慢启动过程持续一段时间后，拥塞窗口达到一个较大的值。这时候传输速度比较快，触碰拥塞点的概率也大了，所以不能再采用翻倍的慢启动算法了，而是要更加缓慢一些。<code>RFC</code>建议是每个往返时间增加一个<code>MSS</code>。这个过程被称为拥塞避免。从慢启动过渡到拥塞避免的临界窗口值很有讲究。如果之前发生过拥塞，那么就把该拥塞点作为参考依据，如果从来没有发生过拥塞就可以取相对较大的值，比如和最大接收窗口相等。</li>
</ul>
<p>拥塞之后，对于发送方来说就是发出去的包得不到确认了，不过收不到确认也可能是网络延迟导致，所以发送方会等待一会儿再判断，如果迟迟收不到，那么就认定包已经丢失，只能重传了。这个过程被称为超时重传。从发出原始包到重传该包的时间被称为<code>RTO</code>。</p>
<p>重传之后的拥塞窗口非常有必要调整，<code>RFC</code>建议把拥塞窗口下降到<code>1</code>个<code>MSS</code>，然后再次进入慢启动过程。这一次从慢启动过程过渡到拥塞避免的临界窗口值就有参考依据了。<code>RFC</code>建议临界窗口值为发生拥塞时没被确认的数据量的<code>1/2</code>，但是不能小于<code>2</code>个<code>MSS</code>。</p>
<p>下图模拟了慢启动和拥塞避免两个过程，并且在此期间发生了超时重传。<br><img src="/img/2016-08-14-Image 8.png" alt="Alt text"></p>
<p>可以看到超时重传对传输性能有着严重影响。因为<code>RTO</code>阶段没有传输数据，相当于浪费了一段时间，并且拥塞敞口急剧减小，相当于接下来传的慢多了。</p>
<p>有时候拥塞很轻微，只有少量的包丢失，还有一些偶然因素，比如校验码不对，也会导致单个丢包。但是这种丢包和严重拥塞时的丢包并不一样，因为后续有包正常到达。当后续的包到达接收方时，会发现其<code>Seq</code>比期望的大，所以接收方每收到一个包就<code>Ack</code>一次期望的<code>Seq</code>号。当发送方收到<code>3</code>个或者以上的重复确认（<code>Dup Ack</code>）时，就意识到相应的包已经丢失了，因此立即重传它。这个过程被称为快速重传。之所以称为快速，是因为它不需要像超时重传那样等待一段时间。</p>
<p>前面提到发送方在收到<code>3</code>个或者以上的<code>Dup Ack</code>时才会启动快速重传，这是因为网络包有时会乱序，乱序的包也会导致触发重复的<code>Ack</code>，但是没有必要为了乱序而重传。由于一般乱序的距离不会相差太大，所以限定成<code>3</code>个 或者以上可以很大程度上避免因为乱序而出发快速重传。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://book.douban.com/subject/26268767/" target="_blank" rel="external">Wireshark网络分析就这么简单</a></p>
</div><div class="tags"><a href="/tags/TCP-IP/">TCP/IP</a></div><div class="post-nav"><a href="/2016/07/30/目录与文件属性：编写ls/" class="pre">目录与文件属性：编写ls</a><a href="/2016/08/19/IO重定向和管道/" class="next">I/O重定向和管道</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/JDK/" style="font-size: 15px;">JDK</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/CSAPP/" style="font-size: 15px;">CSAPP</a> <a href="/tags/Unix-Linux/" style="font-size: 15px;">Unix/Linux</a> <a href="/tags/Distributed-System/" style="font-size: 15px;">Distributed System</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/TCP-IP/" style="font-size: 15px;">TCP/IP</a> <a href="/tags/Golang/" style="font-size: 15px;">Golang</a> <a href="/tags/Assembly/" style="font-size: 15px;">Assembly</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://wdxtub.com/" title="wdxtub" target="_blank">wdxtub</a><ul></ul><a href="http://www.yinwang.org" title="yinwang" target="_blank">yinwang</a><ul></ul><a href="http://coolshell.cn/" title="coolshell" target="_blank">coolshell</a><ul></ul><a href="http://lucida.me/" title="lucida" target="_blank">lucida</a><ul></ul><a href="http://www.zreading.cn/" title="左岸读书" target="_blank">左岸读书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a>2017 </a><a href="/." rel="nofollow">tinylcy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>